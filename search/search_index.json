{"config":{"lang":["ro"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bun venit la Arhiva Educationala RoAlgo","text":"<p>O Arhiv\u0103 Educa\u021bional\u0103 creat\u0103 de comunitatea RoAlgo, centrat\u0103 \u00een jurul serverului de Discord cu acela\u0219i nume.</p> <p>Scopul acestui proiect este de a crea cea mai complet\u0103 arhiv\u0103 educa\u021bional\u0103 pentru un student interesat de programarea competitiv\u0103, concentr\u00e2ndu-se, de asemenea, pe subiectele care apar frecvent \u00een s\u0103lile de clas\u0103, concursurile \u0219i olimpiadele de informatic\u0103 din Rom\u00e2nia.</p>"},{"location":"#ce-este-arhiva-educationala","title":"Ce este arhiva educa\u021bional\u0103?","text":"<p>Arhiva educa\u021bional\u0103 RoAlgo este f\u0103cut\u0103 cu scopul realiz\u0103ri uneri surse de calitate despre algoritmi pentru olimpiada de informatic\u0103</p>"},{"location":"licenta/","title":"Licen\u021b\u0103","text":"<p>Con\u021binutul acestui proiect este licen\u021biat sub Creative Commons Attribution-NonCommercial-ShareAlike (CC BY-NC-SA). Pute\u021bi copia, distribui \u0219i modifica materialul nostru at\u00e2ta timp c\u00e2t ne men\u021biona\u021bi ca surs\u0103, nu folosi\u021bi materialul \u00een scopuri comerciale \u0219i distribui\u021bi lucr\u0103rile derivate sub aceea\u0219i licen\u021b\u0103. Pentru detalii, consulta\u021bi licen\u021ba complet\u0103 aici.</p> <p>Codul scris pentru acest proiect este licen\u021biat sub European Union Public License versiunea 1.2 (EUPL v1.2). Aceasta v\u0103 permite s\u0103 folosi\u021bi, modifica\u021bi \u0219i distribui\u021bi codul, cu condi\u021bia ca orice lucrare derivat\u0103 s\u0103 fie distribuit\u0103 sub aceea\u0219i licen\u021b\u0103. Pentru detalii, consulta\u021bi licen\u021ba complet\u0103 aici.</p> <p>Astfel, pentru arhiva noastr\u0103 educa\u021bional\u0103 de algoritmi de programare explica\u021bi:</p> <ul> <li> Text \u0219i explica\u021bii: Licen\u021biate sub Creative Commons Attribution-NonCommercial-ShareAlike (CC BY-NC-SA). Men\u021biona\u021bi sursa, nu folosi\u021bi comercial \u0219i distribui\u021bi sub aceea\u0219i licen\u021b\u0103. Consulta\u021bi licen\u021ba complet\u0103. </li> <li> Cod surs\u0103: Licen\u021biat sub European Union Public License versiunea 1.2 (EUPL v1.2). Folosi\u021bi, modifica\u021bi \u0219i redistribui\u021bi cu men\u021binerea acelea\u0219i licen\u021be pentru lucr\u0103rile derivate. Consulta\u021bi licen\u021ba complet\u0103. </li> </ul> <p>Aceste licen\u021be asigur\u0103 accesibilitatea \u0219i colaborarea, protej\u00e2nd \u00een acela\u0219i timp \u00eempotriva utiliz\u0103rii comerciale neautorizate.</p>"},{"location":"dificil/centroid_decomposition/","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Centroid Decomposition</li> </ul>"},{"location":"dificil/fenwick-tree/","title":"Fenwick tree","text":""},{"location":"dificil/fenwick-tree/#ce-este-un-arbore-indexat-binar","title":"Ce este un Arbore Indexat Binar?","text":"<p>Arborii indexa\u021bi binar (prescurta\u021bi de regul\u0103, AIB) sunt o structur\u0103 de date ce poate fi folosit\u0103 pentru a actualiza eficient valori \u0219i pentru a calcula sume par\u021biale \u00eentr-un tablou de valori ce poate avea una sau mai multe dimensiuni. </p> <p>De\u0219i arborii indexa\u021bi binar nu \u00eenlocuiesc vreo structur\u0103 de date propriu-zis\u0103 (tot ce poate face un AIB poate face \u0219i un arbore de intervale), marele lor avantaj este dat de faptul c\u0103 implementarea lor este foarte u\u0219oar\u0103 \u0219i constanta folosit\u0103 de ace\u0219tia este una mult redus\u0103 fa\u021b\u0103 de arborii de intervale, fiind de c\u00e2teva ori mai rapizi \u0219i consum\u00e2nd de \\(2-4\\) ori mai pu\u021bin\u0103 memorie, \u00een func\u021bie de implementare. </p>"},{"location":"dificil/fenwick-tree/#cum-functioneaza-un-arbore-indexat-binar","title":"Cum func\u021bioneaz\u0103 un Arbore Indexat Binar?","text":"<p>Pentru a putea folosi un AIB, trebuie s\u0103 folosim un vector, unde aib[i] reprezint\u0103 valoarea pe care o stoc\u0103m pe pozi\u021bia \\(i\\). A\u0219a cum \u00eei zice \u0219i numele, fiecare pozi\u021bie \\(i\\) va \u021bine rezultatele pe un interval egal cu \\(2^{zeroes}\\), unde \\(zeroes\\) reprezint\u0103 num\u0103rul de zerouri de la finalul reprezent\u0103rii binare a lui \\(i\\). Aceast\u0103 expresie ne ajut\u0103 s\u0103 adun\u0103m sau s\u0103 sc\u0103dem valoarea celui mai nesemnificativ bit de \\(1\\) din \\(i\\) pentru a putea opera actualiz\u0103rile \u0219i query-urile.</p> <p>Motivul pentru care se folose\u0219te reprezentarea binar\u0103 a nodurilor este acela c\u0103 \u00een acest mod, se garanteaz\u0103 complexitatea logaritmic\u0103 a opera\u021biilor men\u021bionate mai sus (update \u0219i query), precum \u0219i \u00een practic\u0103 o constant\u0103 foarte bun\u0103 datorit\u0103 num\u0103rului redus de bi\u021bi pe care \u00eel au numerele \u00een binar. </p> <p>Observa\u021bie: Arborii indexa\u021bi binar sunt mereu indexa\u021bi de la \\(1\\), deoarece altfel, am avea de-a face cu \\(0\\), care nu are un bit nesemnificativ egal cu \\(1\\).</p>"},{"location":"dificil/fenwick-tree/#cum-functioneaza-operatia-de-update","title":"Cum func\u021bioneaz\u0103 opera\u021bia de update?","text":"<p>S\u0103 presupunem c\u0103 avem un AIB cu \\(16\\) noduri \u0219i vrem s\u0103 actualiz\u0103m valoarea de la pozi\u021bia \\(3\\). Pentru a putea face asta, vom rula urm\u0103torul algoritm, c\u00e2t timp valoarea curent\u0103 nu e mai mare dec\u00e2t num\u0103rul de noduri:</p> <ul> <li>actualiz\u0103m valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>adun\u0103m \\(2^{lsb}\\) la valoarea curent\u0103</li> </ul> <p>De exemplu, pentru nodul \\(3\\) vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>\\(3\\) - pozi\u021bia celui mai nesemnificativ bit este \\(0\\), adun\u0103m \\(2^0 = 1\\) la pozi\u021bie</li> <li>\\(4\\) - pozi\u021bia celui mai nesemnificativ bit este \\(2\\), adun\u0103m \\(2^2 = 4\\) la pozi\u021bie</li> <li>\\(8\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), adun\u0103m \\(2^3 = 8\\) la pozi\u021bie</li> <li>\\(16\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), adun\u0103m \\(2^4 = 16\\) la pozi\u021bie, algoritmul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de update este \\(O(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar. </p>"},{"location":"dificil/fenwick-tree/#cum-functioneaza-operatia-de-query","title":"Cum func\u021bioneaz\u0103 opera\u021bia de query?","text":"<p>\u00cen mod similar fa\u021b\u0103 de opera\u021bia de update, opera\u021bia de query va rula folosindu-se de reprezentarea binar\u0103 a pozi\u021biei de la care vrem s\u0103 facem query-ul. Este de remarcat faptul c\u0103 dac\u0103 vrem s\u0103 rul\u0103m un query pe intervalul \\([L, R]\\), va trebui s\u0103 sc\u0103dem din rezultatul ob\u021binut p\u00e2n\u0103 la pozi\u021bia \\(R\\), rezultatul ob\u021binut la pozi\u021bia \\(L - 1\\), din cauza faptului c\u0103 informa\u021bia stocat\u0103 \u00een nodurile din AIB nu este suficient de complex\u0103 pentru a putea fi ob\u021binut\u0103 cu o singur\u0103 rutin\u0103 de interogare. Totodat\u0103, aceast\u0103 abordare este similar\u0103 cu cea de la sumele par\u021biale, unde ob\u021binerea lor presupune din nou dou\u0103 calcule, \u00een loc de unul singur.</p> <p>Mai jos prezint algoritmul general \u0219i un exemplu de aplicare al acestuia, pentru valoarea \\(13\\).</p> <ul> <li>adun\u0103m la rezultat valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>sc\u0103dem \\(2^{lsb}\\) din valoarea curent\u0103.</li> </ul> <p>De exemplu, pentru nodul \\(13\\) vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>\\(13\\) - pozi\u021bia celui mai nesemnificativ bit este \\(0\\), sc\u0103dem \\(2^0 = 1\\) din pozi\u021bie</li> <li>\\(12\\) - pozi\u021bia celui mai nesemnificativ bit este \\(2\\), sc\u0103dem \\(2^2 = 4\\) din pozi\u021bie</li> <li>\\(8\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), sc\u0103dem \\(2^3 = 8\\) din pozi\u021bie, am ajuns la \\(0\\), deci calculul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de query este \\(O(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar. </p>"},{"location":"dificil/fenwick-tree/#implementarea-in-c","title":"Implementarea \u00een C++","text":"<p>Un mare avantaj al arborilor indexa\u021bi binar este acela c\u0103 implementarea lor este una foarte scurt\u0103, fiind necesare doar c\u00e2teva r\u00e2nduri pentru a putea fi implementa\u021bi.</p> <pre><code>long long fenwick[100002];\nvoid update(int node, int value)\n{\n    for(int i = node; i &lt;= n; i += (i &amp; (-i)))\n        fenwick[i] += value;\n}\nlong long compute(int node)\n{\n    long long ans = 0;\n    for(int i = node; i &gt; 0; i -= (i &amp; (-i)))\n        ans += fenwick[i];\n    return ans;\n}\n</code></pre>"},{"location":"dificil/fenwick-tree/#probleme-rezolvate","title":"Probleme rezolvate","text":""},{"location":"dificil/fenwick-tree/#problema-inv","title":"Problema inv","text":"<p>Se d\u0103 un \u015fir \\(S\\) de lungime \\(n\\) cu numere \u00eentregi. Numim o inversiune o pereche de indici \\((i, j)\\) astfel \u00eenc\u00e2t \\(1 \\leq i &lt; j \\leq n\\) \u015fi \\(S_i &gt; S_j\\). S\u0103 se determine c\u00e2te inversiuni sunt \u00een \u015firul dat.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, putem folosi orice structur\u0103 de date ce ne permite s\u0103 actualiz\u0103m valoarea unei pozi\u021bii \u0219i s\u0103 rul\u0103m query-uri de sum\u0103 pe un interval. \u00cen cazul problemei noastre, vom vrea pentru fiecare valoare din \u0219ir s\u0103 afl\u0103m num\u0103rul de valori de la st\u00e2nga care sunt mai mari dec\u00e2t valoarea curent\u0103, lucru ce se poate realiza afl\u00e2nd pentru valoarea curent\u0103, pozi\u021bia ei \u00een \u0219irul sortat \u0219i proces\u00e2nd un query de sum\u0103 pe intervalul \\([poz + 1, n]\\), unde \\(poz\\) este pozi\u021bia \u00een vectorul sortat a celei mai din dreapta valori din \u0219ir egal\u0103 cu valoarea de la pozi\u021bia curent\u0103. </p>"},{"location":"dificil/fenwick-tree/#problema-goal-statistics","title":"Problema Goal Statistics","text":"<p>Se dau \\(q\\) opera\u021bii, opera\u021bia de update adaug\u0103 o valoare egal\u0103 cu \\(k\\), iar opera\u021bia de query cere suma celor mai mici \\(p\\) valori din \u0219ir. </p> <p>Aceast\u0103 problem\u0103 este din nou un exemplu clasic de folosire a structurilor de date, iar \u00eenc\u0103 o dat\u0103, arborii indexa\u021bi binari se dovedesc a fi solu\u021bia potrivit\u0103 pentru aceast\u0103 problem\u0103, datorit\u0103 vitezei de implementare \u0219i a u\u0219urin\u021bei de folosire. Pentru a afla suma celor mai mici \\(p\\) valori din \u0219ir, vom c\u0103uta binar r\u0103spunsul, folosind o metod\u0103 similar\u0103 cu cea descris\u0103 mai sus. De\u0219i c\u0103utarea binar\u0103 naiv\u0103 \u00een \\(O(\\log^2 n)\\) ia punctajul maxim, se recomand\u0103 c\u0103utarea binar\u0103 \u00een \\(O(\\log n)\\).</p> <p>Solu\u021bia de \\(100\\)</p>"},{"location":"dificil/fenwick-tree/#alte-aplicatii-si-resurse-suplimentare","title":"Alte aplica\u021bii \u0219i resurse suplimentare","text":"<ul> <li>Fenwick Tree</li> <li>Fenwick Tree</li> <li>Goal Statistics</li> <li>inv</li> <li>Understanding Fenwick Trees</li> <li>Binary Indexed Trees</li> </ul>"},{"location":"dificil/heavy_light_decomposition/","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Heavy Light Decomposition</li> </ul>"},{"location":"dificil/small_to_large/","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Small-to-large</li> </ul>"},{"location":"dificil/trie/","title":"Trie","text":"<p>Autor: Matei Ionescu</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#ce-este-un-trie","title":"Ce este un Trie","text":"<p>Un trie (sau arbore de prefixe) este un arbore de c\u0103utare \\(k\\)-ar (un arbore cu r\u0103d\u0103cin\u0103 unde fiecare nod are maxim \\(k\\) fii), reprezent\u00e2nd un mod unic de a memora informa\u021biile, numite \u0219i chei.</p> <p>Num\u0103rul de fii al unui nod este \u00een mare parte influen\u021bat de tipul informa\u021biilor memorate, dar de cele mai multe ori, un Trie este folosit pentru re\u021binerea \u0219irurilor de caractere, astfel fiecare nod av\u00e2nd maxim \\(26\\) fii.</p> <p>Ini\u021bial arborele con\u021bine doar un singur nod, r\u0103d\u0103cina, urm\u00e2nd ca apoi cuvintele s\u0103 fie introduse \u00een ordinea citirii lor, de la st\u00e2nga la dreapta. Observ\u0103m c\u0103 \u00een\u0103l\u021bimea arborelui este lungimea maxim\u0103 a unui cuv\u00e2nt. Complexitatea de timp este \\(O(L)\\), unde \\(L\\) este lungimea maxim\u0103, iar memoria consumat\u0103, \u00een cel mai r\u0103u caz, este \\(O({ \\cdot k)\\).</p> Un exemplu de trie pentru cuvintele am, bad, be \u0219i so","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#moduri-de-implementare","title":"Moduri de implementare","text":"<p>Exist\u0103 dou\u0103 modalit\u0103\u021bi standard prin care putem implementa un Trie, folosind pointeri sau vectori. Ambele func\u021bioneaz\u0103 la fel de bine, \u00eens\u0103 opera\u021bia de delete este mai greu de implementat cu vectori.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#prin-pointeri","title":"Prin pointeri","text":"<p>Ne vom folosi de o structur\u0103 unde vom re\u021bine un contor reprezent\u00e2nd de c\u00e2te ori am trecut prin nodul curent, c\u00e2t \u0219i un vector de pointeri, reprezent\u00e2nd fiii nodului curent.</p> <pre><code>struct Trie {\n    int cnt;\n    Trie *fii[26];\n\n    Trie() : cnt{0} {\n        for (int i = 0; i &lt; 26; ++i) {\n            fii[i] = nullptr;\n        }\n    }\n\n    ~Trie() {\n        for (int i = 0; i &lt; 26; ++i) {\n            delete fii[i];\n        }\n    }\n};\n\nTrie *root = new Trie;\n</code></pre> <p>Opera\u021bia de insert poate fi foarte u\u0219or scris\u0103 recursiv.</p> <pre><code>void insert(Trie *node, string a, int poz) {\n    if (poz == a.size()) {\n        node-&gt;cnt++;\n        return;\n    }\n\n    int index = a[poz] - 'a';\n    if (node-&gt;fii[index] == nullptr) {\n        node-&gt;fii[index] = new Trie();\n    }\n\n    insert(node-&gt;fii[index], a, poz + 1);\n}\n</code></pre> <p>\u00cen momentul \u00een care am ajuns la un nod \\(node\\) \u00een arbore, verific\u0103m dac\u0103 exist\u0103 fiul pentru caracterul urm\u0103tor \u0219i dac\u0103 nu exist\u0103, \u00eel ad\u0103ug\u0103m \u00een arbore, apoi apel\u0103m recursiv p\u00e2n\u0103 ajungem la finalul stringului. </p> <p>Pentru a elimina un string din trie ne mai trebuie o informa\u021bie suplimentar\u0103, \u0219i anume s\u0103 \u0219tim c\u00e2\u021bi fii are un nod. A\u0219adar, dac\u0103 am eliminat un sufix al \u0219irului \u0219i nodul curent nu mai are fii nici nu mai este vizitat prin alt \u0219ir inserat, putem da erase complet la pointerul respectiv. </p> <pre><code>bool del(Trie *node, string a, int pos) {\n    int idx = a[pos] - 'a';\n    if (pos == a.size()) {\n        node-&gt;cnt--;\n    } else if (del(node-&gt;fii[idx], a, pos + 1)) {\n        node-&gt;nrf--;\n        node-&gt;fii[idx] = nullptr;\n    }\n\n    if (node-&gt;cnt == 0 &amp;&amp; node-&gt;nrf == 0 &amp;&amp; node != t) {\n        delete node;\n        return 1;\n    }\n\n    return 0;\n}\n</code></pre> <p>Restul opera\u021biilor se implementeaz\u0103 similar, practic baza tuturor opera\u021biilor st\u0103 \u00een modul de a parcurge trie-ul.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#prin-vectori","title":"Prin vectori","text":"<p>\u00cen loc de o structur\u0103 vom folosi un vector cu \\(k\\) coloane. \u00cen fiecare element din vector vom re\u021bine pozi\u021bia fiului respectiv.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26, -1));\n</code></pre> <p>Astfel <code>trie[node][5]</code> va fi egal cu pozi\u021bia \u00een vectorul trie pentru al cincilea fiu a lui <code>node</code>.</p> <p>Opera\u021bia de inserare este foarte similar\u0103 fa\u021b\u0103 de cea precedent\u0103, singurul lucru care difer\u0103 este modul de implementare. \u00cen acest caz ne este mult mai u\u0219or s\u0103 folosim o func\u021bie care s\u0103 itereze propriu-zis prin \u0219irul de caractere.</p> <pre><code>vector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26, -1));\nvector&lt;int&gt; cnt(1);\n\nvoid insert(string a) {\n    int root = 0;\n    for (const char i : a) {\n        int idx = i - 'a';\n        if (trie[root][idx] == -1) {\n            trie[root][idx] = trie.size();\n            trie.emplace_back(26, -1);\n            cnt.push_back(0);\n        }\n        cnt[root]++;\n        root = trie[root][idx];\n    }\n    cnt[root]++;\n}\n</code></pre> <p>Observ\u0103m faptul c\u0103 increment\u0103m \u0219i la final contorul.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#trie-pe-biti","title":"Trie pe bi\u021bi","text":"<p>Unele probleme necesit\u0103 re\u021binerea numerelor \u00eentr-o structur\u0103 de date, cum ar fi un trie, \u00eensa vom \u00eenlocui \u0219irurile de caractere cu reprezentarea binar\u0103 a numerelor.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#problema-xormax-de-pe-kilonova-usoara","title":"Problema xormax de pe Kilonova (u\u0219oar\u0103)","text":"<p>Un exemplu bun este chiar problema xormax, unde ni se d\u0103 un vector cu \\(N\\) elemente \u0219i trebuie s\u0103 afl\u0103m care este suma xor maxim\u0103 a unui interval. Suma xor a unui interval cu capetele \\([L, R]\\) este valoarea  \\(v_L \\oplus v_{L+1} \\oplus \\dots \\oplus v_R\\), unde \\(\\oplus\\) este operatorul xor pe bi\u021bi.</p> <p>Pentru a rezolva problema putem parcurge vectorul de la st\u00e2nga la dreapta \u0219i s\u0103 aflam pentru fiecare \\(1 \\leq i \\leq N\\) care este suma xor maxim\u0103 a unui interval care se termin\u0103 \u00een \\(i\\). Dac\u0103 construim vectorul \\(xp\\), unde \\(xp[i] = v_1 \\oplus v_2 \\oplus \\dots \\oplus v_{i-1} \\oplus v_i\\), atunci suma xor pe intervalul \\([L, R]\\) este egal\u0103 cu \\(xp[R] \\oplus xp[L-1]\\). Observ\u0103m c\u0103 pentru un \\(R\\) fixat trebuie s\u0103 g\u0103sim care este \\(L\\)-ul care maximizeaz\u0103 rela\u021bia de mai sus. Pentru a face asta putem s\u0103 introducem primii \\(R-1\\) \\(xp\\)-uri \u00eentr-un trie pe bi\u021bi \u0219i s\u0103 c\u0103ut\u0103m bit cu bit, \u00eencep\u00e2nd cu bitul semnificativ, \\(xp\\)-ul care va maximiza rezultatul.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nconst int N = 2e5 + 1;\n\nvector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(2, -1));\n\nint n, v[N], xp[N];\n\nint find(int nr) {\n    int root = 0;\n    int ans = 0;\n    for (int bit = 31; bit &gt;= 0; bit--) {\n        bool b = (nr &amp; (1 &lt;&lt; bit));\n        if (trie[root][!b] == -1) {\n            if (trie[root][b] == -1) {\n                return ans;\n            } else {\n                root = trie[root][b];\n            }\n        } else {\n            ans += (1 &lt;&lt; bit);\n            root = trie[root][!b];\n        }\n    }\n    return ans;\n}\n\nvoid insert(int nr) {\n    int root = 0;\n    for (int bit = 31; bit &gt;= 0; bit--) {\n        bool b = (nr &amp; (1 &lt;&lt; bit));\n        if (trie[root][b] == -1) {\n            trie[root][b] = trie.size();\n            trie.emplace_back(2, -1);\n        }\n        root = trie[root][b];\n    }\n}\n\nint main() {\n    cin.tie(nullptr)-&gt;sync_with_stdio(nullptr);\n    cin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n        xp[i] = xp[i - 1] ^ v[i];\n    }\n\n    int ans = 0;\n    insert(0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        int res = find(xp[i]);\n        ans = max(ans, res);\n        insert(xp[i]);\n    }\n\n    cout &lt;&lt; ans;\n}\n</code></pre> <p>O variant\u0103 care se folose\u0219te de implementarea cu pointeri este urm\u0103toarea:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nstruct Trie {\n    Trie *_next[2];\n    int _pos;\n\n    explicit Trie(const int value)\n        : _pos{value}\n        , _next{nullptr, nullptr} {}\n\n    Trie() : Trie{-1} {}\n\n    ~Trie() {\n        delete _next[0];\n        delete _next[1];\n    }\n} *root;\n\n\nvoid add(const int val, const int idx) {\n    Trie *node = root;\n\n    for (int i = 29; i &gt;= 0; i--) {\n        bool has = (val &gt;&gt; i) &amp; 1;\n        if (node-&gt;_next[has] == nullptr)\n            node-&gt;_next[has] = new Trie(idx);\n        node = node-&gt;_next[has];\n    }\n}\n\nint query(const int val) {\n    Trie *node = root;\n\n    for (int i = 29; i &gt;= 0; i--) {\n        bool has = (val &gt;&gt; i) &amp; 1;\n        if (node-&gt;_next[!has])\n            node = node-&gt;_next[!has];\n        else if (node-&gt;_next[has])\n            node = node-&gt;_next[has];\n        else\n            break;\n    }\n    return node-&gt;_pos;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    root = new Trie(0);\n\n    int n, x, sum = 0, value = 0;\n    cin &gt;&gt; n;\n    vector&lt;int&gt; sums(n + 1);\n\n    add(sum, 0);\n\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; x;\n        sum ^= x;\n        sums[i] = sum;\n\n        value = max(value, x);\n\n        if (i &gt; 1) {\n            int qry = query(sum);\n            value = max(value, sum ^ sums[qry]);\n        }\n\n        add(sum, i);\n    }\n\n    cout &lt;&lt; value;\n\n    delete root;\n\n    return 0;\n}\n</code></pre>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#problema-xor-construction-medie","title":"Problema XOR Construction (medie)","text":"<p>\u00cen aceast\u0103 problem\u0103 ni se dau \\(n-1\\) numere, unde al \\(i\\)-lea are valoarea \\(a_i\\), iar noi trebuie s\u0103 construim alt vector \\(b\\), cu \\(n\\) elemente, astfel \u00eenc\u00e2t s\u0103 existe toate numerele de la \\(0\\) la \\(n-1\\) \u00een \\(b\\), iar \\(b_i \\oplus b_{i+1} = a_i\\).</p> <p>\u00cen primul r\u00e2nd, dac\u0103 \\(b_i = 0\\) atunci \\(b_{i+1} = a_i\\), \\(b_{i+1} \\oplus b_{i+2} = a_{i+1}\\) , deci \\(b_{i+2} = a_i \\oplus a_{i+1}\\) \u0219i \\(b_{i+3} = a_i \\oplus a_{i+1} \\oplus a_{i+2}\\). Prin urmare deducem o form\u0103 general\u0103 pentru \\(b_j\\), unde \\(i &lt; j\\) , \u0219i anume \\(b_j = a_i \\oplus a_{i+1} \\oplus a_{i+2} \\oplus \\dots \\oplus a_{j-1}\\). Proprietatea se respect\u0103 \u0219i pentru oricare \\(j &lt; i\\), avem \\(b_j = a_j \\oplus a_{j+1} \\oplus \\dots \\oplus a_{i-1}\\).</p> <p>\u00cen al doilea r\u00e2nd, enun\u021bul problemei asigur\u0103 faptul c\u0103 mereu va exista solu\u021bie. Dar c\u00e2nd nu avem solu\u021bie? P\u0103i \u00een momentul \u00een care se repet\u0103 dou\u0103 elemente \u00een vectorul \\(b\\), ceea ce \u00eenseamn\u0103 faptul c\u0103 trebuie s\u0103 existe o secven\u021b\u0103 cu suma xor egal\u0103 cu \\(0\\). Pentru simplitate vom spune c\u0103 pe pozi\u021bia \\(k\\) va fi \\(b_k = 0\\). Dac\u0103 \\(i &lt; j\\) \u0219i \\(b_i = b_j\\) \u0219i \\(j &lt; k\\), atunci \\(a_i \\oplus a_{i+1} \\oplus a_{i+2} \\oplus \\dots \\oplus a_{j-1} = 0\\), analog pentru \\(i &gt; j &gt; k\\). Dac\u0103 \\(i &lt; k &lt; j\\) \u0219i \\(b_i = b_j\\) atunci \\(b_i = a_i \\oplus a_{i+1} \\oplus \\dots \\oplus a_{k-1}\\), \\(b_j = a_k \\oplus a_{k+1} \\dots \\oplus a_{j-1}\\). Prin urmare \\(a_i \\oplus a_{i+1} \\oplus \\dots \\oplus a_{j-1} = 0\\). A\u0219adar, \u0219tim ca mereu \u00een vectorul \\(b\\) elementele vor fi distincte.</p> <p>\u00cen al treilea r\u00e2nd, observ\u0103m c\u0103 vectorul \\(b\\) este generat \u00een func\u021bie de ce valoare are \\(k\\). Deci o prim\u0103 idee ar fi s\u0103 fix\u0103m mai \u00eent\u00e2i unde vom pune \\(0\\)-ul \u00een vectorul \\(b\\) \u0219i s\u0103-l construim \u00een \\(O(n)\\), complexitatea temporal\u0103 fiind \\(O(n^2)\\). Dar putem s\u0103 ne folosim de a doua observa\u021bie, \u0219i anume c\u0103 mereu vectorul \\(b\\) va avea elementele distincte. Deci ne este suficient s\u0103 \u0219tim care va fi valoarea maxim\u0103 din \\(b\\) dac\u0103 \\(0\\)-ul se afl\u0103 pe pozi\u021bia \\(k\\). Pentru a face asta putem s\u0103 folosim 2 trie-uri, unul pentru sufix, altul pentru prefix, complexitatea final\u0103 devenind \\(O(n \\log n)\\).</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nconst int N = 2e5 + 1;\n\nint n;\nvector&lt;int&gt; v(N), ans(N);\nvector&lt;int&gt; xr1(N), xr2(N);\n\nvector&lt;vector&lt;int&gt;&gt; trie1(1, vector&lt;int&gt;(2, -1)),\n                    trie2(1, vector&lt;int&gt;(2, -1));\n\nvector&lt;int&gt; maxim1(N), maxim2(N);\n\nvoid insert(vector&lt;vector&lt;int&gt;&gt; &amp;trie, int nr) {\n    int root = 0;\n    for (int i = 30; i &gt;= 0; i--) {\n        bool bit = (nr &amp; (1 &lt;&lt; i));\n        if (trie[root][bit] == -1) {\n            trie[root][bit] = trie.size();\n            trie.push_back(vector&lt;int&gt;(2, -1));\n        }\n        root = trie[root][bit];\n    }\n\n}\n\nint get_max(vector&lt;vector&lt;int&gt;&gt; &amp;trie, int nr) {\n    int ans = 0;\n    int root = 0;\n    for (int i = 30; i &gt;= 0; i--) {\n        bool bit = (nr &amp; (1 &lt;&lt; i));\n        if (trie[root][!bit] != -1) {\n            ans += (1 &lt;&lt; i);\n            root = trie[root][!bit];\n        } else if (trie[root][bit] != -1) {\n            root = trie[root][bit];\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin &gt;&gt; n;\n    int xr = 0;\n    for (int i = 1; i &lt; n; i++) {\n        cin &gt;&gt; v[i];\n        xr1[i] = xr1[i - 1] ^ v[i];\n    }\n    for (int i = n - 1; i &gt;= 1; i--) {\n        xr2[i] = xr2[i + 1] ^ v[i];\n    }\n\n    maxim1[1] = 0;\n    maxim2[n] = 0;\n    insert(trie1, xr2[1]);\n\n    for (int i = 2; i &lt;= n; i++) {\n        maxim1[i] = get_max(trie1, xr2[i]);\n        insert(trie1, xr2[i]);\n    }\n\n    insert(trie2, xr1[n - 1]);\n    for (int i = n - 2; i &gt;= 0; i--) {\n        maxim2[i] = get_max(trie2, xr1[i]);\n        insert(trie2, xr1[i]);\n    }\n\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (max(maxim1[i], maxim2[i - 1]) == n - 1) {\n            int xr1 = 0, xr2 = 0;\n            vector&lt;int&gt; fr(2 * n + 1);\n            fr[0] = 1;\n            ans[i] = 0;\n            for (int j = i - 1; j &gt;= 1; j--) {\n                ans[j] = v[j] ^ ans[j + 1];\n                xr1 ^= v[j];\n                fr[ans[j]]++;\n                if (fr[ans[j]] &gt;= 2) {\n                    break;\n                }\n            }\n            for (int j = i; j &lt; n; j++) {\n                ans[j + 1] = v[j] ^ xr2;\n                xr2 ^= v[j];\n                fr[ans[j + 1]]++;\n                if (fr[ans[j + 1]] &gt;= 2) {\n                    break;\n                }\n            }\n            int ok = 1;\n            for (int j = 0; j &lt; n; j++) {\n                if (fr[j] != 1) {\n                    ok = 0;\n                    break;\n                }\n            }\n            if (1) {\n                for (int j = 1; j &lt;= n; j++) {\n                    cout &lt;&lt; ans[j] &lt;&lt; \" \";\n                }\n                return 0;\n            }\n        }\n    }\n}\n</code></pre>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#problema-cuvinte-medie-grea","title":"Problema cuvinte (medie-grea)","text":"<p>Se dau \\(N\\) cuvinte formate doar din primele \\(K\\) litere mici ale alfabetului englez \u0219i un \u0219ir \\(x_i\\), de \\(M\\) numere naturale. Trebuie s\u0103 se formeze \\(M\\) cuvinte astfel \u00eenc\u00e2t oricare cuv\u00e2nt \\((1 \\leq i \\leq M)\\) s\u0103 respecte urm\u0103toarele propriet\u0103\u021bi:</p> <ul> <li>S\u0103 aib\u0103 lungimea \\(x_i\\).</li> <li>S\u0103 fie format doar din primele \\(K\\) litere mici ale alfabetului englez.</li> <li>S\u0103 nu existe \\(j \\leq M,\\, j \\neq i\\), sau un cuv\u00e2nt \\(cuv\\) din cele \\(N\\), astfel   \u00eenc\u00e2t cuv\u00e2ntul \\(j\\) s\u0103 fie prefix pentru cuv\u00e2ntul \\(i\\), sau \\(cuv\\) s\u0103 fie prefix   pentru \\(i\\).</li> <li>*S\u0103 nu existe \\(j \\leq M,\\, j \\neq i\\), sau un cuv\u00e2nt \\(cuv\\) din cele \\(N\\), astfel   \u00eenc\u00e2t cuv\u00e2ntul \\(i\\) s\u0103 fie prefix pentru cuv\u00e2ntul \\(j\\), sau \\(i\\) s\u0103 fie prefix   pentru \\(cuv\\).</li> </ul>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#solutie","title":"Solu\u021bie","text":"<p>Prima idee ar fi s\u0103 sortam vectorul \\(x\\). Fie \\(dp_i\\) = \u00een c\u00e2te moduri putem alege primele \\(i\\) cuvinte. Putem considera toate posibilit\u0103\u021bile de a forma \u0219irurile , iar abia apoi s\u0103 vedem cum elimin\u0103m pe cele care nu sunt bune. Cu alte cuvinte, fie \\((s_1, s_2, .. , s_{i-1})\\) primele \\(i-1\\) cuvinte alese astfel \u00eenc\u00e2t s\u0103 respecte condi\u021biile impuse de problem\u0103. Sunt \u00een total \\(dp_{i-1} \\cdot K^{x_i}\\) moduri de a forma un set de \u0219iruri cu primele \\(i\\) cuvinte.</p> <p>Observa\u021bie</p> <p>Nu exist\u0103 dou\u0103 cuvinte, \\(s_x\\) \u0219i \\(s_y\\), astfel \u00eenc\u00e2t ambele s\u0103 fie prefixe pentru \\(s_i\\).</p> <p>Dac\u0103 ambele ar fi prefixe pentru \\(s_i\\), atunci fie \\(s_x\\) este prefix pentru \\(s_y\\), fie invers, ceea ce este fals, pentru c\u0103 noi am generat primele \\(i-1\\) cuvinte optim.</p> <p>Astfel dac\u0103 pentru fiecare cuv\u00e2nt \\(k\\), \\(k &lt; i\\), putem s\u0103 sc\u0103dem din num\u0103rul total de posibilit\u0103\u021bi \u0219irurile unde \\(s_k\\) este prefix pentru \\(s_i\\), nu vom elimina dou\u0103 configura\u021bii la fel. $$ dp_i = dp_{i-1} \\cdot K^{x_i} - dp_{i-1} \\cdot \\sum_{j = 1}^{i-1} K^{x_i - x_j} $$</p> <p>Observa\u021bie</p> <p>Nu exist\u0103 dou\u0103 cuvinte, unul provenit din cele \\(N\\) date \u0219i cel\u0103lalt (\\(s_k\\)) din primele \\(i-1\\) astfel \u00eenc\u00e2t ambele s\u0103 fie prefixe pentru \\(s_i\\).</p> <p>Dac\u0103 ambele sunt prefixe pentru \\(s_i\\), atunci fie \\(s_k\\) este prefix pentru un cuv\u00e2nt din cele \\(N\\), fie invers.</p> <p>Deci, putem s\u0103 fixam un cuv\u00e2nt din cele \\(N\\) date ini\u021bial \u0219i s\u0103 elimin\u0103m num\u0103rul de posibilit\u0103\u021bi ca el s\u0103 fie prefix pentru \\(s_i\\). Datorit\u0103 observa\u021biei, nu vom elimina o posibilitate dac\u0103 a fost eliminat\u0103 deja \u00een prima etap\u0103.</p> <p>\u00cen mod natural vom zice c\u0103 din dp-ul nostru vom sc\u0103dea \u00een mod similar \\(dp_{i-1} \\cdot \\sum_{j = 1}^{N} K^{x_i - len(j)}\\), unde \\(len(j)\\) = lungimea cuv\u00e2ntului \\(j\\), cu \\(x_i \\geq len(j)\\). \u00cens\u0103 nu este adev\u0103rat, pentru c\u0103 dac\u0103 avem dou\u0103 cuvinte \\(x\\) \u0219i  \\(y\\) , unde \\(x\\) este prefix pentru \\(y\\), atunci suma de mai sus va num\u0103ra 2 configura\u021bii de dou\u0103 ori. Observ\u0103m c\u0103 nou\u0103 ne trebuie practic doar acele cuvinte \\(x\\), pentru care nu exist\u0103 alt cuv\u00e2nt \\(y\\), cu \\(y\\) prefix pentru \\(x\\), iar \\(len(x) \\leq x_i\\).</p> <p>Astfel putem parcurge direct pe Trie-ul cuvintelor. Dac\u0103 suntem la un nod \\(node\\), acesta este cap\u0103tul unui cuv\u00e2nt, iar \\(len(cuv) \\leq x_i\\), atunci putem sc\u0103dea din dp-ul nostru \\(dp_{i-1} \\cdot K^{x_i - len(cuv)}\\) \u0219i s\u0103 oprim parcurgerea. Dac\u0103 suntem la un nod \\(node\\), acesta are lungimea egal\u0103 cu \\(x_i\\), atunci sc\u0103dem din dp \\(dp_{i-1}\\) \u0219i oprim parcurgerea. </p> <p>Cu alte cuvinte, o solu\u021bie \u00een \\(O(M^2 + M \\cdot S)\\) este posibil\u0103, unde \\(S = \\sum_{i=1}^{N} len(i)\\). Putem optimiza solu\u021bia, observ\u00e2nd c\u0103 de fiecare dat\u0103 putem face tranzi\u021biile \u00een \\(O(1)\\). Solu\u021bia final\u0103 devine \\(O(M + S)\\) sau \\(O(M \\cdot \\log + S)\\). </p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod = 1e9 + 7, N = 3e5 + 1;\nstruct Mint\n{\n    int val;\n    Mint(int x = 0)\n    {\n        val = x % mod;\n    }\n    Mint(long long x)\n    {\n        val = x % mod;\n    }\n    Mint operator+(Mint oth)\n    {\n        return val + oth.val;\n    }\n    Mint operator*(Mint oth)\n    {\n        return 1LL * val * oth.val;\n    }\n    Mint operator-(Mint oth)\n    {\n        return val - oth.val + mod;\n    }\n    Mint fp(Mint a, long long n){\n        Mint p = 1;\n        while(n){\n            if(n &amp; 1){\n                p = p * a;\n            }\n            a = a * a;\n            n /= 2;\n        }\n        return p;\n    }\n    Mint operator/(Mint oth){\n        Mint invers = fp(oth, mod - 2);\n        return 1LL * val * invers.val;\n    }\n    friend ostream&amp; operator &lt;&lt; (ostream&amp; os, const Mint&amp; lol){\n        os &lt;&lt; lol.val;\n        return os;\n    }\n};\n\nint n, m, k;\nvector&lt;Mint&gt; dp(N);\nvector&lt;int&gt; x(N), depth(N), cnt1(N);\nvector&lt;vector&lt;int&gt;&gt; trie(1, vector&lt;int&gt;(26,-1));\nvector&lt;bool&gt; cnt(1);\nMint spm = 0;\nMint fp(Mint a, int n){\n    Mint p = 1;\n    while(n){\n        if(n &amp; 1) p = a * p;\n        a = a * a;\n        n /= 2;\n    }\n    return p;\n}\n\nvoid insert(string a){\n    int root = 0;\n    for(int i = 0; i &lt; a.size(); i++){\n        if(trie[root][a[i]-'a'] == -1){\n            trie[root][a[i]-'a'] = trie.size();\n            trie.push_back(vector&lt;int&gt;(26, -1));\n            cnt.push_back(0);\n        }\n        root = trie[root][a[i]-'a'];\n    }\n    cnt[root]=1;\n}\nvoid dfs(int node, int lenx, int len){\n    if(lenx == len){\n        return;\n    }\n    if(cnt[node]){\n        spm = spm + fp(k, lenx - len);\n        return;\n    }\n    for(int i = 0; i &lt; 26; i++){\n        if(trie[node][i] != -1){\n            dfs(trie[node][i], lenx, len + 1);\n        }\n    }\n}\nvoid dfs1(int node, int len){\n    depth[len]++;\n    if(cnt[node]){\n        cnt1[len]++;\n        return;\n    }\n    for(int i = 0; i &lt; 26; i++){\n        if(trie[node][i] != -1){\n            dfs1(trie[node][i], len+1);\n        }\n    }\n}\nint main(){\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    for(int i = 1; i &lt;= n; i++){\n        string a;\n        cin &gt;&gt; a;\n        insert(a);\n    }\n    for(int i = 1; i &lt;= m; i++){\n        cin &gt;&gt; x[i];\n    }\n    sort(x.begin() + 1, x.begin() + 1 + m);\n    dp[1] = fp(k, x[1]);\n    Mint sm = 0;\n    dfs(0, x[1], 0);\n    dfs1(0, 0);\n    dp[1] = dp[1] - depth[x[1]];\n    dp[1] = dp[1] - spm;\n    for(int i = 2; i &lt;= m; i++){\n        dp[i] = dp[i - 1] * fp(k, x[i]);\n        sm = sm * fp(k, x[i]-x[i-1]);\n        sm = sm + fp(k, x[i]-x[i-1]);\n        dp[i] = dp[i] - dp[i-1]*sm;\n        spm = spm * fp(k, x[i]-x[i-1]);\n        for(int j = x[i-1]; j &lt; x[i]; j++){\n            spm = spm + fp(k, x[i] - j) * cnt1[j];\n        }\n        dp[i] = dp[i] - dp[i-1]*depth[x[i]];\n        dp[i] = dp[i] - dp[i-1]*spm;\n    }\n    cout &lt;&lt; dp[m];\n}\n</code></pre>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#problema-cli-medie-grea","title":"Problema cli (medie-grea)","text":"<p>Se dau \\(N\\) cuvinte care trebuie tastate \u00eentr-un terminal. Un cuv\u00e2nt este considerat tastat dac\u0103 el va ap\u0103rea \u00een terminal cel pu\u021bin odat\u0103 pe parcursul tast\u0103rii. Avem dou\u0103 tipuri de opera\u021bii la dispozi\u021bie: ad\u0103ug\u0103m un caracter la finalul \u0219irul tastat deja, elimin\u0103m un caracter de la finalul \u0219irului (dac\u0103 nu este vid). Pentru fiecare \\(i = \\overline{1, K}\\), noi trebuie s\u0103 aflam care este num\u0103rul minim de opera\u021bii pentru a tasta exact \\(i\\) cuvinte distincte dintre cele date. \u00cen momentul \u00een care \u00eencepem s\u0103 tast\u0103m un cuv\u00e2nt, trebuie mereu s\u0103 \u00eencepem de la un \u0219ir vid \\((\\emptyset)\\), \u0219i s\u0103 termin\u0103m tastarea tot la un \u0219ir vid. Un exemplu de tastare corect\u0103 este: \\(\\emptyset \\rightarrow a \\rightarrow ab \\rightarrow abc \\rightarrow ab \\rightarrow a \\rightarrow \\emptyset\\).</p> <p>Ne vom folosi din nou de metoda program\u0103rii dinamice, dar de data asta vom face dp direct pe trie. Astfel, fie \\(dp[nod][i]\\) = num\u0103rul minim de opera\u021bii pentru a tasta \\(i\\) cuvinte cu prefixul format din lan\u021bul de la r\u0103d\u0103cin\u0103 la \\(nod\\). Acum, pentru un nod fixat din trie-ul nostru, putem presupune c\u0103 \u00een momentul tast\u0103rii vom \u00eencepe mereu cu \u0219irul format de la r\u0103d\u0103cin\u0103 la \\(nod\\), \u00een loc de \\(\\emptyset\\). De exemplu, dac\u0103 cuvintele au prefixul \\textit{abab}, atunci noi vom presupune o succesiune valid\u0103 de opera\u021bii: \\(abab \\rightarrow abab\\textbf{c} \\rightarrow \\dots \\rightarrow abab\\textbf{c} \\rightarrow abab\\). Putem deci face un rucsac pentru fiii nodului, \\(dp1[i][j]\\) = care e num\u0103rul minim de opera\u021bii pentru a tasta \\(j\\) cuvinte din primii \\(i\\) fii. Pentru c\u0103 prefixul necesit\u0103 \\(\\text{len}(prefix)\\) opera\u021bii de ad\u0103ugare \u0219i \u0219tergere, vom \u00eencepe \\(dp\\)-ul nostru cu \\(2 \\cdot \\text{len}(prefix)\\) opera\u021bii deja f\u0103cute. Cu alte cuvinte, pentru a tasta \\(0\\) cuvinte vom face \\(dp1[0][0] = 2 \\cdot \\text{len}(prefix)\\). \u00cen momentul \u00een care trecem de la \\(i\\) la \\(i+1\\) avem 2 cazuri: fie nu lu\u0103m fiul respectiv \u00een considerare, fie alegem \\(p\\) \u0219iruri pe care le vom tasta \u00een \\(dp[fiu(i)][p] - 2 \\cdot \\text{len}(prefix)\\) opera\u021bii. </p> <pre><code>for (int i = 1; i &lt;= 26; i++) {\n    for (int k1 = 0; k1 &lt;= min(sz[nod], k); k1++) {\n        dp1[i][k1] = min(dp1[i][k1], dp1[i - 1][k1]);\n\n        const auto nod2 = trie[nod][i - 1];\n        for (int k2 = 1; k2 &lt;= k1 &amp;&amp; nod2 != -1 &amp;&amp; k2 &lt; dp[nod2].size(); k2++) {\n            dp1[i][k1] =\n                min(dp1[i][k1], dp1[i - 1][k1 - k2] + dp[nod2][k2] - 2 * len);\n        }\n    }\n}\n</code></pre> <p>Problema const\u0103 \u00een faptul c\u0103 secven\u021ba de cod de mai sus ruleaz\u0103 pentru fiecare nod din trie, ceea ce ar rezulta \u00eentr-o complexitate de \\(O(N \\cdot K^2)\\). Doar c\u0103, \u00een practic\u0103 solu\u021bia are complexitatea de \\(O(N \\cdot K)\\). \u00cen momentul \u00een care facem rucsac pe un arbore, este foarte important s\u0103 fim aten\u021bi la memoria \u0219i la timpul consumate. Observ\u0103m faptul c\u0103 cele dou\u0103 bucle merg p\u00e2n\u0103 la \\(\\min(sz[nod], k)\\), lucru ce  \u00eembun\u0103t\u0103\u021be\u0219te timpul de execu\u021bie considerabil. Pute\u021bi citi mai multe din solu\u021bia problemei Barricades, iar sursa complet\u0103 o pute\u021bi vizualiza aici.</p>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#resurse-suplimentare","title":"Resurse suplimentare","text":"<ul> <li>Trie (USACO Guide)</li> </ul>","tags":["arbori","structuri de date","strings"]},{"location":"dificil/trie/#probleme","title":"Probleme","text":"<ul> <li>intervalxor2 (Trie pe bi\u021bi persistent. Pute\u021bi face queriurile \u0219i offline)</li> <li>xortree2 (Problem\u0103 ok cu trie pe bi\u021bi)</li> <li>rps (Alt exemplu de dp pe trie)</li> <li>ratina (Lowest Common Ancestor pe trie)</li> <li>aiacupalindroame</li> <li>Facebook Search</li> <li>Perfect Security</li> <li>Collapsing Strings</li> </ul>","tags":["arbori","structuri de date","strings"]},{"location":"mediu/","title":"Mediu","text":"<p>In accesta categorie sunt toate de dificultate medie</p>"},{"location":"mediu/combinatorica/","title":"Introducere \u00een combinatoric\u0103","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, \u0218tefan-Iulian Alecu</p> <p>Combinatorica este una din ramurile principale ale matematicii, precum \u0219i una din cele patru ramuri din care se dau problemele de la olimpiada interna\u021bional\u0103 de matematic\u0103 (IMO) celelalte fiind algebra, teoria numerelor \u0219i geometria. \u00cen algoritmic\u0103 \u0219i \u00een programarea competitiv\u0103, combinatorica se reg\u0103se\u0219te \u00een probleme de nivel mediu \u0219i ridicat, aplica\u021biile diverselor formule matematice, precum \u0219i tehnicile de rezolvare ale problemelor de combinatoric\u0103 fiind un pas important spre des\u0103v\u00e2r\u0219irea abilit\u0103\u021bilor de rezolvare a problemelor algoritmice, deoarece spre deosebire de alte capitole, combinatorica este mai greu de antrenat, iar experien\u021ba c\u0103p\u0103tat\u0103 prin rezolvarea problemelor se va dovedi a fi una crucial\u0103.</p> <p>\u00cen acest capitol vom prezenta cele mai importante formule specifice combinatoricii, o serie de identit\u0103\u021bi \u0219i rela\u021bii care sunt folosite \u00een foarte multe probleme de algoritmic\u0103, precum \u0219i diverse tehnici care au scopul s\u0103 v\u0103 ajute pentru a putea \u00een\u021belege formulele necesare, precum \u0219i s\u0103 v\u0103 ajute pentru a putea rezolva problemele de acest fel \u00eentr-un mod c\u00e2t mai u\u0219or \u0219i intuitiv. \u00cen cadrul olimpiadelor \u0219i concursurilor de informatic\u0103 din Rom\u00e2nia, combinatorica se reg\u0103se\u0219te drept parte esen\u021bial\u0103 \u00een dou\u0103 competi\u021bii - lotul de juniori \u0219i olimpiada clasei a zecea. Ulterior, poate s\u0103 se reg\u0103seasc\u0103 \u0219i ca subprobleme la probele ulterioare de seniori, \u00eentr-o m\u0103sur\u0103 mai mic\u0103.</p> <p>Pentru a putea parcurge acest capitol, recomand\u0103m citirea \u00een prealabil a articolelor despre aritmetica modular\u0103, divizibilitate \u0219i \u00een general s\u0103 ave\u021bi o \u00een\u021belegere a conceptelor matematice din capitolele anterioare. Va fi foarte important\u0103 \u0219i \u00een\u021belegerea conceptului de invers modular, deoarece de\u0219i \u00een cele mai multe probleme vom avea de-a face cu modulo numere prime, uneori va trebui s\u0103 \u0219tim s\u0103 implement\u0103m \u0219i inversul modular.</p>"},{"location":"mediu/combinatorica/#notiuni-teoretice-fundamentale","title":"No\u021biuni teoretice fundamentale","text":""},{"location":"mediu/combinatorica/#regula-sumei-si-a-produsului","title":"Regula sumei \u0219i a produsului","text":"<p>Presupunem pentru urm\u0103toarele dou\u0103 reguli c\u0103 avem dou\u0103 mul\u021bimi \\(A\\) \u0219i \\(B\\) disjuncte (adic\u0103 \\(A\\cap B =\\emptyset\\)), av\u00e2nd cardinalul \\(|A| = n\\) \u0219i \\(|B| = m\\).</p> <p>Regula sumei</p> <p>Num\u0103rul de moduri de a alege o valoare din \\(A\\) sau \\(B\\) este \\(n+m\\).</p> <p>Regula produsului</p> <p>Num\u0103rul de moduri de a alege o pereche de valori, una din \\(A\\) \u0219i una din \\(B\\) este \\(n\\cdot m\\).</p> <p>Aceste rela\u021bii vor fi foarte importante mai ales c\u00e2nd avem de-a face cu formule independente care contribuie la r\u0103spunsul final.</p>"},{"location":"mediu/combinatorica/#permutari","title":"Permut\u0103ri","text":"<p>Permutare</p> <p>O permutare a unei mul\u021bimi reprezint\u0103 o aranjare a elementelor dintr-o mul\u021bime \\(M\\) finit\u0103 \u00eentr-o ordine diferit\u0103. Dac\u0103 cardinalul mul\u021bimii \\(|M| = n\\), num\u0103rul de permut\u0103ri ale unei mul\u021bimi de \\(n\\) valori este \\(n!\\).</p> <p>De exemplu, pentru \\(n = 3\\), cele \\(6\\) permut\u0103ri ale mul\u021bimii \\(\\{1, 2, 3\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 3, 2\\}\\), \\(\\{2, 1, 3\\}\\), \\(\\{2, 3, 1\\}\\), \\(\\{3, 1, 2\\}\\),  \\(\\{3, 2, 1\\}\\)</p> <p>\u00cen probleme, exist\u0103 diverse cazuri particulare ale permut\u0103rilor care devin foarte utile \u00een rezolvarea unor probleme de combinatoric\u0103.</p> <p>Deranjamente</p> <p>Un deranjament este o permutare f\u0103r\u0103 puncte fixe, adic\u0103 \\(\\forall i\\), \\(p_i\\neq i\\).</p> <p>Num\u0103rul de deranjamente cu \\(n\\) elemente este egal cu \\(D_n = (n-1)\\cdot (D_{n-1} + D_{n-2})\\), unde \\(D_0 = 1\\) \u0219i \\(D_1 = 0\\). Acest concept a fost util printre altele la rezolvarea problemei Poseidon, dat\u0103 la OJI 2024, clasa a X-a.</p> <p>Permut\u0103ri cu repeti\u021bii</p> <p>Definim o permutare cu repeti\u021bii ca fiind o secven\u021b\u0103 de \\(n\\) numere, care are  proprietatea c\u0103 fiecare valoare este \u00een intervalul \\([1, n]\\) \u0219i valorile se  pot repeta. Num\u0103rul de permut\u0103ri cu repeti\u021bie cu aceste propriet\u0103\u021bi care au  \\(n\\) elemente este</p> \\[ \\frac{n!}{F_1!\\cdot F_2!\\cdot\\dots\\cdot F_n!} = n!\\prod_{k = 1}^{n}\\frac{1}{F_k!} \\] <p>unde \\(F_i\\) reprezint\u0103 frecven\u021ba la care apare \\(i\\) \u00een permutare.  Acest concept se reg\u0103se\u0219te \u00eentr-un num\u0103r de probleme date \u00een special la  loturile de juniori.</p> <p>Mai jos pute\u021bi g\u0103si o secven\u021b\u0103 de cod pe care o putem folosi pentru a genera toate permut\u0103rile unui \u0219ir. Func\u021bia <code>std::next_permutation</code> nu va genera permut\u0103ri cu repeti\u021bie dac\u0103 acestea apar de mai multe ori.</p> <pre><code>vector&lt;int&gt; v(10);\n\nint i = 1;\n\nfor (auto&amp; x : v) {\n    x = i++;\n}\n\ndo {\n    afiseaza(v);\n} while (next_permutation(v.begin(), v.end()));\n</code></pre>"},{"location":"mediu/combinatorica/#submultimi","title":"Submul\u021bimi","text":"<p>O submul\u021bime a unui num\u0103r const\u0103 \u00een alegerea unui num\u0103r de elemente dintr-o mul\u021bime \\(M\\). Num\u0103rul de submul\u021bimi ale lui \\(M\\) este egal cu \\(2^{|M|}\\), deoarece pentru fiecare element al mul\u021bimii, putem alege dac\u0103 s\u0103 \u00eel includem \u00een submul\u021bimea pe care vrem s\u0103 o cre\u0103m sau nu.</p> <p>Dac\u0103 mul\u021bimea \\(M\\) este egal\u0103 cu \\(\\{0, 1, 1\\}\\), cele \\(8\\) submul\u021bimi ale ei sunt urm\u0103toarele: \\(\\emptyset\\), \\(\\{0\\}\\), \\(\\{0, 1\\}\\), \\(\\{0, 1, 2\\}\\), \\(\\{0, 2\\}\\), \\(\\{1\\}\\), \\(\\{1, 2\\}\\), \\(\\{2\\}\\).</p> <p>Pentru a putea itera prin toate submul\u021bimile unei mul\u021bimi date, ne putem folosi de faptul c\u0103 fiind \\(2^n\\) asemenea submul\u021bimi, putem identifica fiecare submul\u021bime folosind una din reprezent\u0103rile binare ale numerelor de la \\(0\\) la \\(2^n - 1\\), tehnic\u0103 numit\u0103 colocvial bitmasks sau m\u0103\u0219ti pe bi\u021bi. Pentru a vedea dac\u0103 trebuie s\u0103 folosim unul din numere sau nu, trebuie doar verificat pentru o submul\u021bime dat\u0103 dac\u0103 bitul corespunz\u0103tor acelei pozi\u021bii este setat sau nu \u00een masca pe care o verific\u0103m. Pentru mai multe detalii, pute\u021bi vedea codul de mai jos.</p> <pre><code>const int totalSubsets = 1 &lt;&lt; n; // 2^n\n\nfor (int mask = 0; mask &lt; totalSubsets; ++mask) {\n    vector&lt;int&gt; subset;\n\n    for (int idx = 0; idx &lt; n; ++idx) {\n        if (mask &amp; (1 &lt;&lt; idx)) { // (1)\n            subset.push_back(idx);\n        }\n    }\n\n    process(subset);\n}\n</code></pre> <ol> <li>Dac\u0103 bitul din masc\u0103 la pozi\u021bia idx este setat, \u00eenseamn\u0103 c\u0103 elementul de la     indice este prezent \u0219i deci ad\u0103ug\u0103m indicele \u00een submul\u021bime. </li> </ol>"},{"location":"mediu/combinatorica/#aranjamente","title":"Aranjamente","text":"<p>Un aranjament de \\(n\\) elemente luate c\u00e2te \\(k\\) reprezint\u0103 o submul\u021bime ordonat\u0103 a lui \\(A\\) de \\(k\\) elemente. De exemplu, aranjamente de \\(4\\) luate c\u00e2te \\(3\\) ale mul\u021bimii \\(\\{1, 2, 3, 4\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 2, 4\\}\\), \\(\\{1, 3, 4\\}\\), \\(\\{2, 1, 3\\}\\), \\(\\{2, 1, 4\\}\\), \\(\\{2, 3, 4\\}\\), \\(\\{3, 1, 2\\}\\), \\(\\{3, 1, 4\\}\\), \\(\\{3, 2, 4\\}\\), \\(\\{4, 1, 2\\}\\), \\(\\{4, 1, 3\\}\\), \\(\\{4, 2, 3\\}\\)</p> <p>Similar permut\u0103rilor, aranjamentele pot fi considerate func\u021bii injective definite pe mul\u021bimea \\(\\{1, 2, 3,\\dots, k\\}\\) cu valori \u00een \\(\\{1, 2, 3,\\dots, n\\}\\)</p> <p>Num\u0103rul aranjamentelor de \\(n\\) luate c\u00e2te \\(k (k\\leq n)\\) se noteaz\u0103 cu \\(A_n^k\\) \u0219i este egal cu \\(\\(\\frac{n!}{(n-k)!}\\)\\)</p> <p>O alt\u0103 formul\u0103 care poate fi util\u0103 \u00een special \u00een cazul precalcul\u0103rilor este \\(A_n^k = (n - k + 1)\\cdot A_n^{k-1}\\)</p>"},{"location":"mediu/combinatorica/#combinari","title":"Combin\u0103ri","text":"<p>O combinare de \\(n\\) elemente luate c\u00e2te \\(k\\) reprezint\u0103 o submul\u021bime neordonat\u0103 a lui \\(A\\) de \\(k\\) elemente. De exemplu, combin\u0103rile de \\(4\\) luate c\u00e2te \\(3\\) ale mul\u021bimii \\(\\{1, 2, 3, 4\\}\\) sunt urm\u0103toarele: \\(\\{1, 2, 3\\}\\), \\(\\{1, 2, 4\\}\\), \\(\\{1, 3, 4\\}\\), \\(\\{2, 3, 4\\}\\)</p> <p>Se poate observa c\u0103 spre deosebire de aranjamente, dac\u0103 dou\u0103 mul\u021bimi au acelea\u0219i elemente dar \u00eentr-o ordine diferit\u0103, se num\u0103r\u0103 o singur\u0103 dat\u0103.</p> <p>Formula pentru combin\u0103ri de \\(n\\) luate c\u00e2te \\(k\\), care se noteaz\u0103 cu \\(C_n^k\\) (alternativ, ve\u021bi mai putea g\u0103si nota\u021bii precum \\({}_{n}C_{k}\\), \\(C(n, k)\\) sau \\(\\binom{n}{k}\\) este  $$ C_n^k = \\frac{n!}{k!\\cdot (n-k)!} $$ unde \\(C_0^0 = C_n^n = 1\\).</p> <p>Exist\u0103 numeroase moduri \u0219i propriet\u0103\u021bi de a lega valoarea lui \\(C_n^k\\) de alte valori combinatoriale, cele mai importante fiind urm\u0103toarele:</p> <ul> <li>\\(C_{n}^{k} =C_{n-1}^{k} +C_{n-1}^{k-1}\\), deoarece:</li> </ul> \\[ \\begin{align*} C_n^k = \\frac{n!}{k! (n-k)!} &amp;= \\frac{n(n - 1)!}{k! (n-k)!}\\\\ &amp;= \\frac{k(n - 1)!}{k!  (n - k)!} + \\frac{(n-k)(n - 1)!}{k!  (n - k)!}\\\\ &amp;= \\frac{(n - 1)!}{(k - 1)!  (n - k)!} + \\frac{(n - 1)!}{k!  (n - k - 1)!}\\\\ &amp;= C_{n-1}^{k-1} +C_{n-1}^{k} \\end{align*} \\] <ul> <li>Dac\u0103 simplific\u0103m frac\u021biile din formula de mai sus, putem scrie \\(C_n^k\\) ca fiind  $$ C_n^k = \\prod_{i=1}^{k}\\frac{n-i+1}{i} =\\frac{(n-k+1)\\cdot (n-(k - 1) + 1)\\cdots(n-1)\\cdot n}{1\\cdot 2\\cdot 3\\cdots\\cdot k} $$</li> <li>\\(C_{n}^{k} = C_{n}^{n-k}\\), fapt ce se poate observa din aplicarea formulei specifice.</li> <li>\\(\\sum_{i=0}^{n} C_n^i = 2^n\\)</li> </ul> <p>De multe ori, pentru a calcula combin\u0103rile, vom folosi triunghiul lui Pascal drept precalculare, fapt ce \u00eel putem realiza cu ajutorul formulei de mai sus care leag\u0103 \\(C_{n}^{k}\\) de \\(C_{n-1}^{k}\\) \u0219i \\(C_{n-1}^{k-1}\\).</p> <pre><code>const int N = 1000;\n\nint C[N + 1][N + 1];\n\nC[0][0] = 1;\n\nfor (int n = 1; n &lt;= N; n++) {\n    C[n][0] = 1;\n\n    for (int k = 1; k &lt;= n; k++) {\n        if (n == k) {\n            C[n][k] = 1;\n        } else {\n            C[n][k] = C[n-1][k] + C[n-1][k-1];\n        }\n    }\n}\n</code></pre> <p>Exist\u0103 o metod\u0103 mai eficient\u0103 de a calcula \\(C_n^k\\) \u00een timp \\(O(k)\\) \u0219i spa\u021biu \\(O(1)\\):</p> <pre><code>const long long C(int n, int k) {\n    long long res = 1;\n\n    // C(n, k) = C(n, n-k)\n    if (k &gt; n - k) {\n        k = n - k;\n    }\n\n    for (int i = 0; i &lt; k; ++i) {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n</code></pre> <p>\u00cen alte situa\u021bii, va trebui s\u0103 precalcul\u0103m factorialele \u0219i inversele modulare pentru a putea calcula combin\u0103rile, a\u0219a cum vom ar\u0103ta mai jos. Dac\u0103 nu sunte\u021bi familiari cu ridicarea la putere \u00een timp logaritmic, v\u0103 rug\u0103m s\u0103 citi\u021bi articolul pe aceast\u0103 tem\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int N = 100000;\n\nlong long fact[N + 1], inv[N + 1];\n\nconst long long modpow(long long base, long long exponent) {\n    long long result = 1;\n    while (exponent) {\n        if (exponent &amp; 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exponent &gt;&gt;= 1;\n    }\n    return result;\n}\n\nconst long long C(const int n, const int k) {\n    if (k &gt; n || k &lt; 0) {\n        return 0;\n    }\n\n    // C(n, k) = n! * (k!)^-1 * (n - k)!^-1\n    long long result = fact[n];\n    result *= inv[k]; \n    result %= MOD;\n    result *= inv[n - k]; \n    result %= MOD;\n    return result;\n}\n\nvoid precalc() {\n    fact[0] = 1;\n    inv[0] = 1;\n\n    for (int i = 1; i &lt;= N; i++) {\n        fact[i] = (fact[i - 1] * i) % MOD;\n    }\n\n    inv[N] = modpow(fact[N], MOD - 2, MOD); // (1)\n    for (int i = N - 1; i &gt;= 0; --i) {\n        inv[i] = (inv[i + 1] * (i + 1)) % MOD;\n    }\n}\n\n1.  Calcul\u0103m inversul modular $x^{-1} \\mod p$ ($p$ este `MOD` \u00een cod). \u00cen cazul \n    \u00een care $p$ este prim, conform micii teoreme a lui Fermat, $x^{-1} = x^{p - 2}$.\n\nint main() {\n    precalc();\n\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    cout &lt;&lt; C(n, k);\n    return 0;\n}\n</code></pre>"},{"location":"mediu/combinatorica/#partitii","title":"Parti\u021bii","text":"<p>Numim parti\u021bie a unui num\u0103r \\(n\\) o secven\u021b\u0103 de numere naturale nenule \\(P\\) cu proprietatea c\u0103 \\(\\sum_{i = 1}^k P_i = n\\), unde \\(k\\) este num\u0103rul de numere din parti\u021bie. Parti\u021biile unui num\u0103r pot fi ordonate sau neordonate, \u00een func\u021bie de proprietatea pe care dorim s\u0103 o aplic\u0103m \u00eentr-o problem\u0103.</p> <p>Pentru a afla num\u0103rul de parti\u021bii ordonate ale unui num\u0103r \\(n\\), putem s\u0103 ne g\u00e2ndim la num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) stele folosind diferite bare (anticip\u0103m \u00eentr-o oarecare m\u0103sur\u0103 discu\u021bia pe care o vom avea la Stars and Bars), iar dat fiind c\u0103 avem \\(n-1\\) pozi\u021bii unde putem face o \u00eemp\u0103r\u021bire, iar pentru fiecare pozi\u021bie avem posibilitatea de a pune o limit\u0103 sau nu, cu alte cuvinte avem \\(2^{n-1}\\) parti\u021bii ordonate ale unui num\u0103r \\(n\\).</p> <p>\u00cen privin\u021ba parti\u021biilor neordonate, deoarece trebuie s\u0103 p\u0103str\u0103m proprietatea c\u0103 numerele din parti\u021bie sunt cresc\u0103toare, trebuie s\u0103 avem grij\u0103 la calculul num\u0103rului de parti\u021bii de acest tip, iar o prim\u0103 solu\u021bie la aceast\u0103 problem\u0103 const\u0103 \u00een folosirea unei recuren\u021be de tipul \\(p(i, j)\\) = num\u0103rul de parti\u021bii neordonate ale lui \\(i\\), unde lungimea acesteia este \\(j\\). Pentru a putea calcula aceast\u0103 recuren\u021b\u0103, avem o formul\u0103 relativ simpl\u0103.</p> <ul> <li>\\(p(i, j) = p(i-1, j-1) + p(i-j, j)\\), dac\u0103 \\(i\\geq 1\\) \u0219i \\(j\\geq 1\\) (cu alte   cuvinte, fie ad\u0103ug\u0103m un \\(1\\) la \u00eenceputul parti\u021biei, fie increment\u0103m toate   elementele din parti\u021bie).</li> <li>\\(p(i, 0) = 0\\), pentru \\(i\\geq 1\\)</li> <li>\\(p(0, 0) = 1\\).</li> </ul> <p>Complexitatea acestei recuren\u021be este \\(n^2\\), optimizarea ei fiind imposibil\u0103 folosind aceast\u0103 abordare. Din fericire, exist\u0103 o metod\u0103 \u0219i mai rapid\u0103, care folose\u0219te numere pentagonale, abordare ce ne duce la o solu\u021bie \u00een \\(O(n\\sqrt n)\\), pentru mai multe detalii pute\u021bi accesa acest articol sau rezolva problema cresc\u0103tor2. </p>"},{"location":"mediu/combinatorica/#trucuri-pentru-rezolvarea-problemelor-de-combinatorica","title":"Trucuri pentru rezolvarea problemelor de combinatoric\u0103","text":""},{"location":"mediu/combinatorica/#stars-and-bars","title":"Stars and Bars","text":"<p>Tehnica stars and bars este o tehnic\u0103 folosit\u0103 pentru a determina diverse sume combinatoriale care se reduc la aflarea num\u0103rului de solu\u021bii ale ecua\u021biei \\(x_1 + x_2 + ... + x_k = n\\), unde \\(x_i\\) este fie num\u0103r natural pozitiv, fie num\u0103r \u00eentreg non-negativ, reg\u0103sindu-se dou\u0103 cazuri.</p> <p>Num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) obiecte \u00een \\(k\\) grupe, fiecare grup\u0103 av\u00e2nd cel pu\u021bin un element este egal cu \\(C_{n-1}^{k-1}\\), deoarece avem \\(n-1\\) locuri unde putem pune barierele \u0219i trebuie s\u0103 punem \\(k-1\\) bariere pentru a ob\u021bine \\(k\\) grupe.</p> <p>Num\u0103rul de moduri de a \u00eemp\u0103r\u021bi \\(n\\) obiecte \u00een \\(k\\) grupe, dac\u0103 fiecare grup\u0103 poate fi \u0219i goal\u0103 cu \\(C_{n+k-1}^{k-1}\\), deoarece avem \\(n+k-1\\) locuri unde putem pune barierele \u0219i trebuie s\u0103 punem \\(k-1\\) bariere pentru a ob\u021bine \\(k\\) grupe.</p> <p>Aceast\u0103 tehnic\u0103 se g\u0103se\u0219te \u00een diferite aplica\u021bii, de obicei atunci c\u00e2nd vrem s\u0103 grup\u0103m diferite valori sau diferite \u0219iruri, \u00een problemele de num\u0103rare.</p>"},{"location":"mediu/combinatorica/#hockey-stick-identity","title":"Hockey Stick Identity","text":"<p>Pentru dou\u0103 numere \\(n\\) \u0219i \\(r\\), \\(\\sum_{i=r}^{n} C_i^r = C_{n+1}^{r+1}\\). Pentru a demonstra aceast\u0103 rela\u021bie, se pot folosi argumente inductive, algebrice sau metode ce se folosesc de func\u021bii generatoare. Pentru mai multe detalii, pute\u021bi citi acest blog.</p>"},{"location":"mediu/combinatorica/#numerele-catalan","title":"Numerele Catalan","text":"<p>\u00cen combinatoric\u0103, numerele Catalan sunt o serie de numere care apar \u00een diverse probleme, devenind foarte cunoscute \u0219i folosite \u00een aplica\u021bii ce se g\u0103sesc de multe ori la olimpiadele de informatic\u0103 pentru juniori.</p> <p>\u0218irul numerelor Catalan este \\(1, 1, 2, 5, 14, 42, \\dots\\) \u0219i formula pentru aflarea celui de-al \\(i\\)-lea num\u0103r Catalan este:</p> \\[ C_n = \\frac{1}{n+1}\\cdot C_{2n}^{n} =\\frac{(2n)!}{(n+1)! n!} = \\prod_{k = 2}^{n} \\frac{n + k}{k} \\] <p>Computa\u021bional vorbind, se folose\u0219te deseori forma recursiv\u0103, cu \\(C_0 = 1\\) \u0219i $$ C_n = \\sum_{i = 1}^n C_{i - 1}C_{n - i} = \\frac{2(2n - 1)}{n + 1} C_{n - 1} $$</p> <p>Printre altele, numerele Catalan apar \u00een aplica\u021bii precum:</p> <ul> <li>Num\u0103rul de arbori binari cu \\(n\\) noduri.</li> <li>Num\u0103rul de parantez\u0103ri corecte de lungime \\(2n\\).</li> <li>Num\u0103rul de drumuri de la \\((0, 0)\\) la \\((n, n)\\) care merg \u00een sus \u0219i la dreapta   f\u0103r\u0103 s\u0103 treac\u0103 de partea cealalt\u0103 a diagonalei principale.</li> <li>\u0218i multe altele, pe care le pute\u021bi g\u0103si   aici</li> </ul> <p>A\u0219a se calculeaz\u0103 num\u0103rul Catalan:</p> Calcul cu C(n, k)Calcul cu DPCalcul direct <pre><code>const unsigned long long C(int n, int k) {\n    unsigned long long res = 1;\n\n    // C(n, k) = C(n, n-k)\n    if (k &gt; n - k) {\n        k = n - k;\n    }\n\n    for (int i = 0; i &lt; k; ++i) {\n        res *= (n - i);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n\nconst unsigned long long catalan(int n) {\n    return C(2 * n, n) / (n + 1);\n}\n</code></pre> <pre><code>unsigned long long catalan(unsigned int n)\n{\n    unsigned long long C[n + 1];\n\n    C[0] = C[1] = 1;\n\n    for (int i = 2; i &lt;= n; i++) {\n        C[i] = 0;\n        for (int j = 0; j &lt; i; j++)\n            C[i] += C[j] * C[i - j - 1];\n    }\n\n    return C[n];\n}\n</code></pre> <pre><code>const unsigned long long catalan(int n) {\n    unsigned long long res = 1;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        res *= 2 * (2 * i - 1);\n        res /= (i + 1);\n    }\n\n    return res;\n}\n</code></pre>"},{"location":"mediu/combinatorica/#numerele-stirling","title":"Numerele Stirling","text":"<p>La fel ca \u0219i numerele Catalan, numerele Stirling \u0219i Bell apar \u00een anumite aplica\u021bii ale problemelor de combinatoric\u0103. Numerele Stirling de prim\u0103 spe\u021b\u0103 sunt folositoare \u00een special c\u00e2nd vine vorba de num\u0103rarea ciclurilor \u00een permut\u0103ri, iar numerele Stirling de cea de-a doua spe\u021b\u0103, precum \u0219i numerele Bell se reg\u0103sesc \u00een probleme legate de num\u0103rarea unor parti\u021bii.</p> <p>Numerele lui Stirling de spe\u021ba I num\u0103r\u0103 c\u00e2te permut\u0103ri de ordin \\(n\\) cu \\(k\\) cicluri exist\u0103, \u0219i se noteaz\u0103 cu \\(s(n, k)\\). De exemplu, permutarea \\(1, 4, 2, 3, 6, 5\\) are \\(3\\) cicluri (\\(1\\), \\(2, 4, 3\\) \u0219i \\(5, 6\\)). Cazurile particulare sunt \\(s(0, 0) = 1, s(n, 0) = 0\\) \u0219i \\(s(0, k) = 0\\), iar formula recurent\u0103 este \\(s(n, k) = s(n-1, k-1) + (n-1)\\cdot s(n-1, k)\\), recuren\u021b\u0103 ce se poate explica recurg\u00e2nd la cazurile pe care le \u00eent\u00e2mpin\u0103m atunci c\u00e2nd ad\u0103ug\u0103m o nou\u0103 valoare la permutare, deoarece fie putem forma un ciclu nou, fie \u00eel introducem \u00eentr-un ciclu deja existent.</p> <p>Numerele lui Stirling de spe\u021ba II reprezint\u0103 num\u0103rul de parti\u021bii ale unei mul\u021bimi cu \\(n\\) elemente \u00een \\(k\\) submul\u021bimi, \u0219i se noteaz\u0103 cu \\(S(n, k)\\). Cazurile particulare sunt \\(S(0, 0) = 1, S(n, 0) = 0\\) \u0219i \\(S(0, k) = 0\\), iar formula recurent\u0103 este \\(S(n, k) = s(n-1, k-1) + k\\cdot s(n-1, k)\\), recuren\u021b\u0103 ce se poate explica recurg\u00e2nd la cazurile pe care le \u00eent\u00e2mpin\u0103m atunci c\u00e2nd ad\u0103ug\u0103m o nou\u0103 valoare la parti\u021biile existente, deoarece fie putem forma o nou\u0103 parti\u021bie, fie o introducem \u00eentr-o parti\u021bie deja existent\u0103.</p> Stirling de spe\u021ba IStirling de spe\u021ba II <pre><code>const int MAX = 100;\n\nunsigned long long S[MAX + 1][MAX + 1];\n\nvoid stirling(const int N) {\n    S[0][0] = 0;\n\n    for (int i = 1; i &lt;= N; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            S[i][j] = S[i - 1][j - 1] + (i - 1) * S[i - 1][j];\n        }\n    }\n}\n</code></pre> <pre><code>const int MAX = 100;\n\nunsigned long long S[MAX + 1][MAX + 1];\n\nvoid stirling(const int N) {\n    S[0][0] = 0;\n\n    for (int i = 1; i &lt;= N; ++i) {\n        for (int j = 1; j &lt;= i; ++j) {\n            S[i][j] = S[i - 1][j - 1] + j * S[i - 1][j];\n        }\n    }\n}\n</code></pre> <p>Numerele Bell se refer\u0103 la num\u0103rul de modalit\u0103\u021bi prin care putem parti\u021biona o mul\u021bime cu \\(n\\) elemente, \u0219i se noteaz\u0103 cu \\(B_n\\), fiind o generalizare a numerelor Stirling de spe\u021ba II, num\u0103r\u00e2nd toate parti\u021biile posibile pentru o mul\u021bime. \\(B_n\\) poate fi calculat u\u0219or plec\u00e2nd de la numerele Stirling de spe\u021ba a doua, \\(B_n = S(n, 0) + S(n, 1) +\\dots + S(n, n)\\) sau folosind direct numerele Bell anterioare, \\(B_n =\\sum_{i=0}^{n-1} C_{n-1}^i\\cdot B_i\\).</p>"},{"location":"mediu/combinatorica/#cum-putem-rezolva-probleme-de-combinatorica","title":"Cum putem rezolva probleme de combinatoric\u0103?","text":"<p>De obicei, c\u00e2nd vine vorba de rezolvarea problemelor de combinatoric\u0103, este foarte important mai \u00eent\u00e2i de toate s\u0103 v\u0103 asigura\u021bi c\u0103 \u0219ti\u021bi formulele \u0219i conceptele esen\u021biale, dar \u0219i s\u0103 le \u00een\u021belege\u021bi foarte clar deoarece \u00een cazul acestor probleme, memorarea formulelor f\u0103r\u0103 a le \u00een\u021belege cum trebuie va cauza mai multe probleme dec\u00e2t necunoa\u0219terea lor.</p> <p>Presupun\u00e2nd c\u0103 ave\u021bi un bagaj de cuno\u0219tin\u021be suficient pentru nivelul de dificultate al problemei pe care \u00eel aborda\u021bi, mai \u00eent\u00e2i de toate vre\u021bi s\u0103 \u0219ti\u021bi foarte clar ce date trebuie num\u0103rate \u0219i s\u0103 g\u0103si\u021bi observa\u021bii, care chiar dac\u0103 la \u00eenceput nu par a fi semnificative, pot fi utile pentru ob\u021binerea r\u0103spunsului final.</p> <p>O alt\u0103 tehnic\u0103 foarte important\u0103 const\u0103 \u00een a g\u0103si subprobleme independente ale problemei date, care pot fi folosite pentru a simplifica procesul de g\u0103sire a r\u0103spunsului final, de multe ori acest lucru fiind esen\u021bial \u00een rezolvarea problemelor mai dificile.</p> <p>Nu \u00een ultimul r\u00e2nd, experien\u021ba \u0219i identificarea diferitelor tipuri de formule ce apar de la problem\u0103 la problem\u0103 poate fi foarte folositor, iar de\u0219i acest lucru nu este neap\u0103rat specific strict combinatoricii, se poate observa faptul c\u0103 \u00een cazul acestei tehnici, generarea tuturor solu\u021biilor folosind metode precum backtracking sau brute force se poate dovedi de ajutor pentru identificarea unor posibile rela\u021bii de recuren\u021b\u0103 sau a unor formule care s\u0103 ne duc\u0103 la r\u0103spuns.</p> <p>Trebuie s\u0103 ave\u021bi grij\u0103 \u0219i la faptul c\u0103 \u00een unele cazuri, probleme ce pot p\u0103rea a fi de combinatoric\u0103 s\u0103 nu fie de fapt dinamici care se pot aborda mult mai u\u0219or folosind modul de g\u00e2ndire specific program\u0103rii dinamice, iar chiar dac\u0103 \u00een unele cazuri exist\u0103 similarit\u0103\u021bi \u00eentre cele dou\u0103, acest lucru nu este adev\u0103rat mereu.</p>"},{"location":"mediu/combinatorica/#probleme-suplimentare","title":"Probleme suplimentare","text":""},{"location":"mediu/combinatorica/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Combination</li> <li>pascal infoarena</li> <li>Stirling infoarena</li> <li>IIOT Dream</li> <li>Polyglot Kilonova</li> <li>Problemele de combinatoric\u0103 de pe Kilonova, \u00een special cele de la loturile de juniori</li> <li>RoAlgo Contest 4 - Ursul</li> <li>RoAlgo Contest 2 - munte</li> <li>RCPC 2023 KsumT</li> <li>ONI 2014 Spion</li> <li>ONI 2015 Nmult</li> <li>ONI 2015 Baraj Provocare</li> <li>ONI 2013 Xnumere</li> <li>IIOT 2024 Mermaid</li> <li>USACO Gold Help Yourself</li> <li>Problemele de pe cppi.sync</li> </ul>"},{"location":"mediu/combinatorica/#alte-probleme","title":"Alte probleme","text":"<ul> <li>Bracket Sequences I</li> <li>Bracket Sequences II</li> <li>Arena</li> <li>Close Tuples (hard version)</li> <li>Almost Identity Permutations</li> <li>Med and Mex</li> <li>Different Subsets For All Tuples</li> <li>Probleme de combinatoric\u0103 de pe Codeforces</li> </ul>"},{"location":"mediu/combinatorica/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Curs de combinatoric\u0103 f\u0103cut de Bogdan Iordache</li> <li>Curs de combinatoric\u0103 avansat f\u0103cut de Alex Luchianov</li> <li>Combinatorics - USACO Guide (articol + probleme)</li> <li>Elemente de combinatoric\u0103</li> <li>Binomial Coefficients - Eolymp</li> <li>Elemente de combinatoric\u0103, curs predat la lotul de juniori din 2018</li> <li>Derangement - wikipedia</li> <li>Binomial coefficient - wikipedia</li> <li>Triunghiul lui Pascal - wikipedia</li> <li>Stars and Bars</li> <li>Num\u0103rul de parti\u021bii ale unui num\u0103r natural</li> <li>Numere Catalan</li> <li>Catalan Numbers and Catalan Convolution</li> <li>Catalan Numbers and Generating Uniform Balanced Bracket Sequences</li> <li>Numerele Stirling \u0219i numerele Bell</li> <li>Numerele Stirling de ambele spe\u021be</li> <li>Partition of a set</li> <li>Op\u021bional, restul articolelor de la sec\u021biunea combinatorics</li> </ul>"},{"location":"mediu/dsu/","title":"P\u0103duri de mul\u021bimi disjuncte (DSU)","text":"<p>title: P\u0103duri de mul\u021bimi disjuncte (DSU) tags:     - vectori      - arbori      - multimi</p> <p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Structurile de date sunt de multe ori foarte utile \u00een multe contexte \u00een programare, acestea dovedindu-se a fi \u00een special foarte puternice \u0219i esen\u021biale \u00een lucrul problemelor date la diverse olimpiade \u0219i concursuri de informatic\u0103. Acest articol va prezenta o structur\u0103 de date care nu e la prima vedere foarte complicat\u0103 fa\u021b\u0103 de alte structuri de date mai consacrate, dar care se dovede\u0219te a fi foarte puternic\u0103 \u00een rezolvarea multor probleme de toate felurile. </p> <p>A\u0219a cum sugereaz\u0103 \u0219i titlul, vom prezenta \u00een acest articol p\u0103durile de mul\u021bimi disjuncte, sau union-find, denumire dat\u0103 dup\u0103 cele dou\u0103 opera\u021bii principale pe care aceast\u0103 structur\u0103 de date le ofer\u0103. Union-Find poate fi folosit cu mare u\u0219urin\u021b\u0103 pentru probleme de tipul acelora \u00een care ni se cere s\u0103 afl\u0103m pe parcurs ce valori sunt legate \u00eentre ele printr-o rela\u021bie, presupun\u00e2nd c\u0103 rela\u021biile dintre valori se adaug\u0103 treptat. Pe parcurs se vor remarca diverse optimiz\u0103ri, precum \u0219i diferitele clase de probleme \u00een care se poate folosi o asemenea structur\u0103 de date.</p> <p>Pentru u\u0219urarea explica\u021biilor, vom presupune c\u0103 avem o situa\u021bie ipotetic\u0103 \u00een care avem \\(n\\) prieteni \u0219i ni se dau opera\u021bii \u00een care fie dou\u0103 persoane devin prietene, fie trebuie s\u0103 decidem dac\u0103 dou\u0103 persoane apar\u021bin aceluia\u0219i grup de prieteni.</p>"},{"location":"mediu/dsu/#definirea-operatiilor-si-functionalitatii-structurii-de-date","title":"Definirea opera\u021biilor \u0219i func\u021bionalit\u0103\u021bii structurii de date","text":""},{"location":"mediu/dsu/#fundamente","title":"Fundamente","text":"<p>Pentru a reprezenta datele, vom \u021bine \u00eentr-un vector dimensiunea fiec\u0103rei mul\u021bimi, iar \u00eentr-un alt vector vom \u021bine pentru fiecare pozi\u021bie, nodul reprezentativ corespunz\u0103tor grupului de prieteni din care face parte, la \u00eenceput fiecare nod fiind reprezentantul lui \u00eensu\u0219i.</p> <pre><code>vector&lt;int&gt; rad(n + 1), card(n + 1);\n\nfor(int i = 1; i &lt;= n; ++i) {\n    rad[i] = i;\n    card[i] = 1;\n}\n</code></pre>"},{"location":"mediu/dsu/#operatia-de-unire-union","title":"Opera\u021bia de unire (Union)","text":"<p>La acest pas, ni se dau dou\u0103 persoane \u0219i trebuie s\u0103 stabilim rela\u021bia de prietenie dintre ei. De\u0219i aceast\u0103 opera\u021bie se face \u00een timp constant, conteaz\u0103 foarte mult modul \u00een care facem rela\u021bia de atribuire, aceasta put\u00e2nd schimba radical complexitatea algoritmului. Astfel, voi introduce prima optimizare, si anume optimizarea de unire dup\u0103 cardinalul mul\u021bimii, astfel \u00eenc\u00e2t vom uni mereu mul\u021bimea cu cardinal mai mic la mul\u021bimea cu cardinal mai mare.</p> <p>Motivul pentru care aceast\u0103 optimizare duce la o complexitate mai mic\u0103 va fi dat de num\u0103rul mai mic de opera\u021bii pe care func\u021bia Find le va face la fiecare pas. De asemenea, aceast\u0103 optimizare de a uni mul\u021bimile mai mici la cele mai mari se reg\u0103se\u0219te \u00een mod frecvent \u0219i \u00een alte contexte \u00een diverse structuri de date \u0219i nu numai. </p> <pre><code>void Union(int a, int b) {\n    if (card[a] &lt; card[b]) { // (1)\n        swap(a, b);\n    }\n    rad[b] = a;              // (2)\n    card[a] += card[b];      // (3)\n}\n</code></pre> <ol> <li>Vom vrea sa ata\u0219\u0103m nodul b la nodul a.</li> <li>R\u0103d\u0103cina lui b devine a.</li> <li>Cre\u0219tem cardinalul lui a cu cardinalul lui b.</li> </ol>"},{"location":"mediu/dsu/#operatia-de-cautare-find","title":"Opera\u021bia de c\u0103utare (Find)","text":"<p>La aceast\u0103 opera\u021bie, vrem s\u0103 g\u0103sim pentru un nod, pozi\u021bia nodului reprezentativ \u00een structura noastr\u0103 de date. \u00cen mod normal, aceast\u0103 opera\u021bie poate face cel mult \\(O(n)\\) pa\u0219i, \u00een cazul \u00een care arborele rezultat ar fi un lan\u021b. Totu\u0219i, putem s\u0103 ne folosim de parcurgerile pe care le facem pentru a re\u021bine rezultatele pentru toate nodurile de pe parcursul acelui drum, astfel \u00eenc\u00e2t la o parcurgere ulterioar\u0103, num\u0103rul de pa\u0219i s\u0103 se reduc\u0103 spre un num\u0103r constant, structura arborelui ajung\u00e2nd similar\u0103 cu cea a unui arbore stea. </p> <pre><code>int Find(int x) {\n    if (rad[x] == x) {  // (1)\n        return x;\n    }\n    rad[x] = Find(rad[x]);  // (2) \n    return rad[x];\n}\n</code></pre> <ol> <li>Dac\u0103 nodul nostru este r\u0103d\u0103cin\u0103, \u00eenseamn\u0103 c\u0103 l-am g\u0103sit \u0219i-l return\u0103m \u00een     consecin\u021b\u0103.</li> <li>R\u0103d\u0103cina nodului nostru va deveni r\u0103d\u0103cina r\u0103d\u0103cinii curente.</li> </ol>"},{"location":"mediu/dsu/#prime-concluzii","title":"Prime concluzii","text":"<p>Opera\u021bia union are complexitatea \\(O(1)\\), iar opera\u021bia de find are complexitatea \\(O(n)\\). Totu\u0219i, datorit\u0103 optimiz\u0103rilor men\u021bionate mai sus (compresia drumurilor \u0219i unirea dup\u0103 dimensiunea mul\u021bimilor), num\u0103rul total de opera\u021bii f\u0103cute este \\(O(n \\log^* n)\\), unde \\(\\log^* x\\) reprezint\u0103 inversul func\u021biei Ackermann, valoare care se poate aproxima ca fiind o constant\u0103. De asemenea, nefolosirea optimiz\u0103rii de compresie a drumurilor ar duce la complexitatea \\(O(n \\log n)\\), rezultat foarte important \u00een contextul altor optimiz\u0103ri, cum ar fi tehnica small-to-large sau \u00een general \u00een demonstrarea diverselor rezultate ce \u021bin de sume armonice. </p>"},{"location":"mediu/dsu/#problema-disjoint","title":"Problema disjoint","text":"<p>Pentru fiecare opera\u021bie citit\u0103 de la intrare, vom implementa func\u021biile necesare pentru a ob\u021bine rezultatul problemei. Unirea a dou\u0103 mul\u021bimi implic\u0103 mai \u00eent\u00e2i folosirea func\u021biei Find pentru a g\u0103si r\u0103d\u0103cinile, iar mai apoi folosim func\u021bia Union pentru a face unirea propriu-zis\u0103. Folosirea ambelor optimiz\u0103ri pentru \u00eembun\u0103t\u0103\u021birea complexit\u0103\u021bii duce la solu\u021bia optim\u0103, ce ruleaz\u0103 \u00eentr-un timp aproximativ liniar raportat la num\u0103rul de valori citite. </p> <p>Solu\u021bia de 100 de puncte este urm\u0103toarea: <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int NMAX = 100002;\n\nint n, m;\n\nvector&lt;int&gt; rad(NMAX), card(NMAX);\n\nint Find(int x) {\n    if (rad[x] == x) {\n        return x;\n    }\n    rad[x] = Find(rad[x]);\n    return rad[x];\n}\n\nvoid Union(int a, int b) {\n    if (card[a] &lt; card[b]) {\n        swap(a, b);\n    }\n    rad[b] = a;\n    card[a] += card[b];\n}\n\nint main() {\n    ifstream fin(\"disjoint.in\");\n    ofstream fout(\"disjoint.out\");\n\n    fin &gt;&gt; n &gt;&gt; m;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        rad[i] = i;\n        card[i] = 1;\n    }\n\n    for (int i = 1; i &lt;= m; ++i) {\n        int cod, x, y;\n        fin &gt;&gt; cod &gt;&gt; x &gt;&gt; y;\n\n        if (cod == 1 &amp;&amp; Find(x) != Find(y)) {\n            Union(Find(x), Find(y));\n        } else {\n            fout &lt;&lt; (Find(x) == Find(y)) ? \"DA\\n\" : \"NU\\n\";\n        }\n    }\n\n    fin.close();\n    fout.close();\n    return 0;\n}\n</code></pre></p>"},{"location":"mediu/dsu/#oare-putem-implementa-mai-eficient","title":"Oare putem implementa mai eficient?","text":"<p>Ini\u021bial, noi am implementat aceast\u0103 structur\u0103 folosind doi vectori, anume cel \u00een care \u021binem cardinalul fiec\u0103rei mul\u021bimi, precum \u0219i cel \u00een care \u021binem r\u0103d\u0103cina fiec\u0103rei mul\u021bimi. Totu\u0219i, se poate observa faptul c\u0103 noi folosim o gr\u0103mad\u0103 de informa\u021bie inutil\u0103 din cauza faptului c\u0103 pentru fiecare num\u0103r, practic ne intereseaz\u0103 doar dac\u0103 e o r\u0103d\u0103cin\u0103 a unei mul\u021bimi de valori sau nu. Astfel, vom recurge la a reprezenta pozi\u021biile corespunz\u0103toare r\u0103d\u0103cinilor cu numere negative, reprezent\u00e2nd \\(-x\\), unde \\(x\\) e cardinalul mul\u021bimii reprezentat de acea valoare, respectiv reprezentarea nodurilor adiacente cu numere pozitive, reprezent\u00e2nd r\u0103d\u0103cina mul\u021bimii din care acea valoare face parte.</p> <p>Solu\u021bia de 100 de puncte cu optimizarea de memorie este urm\u0103toarea: <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int NMAX = 100002;\n\nint n, q;\n\nvector&lt;int&gt; sz(NMAX);\n\nint Find(int nod) {\n    if (sz[nod] &lt; 0) {\n        return nod;\n    }\n    sz[nod] = Find(sz[nod]);\n    return sz[nod];\n}\n\nvoid Union(int a, int b) {\n    if (a == b) {\n        return;\n    }\n\n    if (sz[a] &gt; sz[b]) {\n        swap(a, b);\n    }\n\n    sz[a] += sz[b];\n    sz[b] = a;\n}\n\nint main() {\n    ifstream fin(\"disjoint.in\");\n    ofstream fout(\"disjoint.out\");\n\n    fin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 1; i &lt;= n; ++i) {\n        sz[i] = -1;\n    }\n\n    for (int i = 1; i &lt;= q; ++i) {\n        int cod, x, y;\n        fin &gt;&gt; cod &gt;&gt; x &gt;&gt; y;\n\n        if (cod == 1 &amp;&amp; Find(x) != Find(y)) {\n            Union(Find(x), Find(y));\n        } else {\n            fout &lt;&lt; (Find(x) == Find(y)) ? \"DA\\n\" : \"NU\\n\";\n        }\n    }\n\n    fin.close();\n    fout.close();\n    return 0;\n}\n</code></pre></p>"},{"location":"mediu/dsu/#problema-bile","title":"Problema bile.","text":"<p>Cerin\u021b\u0103</p> <p>Pe o tabla patratica impartita in \\(N^2\\) patratele (\\(N\\) linii si \\(N\\) coloane), se afla asezate \\(N^2\\) bile (cate una in fiecare patratica a tablei). Lui Gigel ii plac bilele foarte mult, astfel ca el ia, pe rand, cate o bila de pe tabla, pana cand nu mai ramane pe tabla nici o bila. Gigel este, de asemenea, un baiat foarte curios. El a constatat ca bilele pot fi impartite in componente conexe, astfel:</p> <ul> <li> <p>fiecare bila face parte din exact o componenta conexa</p> </li> <li> <p>daca 2 bile sunt invecinate pe orizontala sau verticala, atunci ele fac   parte din aceeasi componenta conexa (adica daca una se afla imediat   deasupra, dedesubtul, la dreapta sau la stanga celeilalte)</p> </li> </ul> <p>Dimensiunea unei componente conexe este egala cu numarul de bile care fac parte din componenta conexa respectiva. Dupa fiecare bila luata, Gigel vrea sa stie care este valoarea maxima dintre dimensiunile componentelor conexe din care fac parte bilele ramase.</p> <p>Mai \u00eent\u00e2i, trebuie observat faptul c\u0103 problema determin\u0103rii conectivit\u0103\u021bii dinamice este una foarte dificil de rezolvat (vezi acest articol de pe Wikipedia), deci nu are sens s\u0103 ne chinuim cu asemenea implement\u0103ri care nu fac obiectul cursului nostru sau \u00een general a programelor olimpiadelor de informatic\u0103.</p> <p>Asta ne duce cu g\u00e2ndul s\u0103 \u00eencerc\u0103m s\u0103 privim problema dintr-o perspectiv\u0103 diferit\u0103, \u00een special \u0219i datorit\u0103 faptului c\u0103 nu suntem for\u021ba\u021bi s\u0103 r\u0103spundem la actualiz\u0103ri online. Din acest motiv, vom introduce o abordare care se folose\u0219te la multe solu\u021bii ce se bazeaz\u0103 pe folosirea p\u0103durilor de mul\u021bimi disjuncte. </p> <p>Practic, \u00een loc s\u0103 privim problema de la \u00eenceput la final, vom rezolva problema invers\u0103, \u00een care putem ad\u0103uga bile, ceea ce ne ajut\u0103 s\u0103 reducem problema la o aplica\u021bie standard a p\u0103durilor de mul\u021bimi disjuncte, r\u0103spunsurile ajung\u00e2nd \u00een cele din urm\u0103 s\u0103 fie afi\u0219ate \u00een ordinea invers\u0103 \u00een care le-am aflat. </p> <p>Solu\u021bia de 100 de puncte este urm\u0103toarea: <pre><code>#include &lt;algorithm&gt;\n#include &lt;fstream&gt;\n#include &lt;utility&gt;\n\nusing namespace std;\n\ntemplate&lt;typename T, size_t N&gt;\nusing Array = T[N];\n\nint n, maxim;\n\nArray&lt;int, 251*251&gt; rad, card, rasp;\nArray&lt;pair&lt;int, int&gt;, 251*251&gt; elim;\nArray&lt;Array&lt;int, 251&gt;, 251&gt; nr;\nArray&lt;Array&lt;bool, 251&gt;, 251&gt; viz;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint Find(int x) {\n    if (rad[x] == x) {\n        return x;\n    }\n\n    return rad[x] = Find(rad[x]);\n}\n\nvoid Union(int a, int b) {\n    if (card[a] &lt; card[b]) {\n        swap(a, b);\n    }\n\n    rad[b] = a;\n    card[a] += card[b];\n\n    maxim = max(maxim, card[a]);\n}\n\nint main() {\n    ifstream fin(\"bile.in\");\n\n    fin &gt;&gt; n;\n\n    for (int i = 1; i &lt;= n; ++i)\n        for (int j = 1; j &lt;= n; j++) {\n            int idx = (i - 1) * n + j;\n            nr[i][j] = idx;\n            card[idx] = 1;\n            rad[idx] = idx;\n        }\n\n    for (int i = 1; i &lt;= n * n; ++i) {\n        fin &gt;&gt; elim[i].first &gt;&gt; elim[i].second;\n    }\n\n    fin.close();\n\n    for (int i = n * n; i &gt;= 1; i--) {\n        rasp[i] = maxim;\n        int x = elim[i].first;\n        int y = elim[i].second;\n\n        for (int j = 0; j &lt; 4; j++) {\n            int newX = x + dx[j];\n            int newY = y + dy[j];\n\n            if (newX &gt;= 1 &amp;&amp; newX &lt;= n &amp;&amp; newY &gt;= 1 &amp;&amp; newY &lt;= n &amp;&amp;\n                viz[newX][newY]) {\n                int b1 = nr[x][y];\n                int b2 = nr[newX][newY];\n                if (nr[newX][newY] != 0 &amp;&amp; Find(b1) != Find(b2)) {\n                    Union(Find(b1), Find(b2));\n                }\n            }\n        }\n\n        maxim = max(maxim, 1);\n        viz[x][y] = true;\n    }\n\n    ofstream fout(\"bile.out\");\n\n    for (int i = 1; i &lt;= n * n; ++i) {\n        fout &lt;&lt; rasp[i] &lt;&lt; '\\n';\n    }\n\n    fout.close();\n\n    return 0;\n}\n</code></pre></p>"},{"location":"mediu/dsu/#problema-secvmax","title":"Problema Secvmax.","text":"<p>Cerin\u021b\u0103</p> <p>Fiona are o secventa de \\(N\\) numere naturale. Ea se \u00eentreab\u0103 din c\u00e2nd \u00een c\u00e2nd pentru un anumit num\u0103r \\(Q\\) care este cea mai lung\u0103 subsecven\u021b\u0103 care are toate numerele mai mici sau egale cu \\(Q\\). Ajuta\u021bi-o pe Fiona s\u0103 \u00ee\u0219i r\u0103spund\u0103 la toate \u00eentreb\u0103rile.</p> <p>Aici putem folosi din nou prelucrarea numerelor \u00een ordine cresc\u0103toare a numerelor din vector, iar atunci c\u00e2nd ad\u0103ug\u0103m valorile \u00een considerare, vom verifica fiecare vecin s\u0103 vedem dac\u0103 putem uni valorile din cele dou\u0103 mul\u021bimi, iar la fiecare pas r\u0103spunsul e cardinalul maxim al unei mul\u021bimi, care e cresc\u0103tor pe m\u0103sur\u0103 ce cre\u0219tem valorile ad\u0103ugate.  </p> <pre><code>#include &lt;fstream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nifstream f(\"secvmax.in\");\nofstream g(\"secvmax.out\");\n\nstruct Pair {\n    int value;\n    int index;\n\n    constexpr bool operator&lt;(const Pair &amp;other) const {\n        if (value == other.value) {\n            return index &lt; other.index;\n        }\n        return value &lt; other.value;\n    }\n};\n\nvector&lt;Pair&gt; queries, elements;\nvector&lt;int&gt; result, parent, sequence, length;\nint maxLength = 0;\n\nint Find(int node) {\n    int root;\n    for (root = parent[node]; root != parent[root]; root = parent[root]);\n    int x = node;\n    while (x != root) {\n        swap(root, parent[x]);\n    }\n    return root;\n}\n\nvoid Union(int a, int b) {\n    if (length[a] &lt; length[b]) {\n        length[b] += length[a];\n        parent[a] = b;\n        length[a] = 0;\n    } else {\n        length[a] += length[b];\n        parent[b] = a;\n        length[b] = 0;\n    }\n\n    maxLength = max(maxLength, length[a] + length[b]);\n}\n\nint main() {\n    int n, q;\n    f &gt;&gt; n &gt;&gt; q;\n\n    elements.resize(n + 1);\n    parent.resize(n + 1);\n    sequence.resize(n + 1);\n    length.resize(n + 1);\n\n    queries.resize(q + 1);\n    result.resize(q + 1);\n\n    for (int i = 1; i &lt;= n; ++i) {\n        int value;\n        f &gt;&gt; value;\n        elements[i] = {value, i};\n        sequence[i] = value;\n        parent[i] = i;\n    }\n\n    sort(elements.begin() + 1, elements.end());\n\n    for (int i = 1; i &lt;= q; ++i) {\n        int value;\n        f &gt;&gt; value;\n        queries[i] = {value, i};\n    }\n\n    sort(queries.begin() + 1, queries.end());\n\n    int pos = 1;\n\n    for (int i = 1; i &lt;= q; ++i) {\n        while (pos &lt;= n &amp;&amp; elements[pos].value &lt;= queries[i].value) {\n            int idx = elements[pos++].index;\n            length[idx] = 1;\n            maxLength = max(maxLength, 1);\n\n            if (idx &gt; 0 &amp;&amp; sequence[idx - 1] &lt;= sequence[idx]) {\n                Union(Find(idx - 1), Find(idx));\n            }\n\n            if (idx &lt; n - 1 &amp;&amp; sequence[idx + 1] &lt; sequence[idx]) {\n                Union(Find(idx + 1), Find(idx));\n            }\n\n        }\n        result[queries[i].index] = maxLength;\n    }\n\n    for (int i = 1; i &lt;= q; ++i) {\n        g &lt;&lt; result[i] &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"mediu/dsu/#problema-joingraf","title":"Problema joingraf.","text":"<p>Cerin\u021b\u0103</p> <p>A fost ziua lui Traian de cur\u00e2nd, iar el a primit \u00een dar un graf cu \\(N\\) noduri. La \u00eenceput, fiecare nod era \u00eentr-o component\u0103 conex\u0103, singur. Dar apoi, c\u00e2inele lui Traian a venit \u0219i i-a spus \\(Q\\) \u00eentreb\u0103ri de forma urm\u0103toare:</p> <ul> <li>\\(1 \\ x \\ y\\): Adaug\u0103 la graful t\u0103u muchiile \\((x, x + 1), (x + 1, x + 2), \\dots , (y - 1, y)\\)</li> <li>\\(2 \\ x \\ y\\): Spune dac\u0103 nodurile \\(x\\) \u0219i \\(y\\) sunt \u00een aceea\u0219i component\u0103 conex\u0103.</li> </ul> <p>Pentru a rezolva aceast\u0103 problem\u0103 exist\u0103 mai multe abord\u0103ri, plec\u00e2nd de la diverse moduri de a g\u00e2ndi problema, dar \u00een contextul p\u0103durilor de mul\u021bimi disjuncte, ne vom concentra pe solu\u021bia cu DSU. </p> <p>Mai \u00eent\u00e2i, trebuie s\u0103 observ\u0103m c\u0103 componentele conexe sunt ca ni\u0219te intervale. De exemplu, s\u0103 lu\u0103m \\(n = 7\\). Atunci, la \u00eenceput intervalele vor fi: \\([1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [6, 6], [7, 7]\\). Dac\u0103 unim muchiile de la \\(3\\) la \\(6\\), intervalele vor deveni: \\([1, 1], [2, 2], [3, 6], [7, 7]\\).</p> <p>Atunci, putem folosi o structur\u0103 de tip DSU. Vom re\u021bine $par_i = $ \"p\u0103rintele\" nodului \\(i\\), sau mai u\u0219or de \u00een\u021beles, cap\u0103tul st\u00e2nga al intervalului \u00een care este nodul \\(i\\). Este nevoie s\u0103 re\u021binem doar cap\u0103tul dreapta, deoarece cap\u0103tul dreapta al secven\u021bei curente este predecesorul cap\u0103tului st\u00e2nga al secven\u021bei urm\u0103toare. Vom re\u021bine \u0219i $nxt_i = $ cap\u0103tul st\u00e2nga al secven\u021bei de dup\u0103 secven\u021ba \u00een care este \\(i\\).</p> <p>Iar atunci c\u00e2nd avem update cu \\(x, y\\), mergem la fiecare secven\u021b\u0103 p\u00e2n\u0103 la \\(y\\) (adic\u0103 c\u00e2nd avans\u0103m de la \\(p\\) la urm\u0103toarea, facem \\(p = nxt_p\\)) \u0219i o reunim cu secven\u021ba \u00een care este \\(x\\).</p> <p>Iar la query, verific\u0103m dac\u0103 intervalul \u00een care este \\(x\\) este egal cu cel \u00een care este \\(y\\). Complexitate: \\(O(N + Q \\ log \\ N)\\) timp, \\(O(n)\\) memorie.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int N = 1e6 + 2;\nint n, q;\n\nvector&lt;int&gt; tt(N), jump(N);\n\nint root(int nd) {\n    while (tt[nd] != nd) {\n        return tt[nd] = root(tt[nd]);\n    }\n    return nd;\n}\nvoid unite(int a, int b) {\n    a = root(a);\n    b = root(b);\n\n    if (a == b) {\n        return;\n    }\n\n    tt[b] = tt[a];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; q;\n\n    for (int i = 1; i &lt;= n; i++) {\n        tt[i] = jump[i] = i;\n    }\n\n    while (q--) {\n        int t, x, y;\n        cin &gt;&gt; t &gt;&gt; x &gt;&gt; y;\n\n        if (t != 1) {\n            cout &lt;&lt; (root(x) == root(y) ? \"Da\\n\" : \"Nu\\n\");\n            continue;\n        }\n\n        int p = x;\n        while (p &lt;= y) {\n            unite(x, p);\n            p = jump[p] + 1;\n        }\n        jump[x] = jump[y];\n    }\n    return 0;\n}\n</code></pre>"},{"location":"mediu/dsu/#concluzii","title":"Concluzii","text":"<p>Acest articol este menit s\u0103 introduc\u0103 audien\u021ba \u00een folosirea p\u0103durilor de mul\u021bimi disjuncte, pun\u00e2nd accentul pe func\u021bionalit\u0103\u021bile de baz\u0103, f\u0103r\u0103 a men\u021biona alte aplica\u021bii importante, cum ar fi algoritmul lui Kruskal sau algoritmii folosi\u021bi pentru dynamic connectivity. De asemenea, p\u0103durile de mul\u021bimi disjuncte pot fi folosite pentru a scurta foarte mult implement\u0103rile aplica\u021biilor simple la grafuri.</p>"},{"location":"mediu/dsu/#probleme-suplimentare","title":"Probleme suplimentare","text":""},{"location":"mediu/dsu/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Chemical table - EJOI 2018</li> <li>MexC ONI 2008</li> <li>Probleme cu DSU de pe kilonova</li> <li>COCI 13-ladice</li> <li>USACO MooTube</li> <li>USACO Wormhole Sort</li> </ul>"},{"location":"mediu/dsu/#probleme-de-pe-codeforcesatcoder","title":"Probleme de pe Codeforces/AtCoder","text":"<ul> <li>Galleries - AGM 2020</li> <li>DSU Step 1 - Codeforces EDU</li> <li>DSU Step 2 - Codeforces EDU</li> </ul>"},{"location":"mediu/dsu/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<p>Am ordonat resursele suplimentare \u00een ordinea dificult\u0103\u021bii \u00een\u021belegerii \u0219i \u00eentr-o ordine logic\u0103 pentru a u\u0219ura ob\u021binerea de cuno\u0219tinte despre tehnicile, abord\u0103rile \u0219i problemele discutate \u00een acest curs. </p> <ul> <li>P\u0103duri de mul\u021bimi disjuncte - CS Academy</li> <li>Algoritmul Union-Find - Algopedia</li> <li>Link ce trebuie accesat pentru inscrierea la cursul despre DSU facut de ITMO Academy</li> <li>Articol USACO Guide - DSU</li> <li>Curs despre DSU - Codeforces (este necesar un cont pentru a putea accesa acest curs, plus accesarea linkului de mai sus)</li> <li>Sack (dsu on tree) - Avansat</li> <li>Smenul de manevrare a query-urilor offline cu DSU</li> </ul>"},{"location":"mediu/fenwick-tree/","title":"Fenwick tree","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, Luca Mure\u0219an</p>"},{"location":"mediu/fenwick-tree/#ce-este-un-arbore-indexat-binar","title":"Ce este un arbore indexat binar?","text":"<p>Arborii indexa\u021bi binar (prescurta\u021bi de regul\u0103, AIB) sunt o structur\u0103 de date ce poate fi folosit\u0103 pentru a actualiza eficient valori \u0219i pentru a calcula sume par\u021biale \u00eentr-un tablou de valori ce poate avea una sau mai multe dimensiuni. </p> <p>De\u0219i arborii indexa\u021bi binar nu \u00eenlocuiesc vreo structur\u0103 de date propriu-zis\u0103 (tot ce poate face un AIB poate face \u0219i un arbore de intervale), marele lor avantaj este dat de faptul c\u0103 implementarea lor este foarte u\u0219oar\u0103 \u0219i constanta folosit\u0103 de ace\u0219tia este una mult redus\u0103 fa\u021b\u0103 de arborii de intervale, fiind de c\u00e2teva ori mai rapizi \u0219i consum\u00e2nd de 2-4 ori mai pu\u021bin\u0103 memorie, \u00een func\u021bie de implementare. </p>"},{"location":"mediu/fenwick-tree/#cum-functioneaza-un-arbore-indexat-binar","title":"Cum func\u021bioneaz\u0103 un Arbore Indexat Binar?","text":"<p>Pentru a putea folosi un AIB, trebuie s\u0103 folosim un vector, unde aib[i] reprezint\u0103 valoarea pe care o stoc\u0103m pe pozi\u021bia \\(i\\). A\u0219a cum \u00eei zice \u0219i numele, fiecare pozi\u021bie \\(i\\) va \u021bine rezultatele pe un interval egal cu \\(2^{zeroes}\\), unde \\(zeroes\\) reprezint\u0103 num\u0103rul de zerouri de la finalul reprezent\u0103rii binare a lui \\(i\\). Aceast\u0103 expresie ne ajut\u0103 s\u0103 adun\u0103m sau s\u0103 sc\u0103dem valoarea celui mai nesemnificativ bit de \\(1\\) din \\(i\\) pentru a putea opera actualiz\u0103rile \u0219i interog\u0103rile.</p> <p>Motivul pentru care se folose\u0219te reprezentarea binar\u0103 a nodurilor este acela c\u0103 \u00een acest mod, se garanteaz\u0103 complexitatea logaritmic\u0103 a opera\u021biilor men\u021bionate mai sus (update \u0219i query), precum \u0219i \u00een practic\u0103 o constant\u0103 foarte bun\u0103 datorit\u0103 num\u0103rului redus de bi\u021bi pe care \u00eel au numerele \u00een binar. </p> <p>Observa\u021bie</p> <p>Arborii indexa\u021bi binar sunt mereu indexa\u021bi de la \\(1\\), deoarece altfel, am avea de-a face cu \\(0\\), care nu are un bit nesemnificativ egal cu \\(1\\).</p>"},{"location":"mediu/fenwick-tree/#cum-functioneaza-operatia-de-update","title":"Cum func\u021bioneaz\u0103 opera\u021bia de update?","text":"<p>S\u0103 presupunem c\u0103 avem un AIB cu \\(16\\) noduri \u0219i vrem s\u0103 actualiz\u0103m valoarea de la pozi\u021bia \\(3\\). Pentru a putea face asta, vom rula urm\u0103torul algoritm, c\u00e2t timp valoarea curent\u0103 nu e mai mare dec\u00e2t num\u0103rul de noduri:</p> <ul> <li>actualiz\u0103m valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>adun\u0103m \\(2^{lsb}\\) la valoarea curent\u0103</li> </ul> <p>De exemplu, pentru nodul \\(3\\) vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>\\(3\\) - pozi\u021bia celui mai nesemnificativ bit este \\(0\\), adun\u0103m \\(2^0 = 1\\) la   pozi\u021bie</li> <li>\\(4\\) - pozi\u021bia celui mai nesemnificativ bit este \\(2\\), adun\u0103m \\(2^2 = 4\\) la   pozi\u021bie</li> <li>\\(8\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), adun\u0103m \\(2^3 = 8\\) la   pozi\u021bie</li> <li>\\(16\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), adun\u0103m \\(2^4 = 16\\) la   pozi\u021bie, algoritmul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de update este \\(O(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar. </p>"},{"location":"mediu/fenwick-tree/#cum-functioneaza-operatia-de-query","title":"Cum func\u021bioneaz\u0103 opera\u021bia de query?","text":"<p>\u00cen mod similar fa\u021b\u0103 de opera\u021bia de update, opera\u021bia de query va rula folosindu-se de reprezentarea binar\u0103 a pozi\u021biei de la care vrem s\u0103 facem query-ul. Este de remarcat faptul c\u0103 dac\u0103 vrem s\u0103 rul\u0103m un query pe intervalul \\([L, R]\\), va trebui s\u0103 sc\u0103dem din rezultatul ob\u021binut p\u00e2n\u0103 la pozi\u021bia \\(R\\), rezultatul ob\u021binut la pozi\u021bia \\(L - 1\\), din cauza faptului c\u0103 informa\u021bia stocat\u0103 \u00een nodurile din AIB nu este suficient de complex\u0103 pentru a putea fi ob\u021binut\u0103 cu o singur\u0103 rutin\u0103 de interogare. Totodat\u0103, aceast\u0103 abordare este similar\u0103 cu cea de la sumele par\u021biale, unde ob\u021binerea lor presupune din nou dou\u0103 calcule, \u00een loc de unul singur.</p> <p>Mai jos prezint algoritmul general \u0219i un exemplu de aplicare al acestuia, pentru valoarea \\(13\\).</p> <ul> <li>adun\u0103m la rezultat valoarea curent\u0103</li> <li>afl\u0103m pozi\u021bia celui mai nesemnificativ bit, s\u0103 o not\u0103m \\(lsb\\)</li> <li>sc\u0103dem \\(2^{lsb}\\) din valoarea curent\u0103.</li> </ul> <p>De exemplu, pentru nodul \\(13\\) vom trece prin urm\u0103toarele pozi\u021bii, dup\u0103 cum se poate vedea pe desen:</p> <ul> <li>\\(13\\) - pozi\u021bia celui mai nesemnificativ bit este \\(0\\), sc\u0103dem \\(2^0 = 1\\) din   pozi\u021bie</li> <li>\\(12\\) - pozi\u021bia celui mai nesemnificativ bit este \\(2\\), sc\u0103dem \\(2^2 = 4\\) din   pozi\u021bie</li> <li>\\(8\\) - pozi\u021bia celui mai nesemnificativ bit este \\(3\\), sc\u0103dem \\(2^3 = 8\\) din   pozi\u021bie, am ajuns la \\(0\\), deci calculul ia sf\u00e2r\u0219it.</li> </ul> <p></p> <p>Complexitatea opera\u021biei de query este \\(O(\\log n)\\), unde \\(n\\) este dimensiunea arborelui indexat binar. </p>"},{"location":"mediu/fenwick-tree/#implementarea-in-c","title":"Implementarea \u00een C++","text":"<p>Un mare avantaj al arborilor indexa\u021bi binar este acela c\u0103 implementarea lor este una foarte scurt\u0103, fiind necesare doar c\u00e2teva r\u00e2nduri pentru a putea fi implementa\u021bi.</p> <pre><code>long long fenwick[100002];\nvoid update(int node, int value) {\n    for (int i = node; i &lt;= n; i += (i &amp; (-i))) {\n        fenwick[i] += value;\n    }\n}\nlong long compute(int node) {\n    long long ans = 0;\n    for (int i = node; i &gt; 0; i -= (i &amp; (-i))) {\n        ans += fenwick[i];\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"mediu/fenwick-tree/#probleme-rezolvate","title":"Probleme rezolvate","text":""},{"location":"mediu/fenwick-tree/#problema-inv","title":"Problema inv","text":"<p>Se d\u0103 un \u015fir \\(S\\) de lungime \\(n\\) cu numere \u00eentregi. Numim o inversiune o pereche de indici \\((i, j)\\) astfel \u00eenc\u00e2t \\(1 \\leq i &lt; j \\leq n\\) \u015fi \\(S_i &gt; S_j\\). S\u0103 se determine c\u00e2te inversiuni sunt \u00een \u015firul dat.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, putem folosi orice structur\u0103 de date ce ne permite s\u0103 actualiz\u0103m valoarea unei pozi\u021bii \u0219i s\u0103 rul\u0103m interog\u0103ri de sum\u0103 pe un interval. \u00cen cazul problemei noastre, vom vrea pentru fiecare valoare din \u0219ir s\u0103 afl\u0103m num\u0103rul de valori de la st\u00e2nga care sunt mai mari dec\u00e2t valoarea curent\u0103, lucru ce se poate realiza afl\u00e2nd pentru valoarea curent\u0103, pozi\u021bia ei \u00een \u0219irul sortat \u0219i proces\u00e2nd un query de sum\u0103 pe intervalul \\([poz + 1, n]\\), unde \\(poz\\) este pozi\u021bia \u00een vectorul sortat a celei mai din dreapta valori din \u0219ir egal\u0103 cu valoarea de la pozi\u021bia curent\u0103. </p>"},{"location":"mediu/fenwick-tree/#problema-goal-statistics","title":"Problema Goal Statistics","text":"<p>Se dau \\(q\\) opera\u021bii, opera\u021bia de update adaug\u0103 o valoare egal\u0103 cu \\(k\\), iar opera\u021bia de query cere suma celor mai mici \\(p\\) valori din \u0219ir. </p> <p>Aceast\u0103 problem\u0103 este din nou un exemplu clasic de folosire a structurilor de date, iar \u00eenc\u0103 o dat\u0103, arborii indexa\u021bi binari se dovedesc a fi solu\u021bia potrivit\u0103 pentru aceast\u0103 problem\u0103, datorit\u0103 vitezei de implementare \u0219i a u\u0219urin\u021bei de folosire. Pentru a afla suma celor mai mici \\(p\\) valori din \u0219ir, vom c\u0103uta binar r\u0103spunsul, folosind o metod\u0103 similar\u0103 cu cea descris\u0103 mai sus. De\u0219i c\u0103utarea binar\u0103 naiv\u0103 \u00een \\(O(\\log^2 n)\\) ia punctajul maxim, se recomand\u0103 c\u0103utarea binar\u0103 \u00een \\(O(\\log n)\\).</p> <p>Solu\u021bia de \\(100\\)</p>"},{"location":"mediu/fenwick-tree/#alte-aplicatii-si-resurse-suplimentare","title":"Alte aplica\u021bii \u0219i resurse suplimentare","text":"<ul> <li>Fenwick Tree</li> <li>Fenwick Tree</li> <li>Goal Statistics</li> <li>inv</li> <li>Understanding Fenwick Trees</li> <li>Binary Indexed   Trees</li> </ul>"},{"location":"mediu/hashing/","title":"Hashing","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>\u00cen informatic\u0103 \u0219i \u00een algoritmic\u0103, de multe ori avem de-a face cu stocarea unei cantit\u0103\u021bi semnificative de informa\u021bie f\u0103r\u0103 s\u0103 putem s\u0103 o stoc\u0103m \u00een intregime, sau \u00een alte cazuri va trebui s\u0103 alter\u0103m informa\u021bia sau s-o organiz\u0103m diferit pentru a putea ajunge la r\u0103spunsurile c\u0103utate c\u00e2t mai rapid \u0219i eficient. \u00cen acest articol voi prezenta c\u00e2teva tipuri de probleme pentru care putem folosi tehnici care vor fi categorizate drept tehnici specifice hashingului, aici voi enumera string hashing, hash tables \u0219i alte tehnici similare, precum xor hashing sau unele fundamente din spatele structurilor de tipul hash map. Pentru a putea parcurge acest capitol, e bine s\u0103 v\u0103 familiariza\u021bi cu lucrul cu \u0219iruri de caractere \u0219i cu aritmetica modular\u0103.</p>"},{"location":"mediu/hashing/#string-hashing","title":"String hashing","text":"<p>Se d\u0103 urm\u0103toarea problem\u0103 ce trebuie rezolvat\u0103: D\u00e2ndu-se dou\u0103 \u0219iruri de caractere, s\u0103 se afle de c\u00e2te ori apare cel de-al doilea \u0219ir \u00een primul. Aceast\u0103 problem\u0103 are diverse solu\u021bii, \u00eencep\u00e2nd de la solu\u021biile de tip brute-force care verific\u0103 naiv toate apari\u021biile unui \u0219ir \u00een cel\u0103lalt, \u0219i termin\u00e2nd cu solu\u021biile care folosesc algoritmi de potrivire a \u0219irurilor, precum KMP sau Z-function, care vor fi aborda\u021bi in alte capitole.</p> <p>\u00cen acest capitol voi prezenta o alt\u0103 abordare foarte util\u0103 pentru acest tip de probleme, \u0219i anume string hashingul. Pe scurt, vom vrea s\u0103 codific\u0103m fiecare \u0219ir de caractere cu un num\u0103r natural care s\u0103 poat\u0103 fi stocat relativ u\u0219or, \u0219i care s\u0103 ne garanteze o probabilitate c\u00e2t mai mare de succes. De ce probabilitate? Dat fiind c\u0103 avem un num\u0103r finit de numere pe care le vom putea folosi \u0219i un num\u0103r mult mai mare de \u0219iruri de caractere care se pot crea, va exista o \u0219ans\u0103 foarte mic\u0103 de a ob\u021bine un rezultat diferit de cel adev\u0103rat (cu alte cuvinte, s\u0103 consider\u0103m dou\u0103 \u0219iruri de caractere diferite ca fiind identice). Dar a\u0219a cum ve\u021bi vedea mai t\u00e2rziu, vom putea mic\u0219ora \u0219ansa de a avea o asemenea coliziune.</p>"},{"location":"mediu/hashing/#cum-aplicam-un-hash-pe-un-sir-de-caractere","title":"Cum aplic\u0103m un hash pe un \u0219ir de caractere","text":"<p>\u00cen cazul majorit\u0103\u021bii problemelor, vom avea de-a face cu \u0219iruri de caractere ce con\u021bin litere mici sau mari ale alfabetului englez (\u00een total, \\(26\\) de litere) \u0219i care au o lungime de un ordin cel mult \\(10^6\\). Din nou, dac\u0103 apar \u0219i alte caractere, va trebui s\u0103 ajust\u0103m parametrii dupa o regul\u0103 bine precizat\u0103.</p> <p>S\u0103 presupunem pentru un moment c\u0103 putem stoca numere arbitrar de mari \u00een timp constant, put\u00e2nd s\u0103 efectu\u0103m opera\u021bii pe ele. Dat fiind c\u0103 sunt \\(26\\) de litere, ne putem g\u00e2ndi la folosirea bazei \\(26\\) pentru a stoca un num\u0103r corespunz\u0103tor unui \u0219ir de caractere, fiecare pozi\u021bie av\u00e2nd o valoare egal\u0103 cu \\(26^{n - i - 1} \\cdot ind_i\\), unde \\(n\\) este lungimea \u0219irului de caractere, \\(i\\) este pozi\u021bia caracterului curent iar \\(ind_i\\) este pozi\u021bia din alfabet (cu indexare de la \\(0\\)) a caracterului de pe pozi\u021bia \\(i\\). De exemplu, dac\u0103 \\(s_i = d\\), \\(ind_i = 3\\) (d este cea de-a patra liter\u0103 din alfabet). </p> <p>De exemplu, dac\u0103 \u0219irul de caractere este algo, num\u0103rul pe care l-am stoca ar fi egal cu</p> \\[ 26^3 \\cdot 0 + 26^2 \\cdot 11 + 26^1 \\cdot 6 + 26^0 \\cdot 14 = 7606 \\] <p>Din p\u0103cate, nu avem parte de numere infinit de mari, a\u0219a c\u0103 trebuie s\u0103 ne limit\u0103m op\u021biunile. Astfel, va trebui s\u0103 facem ajust\u0103ri \u00een ceea ce prive\u0219te baza folosit\u0103, dar \u0219i ca o noutate, vom stoca numerele modulo \\(m\\), care va fi de regul\u0103 un num\u0103r prim mare, valori potrivite sunt de regul\u0103 \\(10^9 + 7\\), \\(998 \\ 244 \\ 353\\) sau \\(10^9 + 9\\). \u00cen mod similar, vom vrea s\u0103 folosim o baz\u0103 \\(b\\) care va fi \u0219i ea un num\u0103r prim, mai mare dec\u00e2t num\u0103rul de caractere distincte pe care \u00eel putem avea (dat fiind c\u0103 avem \\(26\\) de litere, alegeri bune pentru baz\u0103 ar fi \\(29\\) sau \\(31\\)).</p> <p>Observa\u021bie</p> <p>Numerele prime sunt recomandate pentru crearea hashurilor deoarece neav\u00e2nd divizori comuni cu alte numere, riscul de a ajunge la valori egale cu \\(0\\) este mult mai sc\u0103zut, ceea ce reduce semnificativ riscul unor coliziuni.</p> <p>Un alt aspect important ce trebuie prezentat const\u0103 \u00een prezentarea modului \u00een care calcul\u0103m hashul unei subsecven\u021be a unui \u0219ir de caractere de la pozi\u021bia \\(L\\) la pozi\u021bia \\(R\\), lungimea acestuia fiind \\(R - L + 1\\). Dac\u0103 \u0219tim hashul pentru intervalul \\([1, R]\\) \u0219i hashul pentru intervalul \\([1, L-1]\\), s\u0103 le not\u0103m \\(x_R\\) \u0219i \\(x_L\\), hashul subsecven\u021bei \\([L, R]\\) va fi \\(y - x \\cdot base^{R - L + 1}\\).</p> <p>Observa\u021bie</p> <p>Deoarece \u00een majoritatea cazurilor avem de p\u0103strat valoarea modulo \\(X\\), va trebui s\u0103 fim aten\u021bi \u00een ceea ce prive\u0219te calculul hashului \u0219i evitarea valorilor negative ale opera\u021biei modulo. Acum, tot ce ne mai r\u0103m\u00e2ne de f\u0103cut e s\u0103 explic\u0103m cum s\u0103 calcul\u0103m aceste hashuri \u0219i s\u0103 putem ajusta parametrii \u00een func\u021bie de problemele care trebuie rezolvate.</p>"},{"location":"mediu/hashing/#implementarea-si-folosirea-hashurilor","title":"Implementarea \u0219i folosirea hashurilor","text":"<p>Pentru a putea folosi hashurile, va trebui s\u0103 precalcul\u0103m mai \u00eent\u00e2i puterile bazei, p\u00e2n\u0103 la \\(n\\), unde \\(n\\) e lungimea \u0219irului de caractere. De asemenea, va trebui sa precalcul\u0103m hashurile pentru toate prefixele \u0219irului \\(s\\) folosind formula de mai sus, practic la fiecare pas vom \u00eenmul\u021bi r\u0103spunsul anterior cu baza \u0219i adun\u0103m valoarea literei noastre, \u021bin\u00e2nd cont de valoarea modulo-ului. Mai jos pute\u021bi g\u0103si chiar solu\u021bia problemei strmatch de pe infoarena, unde ni se cere s\u0103 afl\u0103m de c\u00e2te ori apare primul \u0219ir \u00een cel de-al doilea.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconstexpr int base = 127;\nconstexpr int mod = 1000000007;\nconstexpr int N = 2000000;\n\nint n, m;\nlong long textHash[N + 1], power[N + 1];\n\nint main() {\n    ifstream fin(\"strmatch.in\");\n    ofstream fout(\"strmatch.out\");\n\n    string pattern, text;\n    fin &gt;&gt; pattern &gt;&gt; text;\n\n    int textLen = text.size();\n    int patternLen = pattern.size();\n\n    power[0] = 1;\n    for (int i = 1; i &lt;= N; i++) {\n        power[i] = (power[i - 1] * base) % mod;\n    }\n\n    long long patternHash = 0;\n    for (int i = 0; i &lt; patternLen; i++) {\n        patternHash *= base;\n        patternHash += pattern[i] - '0';\n        patternHash %= mod;\n    }\n\n    for (int i = 0; i &lt; textLen; i++) {\n        textHash[i + 1] = textHash[i];\n\n        textHash[i + 1] *= base;\n        textHash[i + 1] += text[i] - '0';\n        textHash[i + 1] %= mod;\n    }\n\n    int matchCount = 0;\n\n    vector&lt;int&gt; matchPositions;\n    for (int i = patternLen; i &lt;= textLen; i++) {\n        const auto endHash = textHash[i];\n        const auto startHash = textHash[i - patternLen];\n        const auto newStartHash = (startHash * power[patternLen]) % mod;\n\n        const auto currHash = (endHash - newStartHash + mod) % mod;\n\n        if (currHash == patternHash) {\n            matchCount++;\n            if (matchCount &lt;= 1000) {\n                matchPositions.push_back(i - patternLen);\n            }\n        }\n    }\n\n    fout &lt;&lt; matchCount &lt;&lt; '\\n';\n\n    for (const auto pos : matchPositions) {\n        fout &lt;&lt; pos &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"mediu/hashing/#double-si-multiple-hashing","title":"Double \u0219i multiple hashing","text":"<p>\u00cen unele probleme, precum String Matching de pe CSES, folosirea unui singur hash nu garanteaz\u0103 r\u0103spunsul corect, datorit\u0103 calit\u0103\u021bii testelor. Astfel, se impune folosirea mai multor hashuri concomitent. Cu alte cuvinte, vom proceda la fel ca la un singur hash, doar c\u0103 pentru a testa egalitatea a dou\u0103 \u0219iruri de caractere de aceea\u0219i lungime, va trebui s\u0103 ne asigur\u0103m c\u0103 \u0219irurile returneaz\u0103 acela\u0219i hash pentru toate perechile de tipul \\((baz\u0103, modulo)\\) alese, perechi care trebuie s\u0103 respecte propriet\u0103\u021bile descrise mai sus.</p> <p>Un exemplu de implementare pe aceast\u0103 idee se poate g\u0103si aici, dou\u0103 hashuri fiind suficiente aici.</p> <p>\u00cen practic\u0103, cu c\u00e2t ad\u0103ug\u0103m mai multe hashuri, cu at\u00e2t probabilitatea ca noi s\u0103 nu mai avem coliziuni scade exponen\u021bial, de cele mai multe ori dou\u0103 hashuri fiind suficiente, dac\u0103 sunt alese \u00een mod potrivit.</p>"},{"location":"mediu/hashing/#hash-tables-si-unordered-map","title":"Hash tables \u0219i unordered map","text":"<p>\u00cen anumite situa\u021bii, suntem nevoi\u021bi s\u0103 grup\u0103m valorile \u00een func\u021bie de anumite criterii, ajung\u00e2nd astfel s\u0103 avem nevoie de o structur\u0103 de date care s\u0103 poat\u0103 grupa elementele cu aceea\u0219i valoare pentru a putea procesa opera\u021bii de inserare, \u0219tergere \u0219i modificare \u00een timp rezonabil. Aici intervin tabelele hash, unde vom p\u0103stra valorile grupate \u00een func\u021bie de un criteriu ales de noi anterior (de exemplu, putem s\u0103 le grup\u0103m \u00een func\u021bie de restul \u00eemp\u0103r\u021birii la un num\u0103r prim mare, dar spre deosebire de string hashing, nu foarte mare deoarece va trebui s\u0103 p\u0103str\u0103m aceste liste separat).</p> <p>Totu\u0219i, \u00een prezent o metod\u0103 mult mai popular\u0103 \u0219i mai simplu de folosit pentru a stoca informa\u021bii legate de valori, p\u0103str\u00e2nd \u0219i eficien\u021ba proces\u0103rii acestora const\u0103 \u00een folosirea structurii de date unordered map, care func\u021bioneaz\u0103 \u00eentr-o manier\u0103 similar\u0103 cu a tabelelor hash. Practic, fiecare valoare inserat\u0103 \u00eentr-un unordered map este stocat\u0103 \u00eentr-o tabel\u0103 hash \u00een func\u021bie de valoarea unui hash intern calculat de structura de date \u00een sine. Aceast\u0103 structur\u0103 de date ne garanteaz\u0103 o complexitate foarte bun\u0103 pe un caz obi\u0219nuit, opera\u021biile fiind \u00een medie \\(O(1)\\), dar trebuie avut grij\u0103 la cazul cel mai prost, unde complexitatea unei opera\u021bii poate atinge \u0219i \\(O(n)\\), mai jos g\u0103si\u021bi un exemplu de implementare.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nusing namespace std;\n\nconstexpr enum Action { INSERT = 1, DELETE = 2, QUERY = 3 };\n\nint main() {\n    ifstream fin(\"hashuri.in\");\n    ofstream fout(\"hashuri.out\");\n\n    unordered_map&lt;int, bool&gt; fr;\n    int n;\n    fin &gt;&gt; n;\n\n    while (n--) {\n        int p, x;\n        fin &gt;&gt; p &gt;&gt; x;\n\n        switch (p) {\n            case Action::INSERT:\n                fr[x] = true;\n                break;\n            case Action::DELETE:\n                fr.erase(x);\n                break;\n            case Action::QUERY:\n                fout &lt;&lt; (fr.count(x) &gt; 0) &lt;&lt; \"\\n\";\n                break;\n            default:\n                break;\n        }\n    }\n\n    return 0;\n}\n</code></pre> <p>Observa\u021bie</p> <p>De\u0219i <code>unordered_map</code> este o structur\u0103 de date destul de eficient\u0103 \u0219i foarte util\u0103 \u00een concursuri, se recomand\u0103 evitarea ei la rundele de Codeforces, unde datorit\u0103 perioadei de open hacking de 12 ore de la rundele Div. 3, Div. 4 \u0219i educationale, solu\u021biile care folosesc <code>unordered_map</code> sunt vulnerabile hackurilor ce se folosesc de tehnicile descrise \u00een acest blog. O alternativ\u0103 const\u0103 \u00een folosirea unui hash custom, sau \u0219i mai simplu, folosirea map-ului chiar dac\u0103 pierdem un factor de \\(O(\\log n)\\). Totu\u0219i, la olimpiade nu se genereaz\u0103 de regul\u0103 teste anti-unordered map.</p>"},{"location":"mediu/hashing/#xor-hashing","title":"Xor Hashing","text":"<p>O alt\u0103 tehnic\u0103 ce merit\u0103 men\u021bionat\u0103, dat fiind faptul c\u0103 a ap\u0103rut relativ recent, este cea a xor hashurilor. Pe scurt, modul cum func\u021bioneaz\u0103 este c\u0103 pentru fiecare valoare care apare \u00een \u0219ir (de regul\u0103, o permutare de la \\(1\\) la \\(n\\) sau \u00een general un interval de valori mici), vom vrea s\u0103 o \u00eenlocuim cu o valoare aleas\u0103 aleator \u00eentr-un \u00eenterval foarte mare (de regul\u0103, numerele \u00eentregi pe \\(32\\) de bi\u021bi).</p> <p>Aceast\u0103 tehnic\u0103 ne ajut\u0103 s\u0103 putem afla cu u\u0219urin\u021b\u0103 dac\u0103 un set de numere \u00eentr-un anumit interval apare \u00eentr-o subsecven\u021b\u0103 sau \u00eentr-un \u0219ir de numere (de regul\u0103, problemele se reduc la a afla dac\u0103 valorile dintr-un interval de numere formeaz\u0103 o permutare a mul\u021bimii \\(\\{1, 2, \\dots, n\\}\\).</p>"},{"location":"mediu/hashing/#exemplu-mixperm-lot-juniori-2017","title":"Exemplu: mixperm lot juniori 2017","text":"<p>Pentru aceast\u0103 problem\u0103, se poate observa c\u0103 este un exemplu clasic al folosirii tehnicii xor hashing (solu\u021bia oficial\u0103 folose\u0219te o combina\u021bie de propriet\u0103\u021bi matematice) deoarece putem genera un num\u0103r aleator pentru fiecare valoare de la \\(1\\) la \\(n\\) iar mai apoi c\u00e2nd verific\u0103m fiecare secven\u021b\u0103 brut, folosim valorile xor-urilor par\u021biale pentru a determina cu o probabilitate de aproximativ \\(100 \\%\\) dac\u0103 ob\u021binem o permutare a mul\u021bimii \\(\\{1, 2, \\dots, n\\}\\). O surs\u0103 demonstrativ\u0103 se poate g\u0103si mai jos, submisia put\u00e2nd fi accesat\u0103 aici sau mai jos.</p> <pre><code>#include &lt;chrono&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int randgen(int left = 1, int right = 1000000000) {\n    return uniform_int_distribution&lt;int&gt;(left, right)(rng);\n}\n\nconstexpr int N = 10000;\n\nint hsh[N + 5], a[N + 5], b[N + 5];\n\nint prefa[N + 5], prefb[N + 5];\nint suffa[N + 5], suffb[N + 5];\n\nint main() {\n    ifstream fin(\"mixperm.in\");\n    ofstream fout(\"mixperm.out\");\n\n    int n;\n    fin &gt;&gt; n;\n\n    int xr = 0;\n\n    for (int i = 1; i &lt;= n; i++) {\n        hsh[i] = randgen();\n        xr ^= hsh[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; a[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        fin &gt;&gt; b[i];\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        prefa[i] = prefa[i - 1] ^ hsh[a[i]];\n        prefb[i] = prefb[i - 1] ^ hsh[b[i]];\n\n        const int j = n - i + 1;\n        suffa[j] = suffa[j + 1] ^ hsh[a[j]];\n        suffb[j] = suffb[j + 1] ^ hsh[b[j]];\n    }\n\n    int ans = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        for (int j = i; j &lt;= n; j++) {\n            const int secva = prefa[j] ^ prefa[i - 1];\n            const int secvb = prefb[j] ^ prefb[i - 1];\n\n            const int suffa_xor = suffa[j + 1];\n            const int suffb_xor = suffb[j + 1];\n\n            if ((prefa[i - 1] ^ secvb ^ suffa_xor) == xr ||\n                (prefb[i - 1] ^ secva ^ suffb_xor) == xr) {\n                ans++;\n            }\n        }\n    }\n\n    fout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>"},{"location":"mediu/hashing/#probleme-suplimentare","title":"Probleme suplimentare","text":""},{"location":"mediu/hashing/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>subsecvente OJI 2013</li> <li>Carry Bit IIOT 2023-24</li> <li>sp Lot juniori 2021</li> <li>mixperm Lot juniori 2017</li> <li>Palindrome String</li> <li>sap RoAlgo Contest 6 - XOR Hashing</li> <li>toska Stelele Informaticii - XOR Hashing</li> <li>Bovine Genomics   USACO</li> <li>RMI 2017 Hangman   2]</li> <li>Probleme cu hashing de pe kilonova</li> <li>Probleme cu hashing de pe   infoarena</li> </ul>"},{"location":"mediu/hashing/#probleme-de-pe-alte-siteuri","title":"Probleme de pe alte siteuri","text":"<ul> <li>Finding Periods</li> <li>Sum of Four Values</li> <li>Fullmetal Alchemist II</li> <li>Mysterious Crime</li> <li>The Number of Subpermutations</li> <li>Alte probleme cu hashing de pe   Codeforces</li> </ul>"},{"location":"mediu/hashing/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<p>Am ordonat resursele suplimentare \u00een ordinea dificult\u0103\u021bii \u00een\u021belegerii \u0219i \u00eentr-o ordine logic\u0103 pentru a u\u0219ura ob\u021binerea de cuno\u0219tinte despre tehnicile, abord\u0103rile \u0219i problemele discutate \u00een acest curs.</p> <ul> <li>Cartea SEPI F1 - Capitolul 12 (pagina 171) - C\u0103ut\u0103ri \u00een \u0219iruri de caractere.   Algoritmul Rabin-Karp - Articol   Recomandat</li> <li>Articol USACO Guide - String   Hashing</li> <li>Articol USACO Guide - Hash maps</li> <li>XOR Hashing TUTORIAL</li> <li>On the mathematics behind rolling hashes and anti-hash   tests</li> <li>Articolul de pe cppi.sync</li> <li>Hash tables</li> <li>Hash tables - prezentare   detaliata</li> </ul>"},{"location":"mediu/mobius/","title":"Func\u021bia M\u00f6bius","text":"<p>Autor: Matei Ionescu</p>"},{"location":"mediu/mobius/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>\u00cen teoria numerelor, o func\u021bie aritmetic\u0103 este o func\u021bie \\(f(n) : \\mathbb{N} \\to \\mathbb{C}\\). O func\u021bie aritmetic\u0103 exprim\u0103 propriet\u0103\u021bi aritmetice pentru \\(n\\).</p> <p>Pentru \\(m, n\\) numere prime \u00eentre ele (adic\u0103 \\(cmmdc(m, n) = 1\\)), avem dou\u0103 feluri de func\u021bii aritmetice:</p> <ul> <li>func\u021bii aditive, unde \\(f(mn) = f(n) + f(m)\\);</li> <li>func\u021bii multiplicative, unde \\(f(mn)\\) = \\(f(m)f(n)\\).</li> </ul> <p>Pentru simplitate vom defini urm\u0103toarele aspecte: </p> <ul> <li>\\([p] = 1\\) dac\u0103 \\(p\\) este o propozi\u021bie adev\u0103rat\u0103 sau 0 \u00een caz contrar.</li> <li>\\(\\lfloor n \\rfloor\\) = partea \u00eentreag\u0103 a lui \\(n\\).</li> </ul> <p>C\u00e2t \u0219i urm\u0103toarele propriet\u0103\u021bi celebre:</p> <ul> <li>\\(\\sum_{k = 1}^{N} \\frac{1}{k} \\approx \\log{N}\\).</li> <li>\u0218irul $ a_i = \\lfloor \\frac{N}{i} \\rfloor $, cu \\(\\leq N\\), are \\(O(\\sqrt N)\\) valori distincte.</li> </ul> <p>Pentru \\(\\forall p \\in \\mathbb{N}\\), \\(p\\) num\u0103r prim, \u0219i \\(\\forall k \\in \\mathbb{N}\\), definim urm\u0103toarele func\u021bii multiplicative:</p> <ul> <li>func\u021bia identic\u0103 \\(I(p^k) = p^k\\);</li> <li>func\u021bia putere \\(P_a(p^k) = p^{ka}\\), unde \\(a\\) este constant\u0103 (nu confund\u0103m cu func\u021bia exponen\u021biala \\(f_a(p^k) = a^{p^k}\\));</li> <li>func\u021bia unitate \\(U(p^k) = [p^k = 1]\\);</li> <li>func\u021bia divizorilor \\(\\sigma (p^k)\\) = num\u0103rul de divizori ai lui \\(p^k\\); </li> <li>indicatorul lui Euler $\\varphi(p^k) $ = \\(p^{k} - p^{k-1}\\), c\u00e2te numere \\(x\\), cu \\(1 \\leq x \\leq p^k\\) \u0219i \\(cmmdc(x, p^k) = 1\\) exist\u0103 </li> <li>func\u021bia M\u00f6bius \\(\\mu(p^k) = [k = 0] - [k = 1]\\).</li> </ul> <p>Defini\u021bie</p> <p>Dou\u0103 func\u021bii multiplicative , \\(f(n)\\) \u0219i $g(n) $,  sunt identice dac\u0103 pentru oricare \\(p\\) num\u0103r prim \u0219i oricare \\(k \\geq 0\\), \\(g(p^k) = f(p^k)\\).</p>"},{"location":"mediu/mobius/#precalcularea-functiilor-multiplicative","title":"Precalcularea func\u021biilor multiplicative","text":"<p>\u00cen contextul nostru, vom lucra cel mai des cu func\u021bii multiplicative, iar de cele mai multe ori avem nevoie s\u0103 \u0219tim valorile unei func\u021bii pentru un set mai larg de elemente. \u0218i se dovede\u0219te c\u0103 Ciurul \u00eenv\u0103\u021bat \u00een clasa a 6-a este bun nu numai la aflarea numerelor prime.</p> <p>\\subsection{Ciurul lui Eratostene}</p> <p>Acest algoritm este poate cel mai popular printre elevii de liceu \u0219i gimnaziu pentru a afla numerele prime \u00eentr-un interval. </p> <pre><code>vector&lt;int&gt; ciur(N+1);\nciur[0] = ciur[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (ciur[i] == 0) { //numarul i este prim\n        for (int j = 2 * i; j &lt;= N; j += i) {\n            ciur[j] = 1; //j se scrie ca i * p\n        }\n    }\n}\n</code></pre> <p>La finalul programului, \\(k\\) va fi num\u0103r prim doar dac\u0103 \\(\\operatorname{ciur}(k) = 0\\).</p> <p>Complexitatea de timp este \\(O(\\sum_{k=1}^N \\frac{N}{k}) = O(N \\log{N})\\). </p>"},{"location":"mediu/mobius/#ciur-liniar","title":"Ciur liniar","text":"<p>Observ\u0103m c\u0103 fiecare num\u0103r compus \\(X\\) este parcurs de c\u0103tre cel de-al doilea for de mai multe ori. Dac\u0103 am putea s\u0103 iter\u0103m prin fiecare num\u0103r compus exact o singur\u0103 dat\u0103 am ajunge la complexitatea de \\(O(N)\\). Re\u021binem \u00eentr-un vector auxiliar numerele prime, \u0219i pentru un \\(i\\) fixat vom parcurge numerele prime p\u00e2n\u0103 c\u00e2nd un num\u0103r prim  divide \\(i\\).</p> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; is_composite(N+1);\n\nfor (int i = 2; i &lt;= n; i++) {\n    if (!is_composite[i]) \n        prime.push_back(i);\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= n; j++) {\n        is_composite[i * prime[j]] = 1;\n        if (i % prime[j]) \n            break;\n    }\n}\n</code></pre> <p>Demonstra\u021bie</p> <p>Ca s\u0103 demonstr\u0103m faptul c\u0103 ciurul de mai sus itereaz\u0103 prin fiecare num\u0103r compus exact odat\u0103 avem nevoie de cel mai mic factor prim al acestuia, \\(p\\). S\u0103 presupunem c\u0103 \\(q = i \\cdot p\\). Pentru oricare \\(j &gt; i\\), \\(j\\) este divizor a lui  \\(q\\), presupunem ca \\(k = \\frac{q}{j}\\) este prim. Cum \\(i &lt; j\\), atunci \\(k &lt; p\\), \u00eens\u0103 \\(p\\) este cel mai mic num\u0103r prim care divide \\(q\\), deci nu exist\u0103 un astfel \\(k\\). Deci odat\u0103 luat\u0103 \u00een considerare perechea \\((i, p)\\),\\, \\(i \\cdot p\\) va fi calculat doar o singur\u0103 dat\u0103, transform\u00e2nd complexitatea final\u0103 \u00een \\(O(N)\\).</p>"},{"location":"mediu/mobius/#precalcularea-indicatorului-lui-euler-folosind-ciurul-liniar","title":"Precalcularea indicatorului lui Euler folosind Ciurul Liniar","text":"<p>Pentru a calcula \\(\\varphi(n)\\) trebuie s\u0103 luam \u00een considerare \\(3\\) cazuri:</p> <ul> <li>\\(n\\) este prim \\(\\Rightarrow \\varphi(n) = n-1\\)</li> <li>\\(n = i \\cdot p\\) \u0219i \\(p \\nmid i \\Rightarrow \\varphi(n) = \\varphi(i) \\varphi(p)\\). Prin \\(a \\nmid b\\) \u00een\u021belegem : \"a nu divide pe b\".</li> <li>\\(n = i \\cdot p\\) \u0219i \\(p \\mid i\\). Acest caz este uneori greu de tratat, dar din fericire \u0219tim sigur c\u0103 \\(\\varphi(ip) = p\\varphi(i)\\ \\forall i, p\\).</li> </ul> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; phi(N), compus(N);\nphi[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (!compus[i]) {\n        prime.push_back(i);\n        phi[i] = i - 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= N; j++) {\n        compus[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            phi[i * prime[j]] = phi[i] * phi[prime[j]];\n        }\n        else {\n            phi[i * prime[j]] = prime[j] * phi[i];\n        }\n    }\n}\n</code></pre>"},{"location":"mediu/mobius/#generalizare-a-ciurului-liniar","title":"Generalizare a ciurului liniar","text":"<p>Totu\u0219i, putem s\u0103 generaliz\u0103m algoritmul prezentat mai sus pentru a func\u021biona pentru oricare func\u021bie multiplicativ\u0103. Fie $sml(n) = $ puterea celui mai mic factor din descompunerea \u00een factori primi a lui \\(n\\). Pentru oricare \\(i\\) \u0219i \\(p\\), \\(p\\) cel mai mic num\u0103r prim care divide \\(i\\), putem scrie \\(f(ip) = f(\\frac{i}{p^{sml(i)}}) \\cdot f(p^{sml(i) + 1})\\).</p> <pre><code>vector&lt;int&gt; prime, phi(N+1), compus(N+1), sml(N+1);\nphi[1] = 1;\nfor (int i = 2; i &lt;= N; i++) {\n    if (!compus[i]) {\n        prime.push_back(i);\n        phi[i] = i - 1;\n        sml[i] = 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt;= N; j++) {\n        compus[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            phi[i * prime[j]] = phi[i] * phi[prime[j]];\n            sml[i * prime[j]] = 1;\n        }\n        else {\n            phi[i * prime[j]] = (phi[i] / (pow(prime[j], sml[i]) - pow(prime[j], sml[i] - 1)));\n            phi[i * prime[j]] *= (pow(prime[j], sml[i] + 1) - pow(prime[j], sml[i]));\n            sml[i * prime[j]] = sml[i] + 1;\n        }\n    }\n}\n</code></pre> <p>Aten\u021bie</p> <p>Func\u021bia pow din cod este o func\u021bie scris\u0103 de m\u00e2n\u0103. Nu recomand\u0103m folosirea func\u021biei pow din cmath, din cauza erorilor de precizie. </p> <p>G\u00e2ndim similar pentru func\u021bia M\u00f6bius: </p> <ul> <li>\\(n\\) prim \\(\\Rightarrow \\mu(n) = -1\\)</li> <li>\\(n = i \\cdot p\\), \\(p \\nmid i \\Rightarrow~\\mu(n) = \\mu(i) \\cdot \\mu(p)\\)</li> <li>\\(n = i \\cdot p\\), \\(p \\mid i \\Rightarrow~\\mu(n) = \\frac{\\mu(i)}{[sml(i)=0]-[sml(i)=1]} \\cdot ([sml(i)+1=0]-[sml(i)+1=1])\\).</li> </ul> <p>Observa\u021bie</p> <p>\u00cen cazul \u00een care frac\u021bia de mai sus nu este definit\u0103 (numitorul este \\(0\\)), putem spune din start c\u0103 \\(\\mu(n) = 0\\).</p> <pre><code>vector&lt;int&gt; prime;\nvector&lt;int&gt; sml(N), mobius(N), composite(N);\n\nmobius[1] = 1;\nfor (int i = 2; i &lt; N; i++) {\n    if (!composite[i]) {\n        prime.push_back(i);\n        mobius[i] = -1;\n        sml[i] = 1;\n    }\n    for (int j = 0; j &lt; prime.size() &amp;&amp; i * prime[j] &lt; N; j++) {\n        composite[i * prime[j]] = 1;\n        if (i % prime[j]) {\n            mobius[i * prime[j]] = mobius[i] * mobius[prime[j]];\n            sml[i * prime[j]] = 1;\n        }\n        else {\n            int cltr = (sml[i] == 0) - (sml[i] == 1);\n            int pl = (sml[i] + 1 == 0) - (sml[i] + 1 == 1);\n            if (cltr == 0) {\n                mobius[i] = 0;\n            }\n            else {\n                mobius[i * prime[j]] = (mobius[i] / cltr) * pl;\n            }\n            sml[i * prime[j]] = sml[i] + 1;\n        }\n    }\n}\n</code></pre>"},{"location":"mediu/mobius/#implementare-mai-populara","title":"Implementare mai popular\u0103","text":"<p>Rareori avem nevoie de ciur liniar, \u0219i dac\u0103 nu intr\u0103 \u00een timp \\(O(N \\log{N})\\) pentru precalculare, de ce ar intra \\(O(N)\\)? </p> <pre><code>vector&lt;int&gt; phi(N), mobius(N);\nphi[1] = mobius[1] = 1;\n\nfor (int i = 2; i &lt; N; i++) {\n    phi[i] = i-1;\n}\nfor (int i = 1; i &lt; N; i++) {\n    for (int j = 2 * i; j &lt; N; j+=i) {\n        mobius[j] -= mobius[i];\n        if (i &gt; 1) {\n            phi[j] -= phi[i];\n        }\n    }\n}\n</code></pre>"},{"location":"mediu/mobius/#inversiunea-lui-mobius","title":"Inversiunea lui M\u00f6bius","text":"<p>Ultimele din cele \\(3\\) func\u021bii prezentate la \u00eenceputul articolului sunt mai cunoscute ca restul, \u00eens\u0103 noi ne vom folosi cel mai mult de ultimele \\(2\\), anume indicatorul lui Euler \u0219i func\u021bia M\u00f6bius.</p> <p>Fie \\(g(n)\\) = \\(\\sum_{d\\mid n} f(d)\\). Inversiunea lui M\u00f6bius ne spune: $$     f(n) = \\sum_{d\\mid n} g(d) \\cdot \\mu \\left(\\frac{n}{d}\\right) $$ Cu toate astea, o proprietate mai important\u0103 este \\(\\sum_{d\\mid n} \\mu(d) = U(n)\\). Ceea ce sugereaz\u0103 expresia este c\u0103 pentru oricare num\u0103r natural \\(n\\) suma va da \\(1\\) doar dac\u0103 \\(n = 1\\). Pare nesemnificativ\u0103 proprietatea, \u00eens\u0103 este foarte util\u0103 \u00een rezolvarea multor probleme de informatic\u0103.</p> <p>Exerci\u021biu \\(1\\): Calculeaz\u0103 c\u00e2te perechi \\((a,b)\\) (\\(1 \\leq a,b \\leq n\\)) exist\u0103 cu proprietatea c\u0103 \\(gcd(a,b) = 1\\).</p> <p>Rezolvare: Noi trebuie s\u0103 calcul\u0103m \\(\\sum_{i=1}^{n} \\sum_{j=1}^{n} [cmmdc(i, j) = 1]\\). Ne putem folosi de proprietatea de mai sus \u0219i s\u0103 scriem rela\u021bia astfel:  $$     \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d \\mid cmmdc(i,j)} \\mu(d) $$ Iter\u0103m prin toate numerele \\(\\leq n\\) \u00een loc de divizorii lui \\(n\\) \u0219i ob\u021binem  $$     \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d = 1}^{n} \\mu(d) \\cdot [d\\mid cmmdc(i,j)] = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\sum_{d = 1}^{n} \\mu(d) \\cdot [d\\mid i] \\cdot [d\\mid j] $$ Rearanj\u0103m termenii \u0219i ob\u021binem $$     \\sum_{d=1}^{n} \\mu(d) \\left(\\sum_{i=1}^{n} [d\\mid i]\\right) \\left(\\sum_{j=1}^{n} [d\\mid j]\\right) $$ Observ\u0103m c\u0103  $$     \\sum_{i=1}^{n} [d\\mid i] = \\sum_{j=1}^{n} [d\\mid j] = \\left\\lfloor \\frac{n}{d} \\right\\rfloor $$ </p> <p>deci rela\u021bia final\u0103 devine \\(\\sum_{d=1}^{n} \\mu(d) \\cdot (\\frac{n}{d})^2\\), care poate fi calculat\u0103 \u00een \\bigO{n}.</p> <p>Exerci\u021biu \\(2\\): Calculeaz\u0103 c\u00e2te perechi \\((a,b)\\) exis\u0103, astfel \u00eenc\u00e2t \\(1 \\leq a,b \\leq n\\) \u0219i \\(cmmdc(a, b)\\) = \\(P\\).</p> <p>Rezolvare: </p> \\[     \\sum_{i=1}^{n} \\sum_{j=1}^{n} [cmmdc(i,j) = P] = \\sum_{i=1}^{\\frac{n}{P}} \\sum_{j=1}^{\\frac{n}{P}} [cmmdc(i,j) = 1] \\] <p>Observ\u0103m c\u0103 e identic cu exerci\u021biul precedent, rezultatul fiind \\(\\sum_{d=1}^{\\frac{n}{P}} \\mu(d) \\cdot \\left(\\frac{n}{dP}\\right)^2\\).\\</p> <p>Exerci\u021biul \\(3\\): Calculeaz\u0103 \\(\\sum_{1 \\leq i,j \\leq N} lcm(i,j)\\), unde $lcm(i,j) = $ cel mai mic multiplu comun al numerelor \\(i\\) \u0219i \\(j\\).</p> <p>Rezolvare: \u0218tim totu\u0219i c\u0103 \\(lcm(i,j) = \\dfrac{i\\cdot j}{cmmdc(i,j)}\\), astfel problema ne cere s\u0103 calcul\u0103m suma: $$     \\sum_{1 \\leq i, j \\leq N} \\dfrac{i \\cdot j}{cmmdc(i,j)} $$ Pentru a ne u\u0219ura calculul, putem defini: $$     f(k) = \\sum_{1 \\leq i, j \\leq N} \\dfrac{i \\cdot j}{cmmdc(i,j)} \\cdot [cmmdc(i,j) = k] $$ Observ\u0103m deci c\u0103 dac\u0103 \u0219tim suma produselor \\(i \\cdot j\\), cu \\(cmmdc(i,j) = k\\), fie aceast\u0103 sum\u0103 \\(p(k)\\), atunci rezultatul devine: $$     f(k) = \\dfrac{p(k)}{k} $$ Pentru a calcula \\(p(k)\\) ne putem folosi de func\u021bia mobius astfel:</p> \\[     p(k) = \\sum_{1 \\leq i,j \\leq N} i \\cdot j \\cdot [cmmdc(i,j) = k]\\\\      = \\sum_{a = 1}^{\\frac{N}{k}} \\sum_{b = 1}^{\\frac{N}{k}} a \\cdot b \\cdot k^2 \\cdot [cmmdc(a,b) = 1]\\\\     = \\sum_{a = 1}^{\\frac{N}{k}} \\sum_{b = 1}^{\\frac{N}{k}} a \\cdot b \\cdot k^2 \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot [d \\mid a] \\cdot [d\\mid b]\\\\     = k^2 \\cdot \\sum_{d=1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left(\\sum_{a = 1}^{\\frac{N}{k}} a \\cdot [d \\mid a] \\right) \\cdot \\left(\\sum_{b=1}^{\\frac{N}{k}} b \\cdot [d \\mid b] \\right)\\\\  \\] <p>Observ\u0103m c\u0103: $$     \\sum_{a=1}^{\\frac{N}{k}} a \\cdot [d \\mid a] = \\sum_{b=1}^{\\frac{N}{k}} b \\cdot [d \\mid b] = \\left(d \\cdot (1 + 2 + \\dots + \\frac{N}{kd}) \\right) ^ 2 = \\left( d \\cdot \\dfrac{\\frac{N}{kd} \\cdot (\\frac{N}{kd} + 1)}{2} \\right) ^ 2 $$ Deci: $$     p(k) = k^2 \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left( d \\cdot \\dfrac{\\frac{N}{kd} \\cdot (\\frac{N}{kd} + 1)}{2} \\right) ^ 2 $$ Revenim la problema noastr\u0103 ini\u021bial\u0103: $$     f(k) = \\frac{p(k)}{k} = k \\cdot \\sum_{d = 1}^{\\frac{N}{k}} \\mu(d) \\cdot \\left( d \\cdot \\dfrac{\\frac{N}{kd} \\cdot (\\frac{N}{kd} + 1)}{2} \\right) ^ 2 $$ Iar r\u0103spunsul final este \\(\\sum_{k=1}^{N} f(k)\\), care este calculabil \u00een \\(O(N \\log N)\\).</p>"},{"location":"mediu/mobius/#probleme-propuse-spre-rezolvare","title":"Probleme propuse spre rezolvare","text":""},{"location":"mediu/mobius/#problema-sumgcd-de-pe-kilonova","title":"Problema sumgcd de pe Kilonova","text":"<p>Pentru \\(N\\) \u0219i \\(M\\) date la tastatur\u0103, trebuie s\u0103 calcula\u021bi \\(\\sum_{V} cmmdc(V)\\), unde \\(V\\) reprezint\u0103 un \\(M\\)-tuplu. Un \\(M\\)-tuplu reprezint\u0103 o mul\u021bime de \\(M\\) elemente nu neap\u0103rat distincte cu valori cuprinse \u00eentre 1 \u0219i \\(N\\). Formal, noi trebuie s\u0103 calculam \\(\\sum_{i_1 = 1}^{N} \\sum_{i_2 = 1}^{N} \\dots \\sum_{i_M = 1}^{N} cmmdc(i_1, i_2, \\dots, i_M)\\).</p> <p>Dac\u0103 pentru un \\(K\\) fixat afl\u0103m c\u00e2te M-tupluri exist\u0103 cu \\cmmdc-ul egal cu \\(K\\), atunci putem rezolva foarte u\u0219or problema. Fie \\(f(K)\\) num\u0103rul de tupluri \\((m, n)\\) pentru care \\(cmmdc(m, n) = K\\): $$     f(K) = \\sum_{i_1 = 1}^{N} \\sum_{i_2 = 1}^{N} \\dots \\sum_{i_M = 1}^{N} [cmmdc(i_1, i_2, \\dots, i_M) = K] \\Leftrightarrow \\     \\Leftrightarrow f(k) = \\sum_{i_1 = 1}^{\\frac{N}{K}} \\sum_{i_2 = 1}^{\\frac{N}{K}} \\dots \\sum_{i_M = 1}^{\\frac{N}{K}} [cmmdc(i_1, i_2, \\dots, i_M) = 1] \\Leftrightarrow\\     \\Leftrightarrow f(k) = \\sum_{i_1 = 1}^{\\frac{N}{K}} \\sum_{i_2 = 1}^{\\frac{N}{K}} \\dots \\sum_{i_M = 1}^{\\frac{N}{K}} \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot [d\\mid i_1] \\cdot \\dots \\cdot [d\\mid i_M] \\Leftrightarrow\\     \\Leftrightarrow f(k) = \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot \\left(\\sum_{i_1 = 1}^{\\frac{N}{K}} [d\\mid i_1]\\right) \\cdots \\left(\\sum_{i_M = 1}^{\\frac{N}{K}} [d\\mid i_M]\\right) \\Leftrightarrow\\     \\Leftrightarrow f(k) = \\sum_{d = 1}^{\\frac{N}{K}} \\mu(d) \\cdot \\left(\\frac{N}{Kd}\\right)^M. $$</p> <p>Rezultatul problemei este dat de \\(\\sum_{i=1}^{N} f(i) \\cdot i\\). Complexitatea de timp pentru a calcula \\(f(K)\\) este \\bigO{\\frac{N}{K}\\log{M}}, astfel complexitatea final\u0103  este  $$     \\sum_{i=1}^{N} O(\\frac{N}{i} \\log{M})     = O(\\left(N + \\frac{N}{2} + \\frac{N}{3} + \\cdots + \\frac{N}{N}\\right) \\log{M})\\     = O(N \\left(1 + \\frac{1}{2} + \\frac{1}{3} + \\cdots + \\frac{1}{N}\\right) \\log{M})\\     = O(N\\log{N}\\log{M}). $$</p> <p>Alt\u0103 solu\u021bie este urm\u0103toarea: </p> <p>Vom pune pe cele \\(M\\) pozi\u021bii doar multiplii de \\(K\\), astfel se formeaz\u0103 \\(M^{\\lfloor\\frac{N}{K} \\rfloor}\\) \u0219iruri posibile, dintre care sc\u0103dem \\(f(K \\cdot Q), Q \\geq 1\\). $$     f(K) = M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{K\\mid i} f(i)\\     = M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{i=1}^{N} f(i) \\cdot [K\\mid i] \\     = M^{\\left\\lfloor \\frac{N}{K} \\right\\rfloor} - \\sum_{i=1}^{\\frac{N}{K}} f(K \\cdot i) $$</p> <p>Complexitatea devine: $$     \\sum_{i=1}^{N} O(\\left\\lfloor \\frac{N}{i} \\right\\rfloor + \\log{M}) = O(N \\left(1 + \\frac{1}{2} + \\frac{1}{3} + \\dots \\frac{1}{N}\\right) + N \\log{M})     = O(N \\log{N} + N \\log{M}) \\      = O(N\\left(\\log{N} + \\log{M}\\right))     = O(N\\log{(MN)}) $$ Putem precalcula puterile lui \\(M\\), ob\u021binem astfel \\(O(N \\log{N})\\).</p> <p>Ambele iau \\(100\\) puncte.</p>"},{"location":"mediu/mobius/#problema-cntgcd","title":"Problema cntgcd","text":"<p>Se dau dou\u0103 numere naturale \\(N\\) \u0219i \\(D\\). Calcula\u021bi c\u00e2te perechi de numere \\(A\\) \u0219i \\(B\\) mai mici ca \\(N\\) exist\u0103, astfel \u00eenc\u00e2t \\(cmmdc(A,B) = D\\). Perechea \\((A,B)\\) = \\((B, A)\\).</p> <p>Putem s\u0103 lu\u0103m rezultatul de la primul exerci\u021biu, pentru c\u0103 probleme sunt echivalente. Singura restric\u021bie este faptul c\u0103 perechea \\((A,B)\\) = \\((B,A)\\), dar putem efectiv s\u0103 \u00eemp\u0103r\u021bim rezultatul la 2. $$ ans = \\frac{\\sum_{d=1}^{\\frac{N}{D}} \\mu(d) \\cdot \\left(\\frac{N}{dD}\\right)^2 + 1}{2} $$ Solu\u021bia ia undeva la \\(45\\) puncte, datorit\u0103 faptului c\u0103 \\(D \\leq N \\leq 10^9\\).</p> <p>Fie \\(f(n)\\) = num\u0103rul de perechi \\((A,B)\\), unde \\(cmmdc(A,B) = 1\\). Noi trebuie s\u0103 calcul\u0103m practic \\(f(\\left\\lfloor \\frac{N}{D} \\right\\rfloor ) = \\sum_{d = 1}^{\\left\\lfloor \\frac{N}{D} \\right\\rfloor } \\varphi(d)\\).</p> <p>Pentru \\(N \\leq 10^6\\) putem calcula suma brut. Pentru \\(N &gt; 10^6\\) putem elimina perechile care au cmmdc-ul 2, 3 etc. $$     f(n) = \\frac{n^2 - n}{2} - \\sum_{d=2}^{n} f\\left(\\lfloor \\frac{n}{d} \\rfloor\\right) $$</p> <p>Datorit\u0103 faptului c\u0103 \u0219irul \\(a_i = \\lfloor \\frac{N}{i} \\rfloor\\) are \\(O(\\sqrt{N})\\) elemente diferite, putem doar s\u0103 calcul\u0103m c\u00e2te numere \\(d_1\\) exist\u0103, astfel \u00eenc\u00e2t \\(\\frac{n}{d} = \\frac{n}{d_1}\\) \u0219i s\u0103 adun\u0103m la rezultat \\(f(\\lfloor \\frac{n}{d} \\rfloor) \\cdot nr\\).</p> <p>Observa\u021bie</p> <p>Fie \\(d\\) = cel mai mic num\u0103r astfel \u00eenc\u00e2t \\(\\frac{n}{d} = x\\). Atunci cel mai mare num\u0103r care \u00eendepline\u0219te aceea\u0219i proprietate este \\(\\left\\lfloor \\frac{n}{\\lfloor \\frac{n}{d} \\rfloor} \\right\\rfloor\\).</p> <pre><code>long long f (long long n) {\n    //cout &lt;&lt; n &lt;&lt; '\\n';\n    if (n &lt;= 1000000) {\n        return sum_phi[n]; //phi(1) + phi(2) + ... + phi(n)\n    }\n    if (dp[n]) {\n        return dp[n];\n        //am calculat deja rezultatul pt n\n    }\n    long long ans = 1LL * (1LL * n * (n + 1)) / 2; \n    for (int i = 2, dr; i &lt;= n; i = dr + 1) {\n        dr = (n / (n / i));\n        if (dr &gt; n) {\n            break;\n        }\n        ans -= (dr - i + 1) * f(n / i);\n    }\n    dp[n] = ans;\n    return ans;\n}\n</code></pre> <p>Complexitatea algoritmului de mai sus este foarte interesant\u0103, ea fiind \\(O(N^\\frac{2}{3})\\).</p>"},{"location":"mediu/mobius/#problema-tupleco","title":"Problema tupleco","text":"<p>Se dau dou\u0103 numere \\(K\\) \u0219i \\(N\\). S\u0103 se afle \\(T\\), num\u0103rul de tupluri formate din \\(K\\) elemente \\((X_1, X_2, X_3, \\dots , X_K)\\) cu proprietatea c\u0103:</p> <ul> <li>\\(1 \\leq X_1 \\leq X_2 \\leq \\dots \\leq X_K \\leq N\\).</li> <li>\\(cmmdc(X_1, X_2, \\dots, X_K) = 1\\).</li> </ul>"},{"location":"mediu/mobius/#solutie-de-75-rightarrow-80-sau-chiar-100-de-puncte","title":"Solu\u021bie de \\(75 \\rightarrow 80\\) (sau chiar \\(100\\)) de puncte:","text":"<p>Ne vom folosi de func\u021bia M\u00f6bius pentru a calcula rezultatul. Dac\u0103 facem abstrac\u021bie de prima proprietate, r\u0103spunsul nostru devine: $$     \\sum_{d=1}^{N} \\mu(d) \\cdot \\lfloor \\frac{N}{d} \\rfloor ^K $$</p> <p>Ce \u00eenseamn\u0103 \u00eens\u0103 \\(\\lfloor \\dfrac{N}{d} \\rfloor ^ K\\)? Reprezint\u0103 num\u0103rul de \u0219iruri de lungime \\(K\\) , unde \\(X_i\\) este multiplu de \\(d\\). Ca s\u0103 num\u0103r\u0103m doar num\u0103rul de \u0219iruri care sunt sortate, ne vom folosi de Stars and Bars, astfel num\u0103rul de \u0219iruri \\((X_1, X_2, X_3, .. ,X_K)\\) cu \\(X_i \\leq X_{i+1} \\leq N\\) este egal cu \\(N-K+1 \\choose K\\). </p> <p>Rezultatul nostru devine:  $$     \\sum_{d=1}^{N} \\mu(d) \\cdot {\\left\\lfloor \\frac{N}{d} \\right\\rfloor - K + 1 \\choose K} $$ Solu\u021bia ruleaz\u0103 \u00een \\(O(N)\\) cu \\(O(N)\\) sau \\(O(N \\cdot \\log N)\\) precalcularea.</p> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e7 + 1, mod = 3000017;\nint n, k;\nifstream fin (\"tupleco.in\");\nofstream fout (\"tupleco.out\");\n#define cin fin\n#define cout fout\nlong long C (int n, int k, vector&lt;long long&gt; &amp;f, vector&lt;long long&gt; &amp;invf) {\n    return (1ULL * f[n] * (1ULL * invf[k] * invf[n - k] % mod) % mod) % mod;\n}\nint main() {\n    cin.tie(0)-&gt;sync_with_stdio(0);\n    cin &gt;&gt; k &gt;&gt; n;\n    vector&lt;long long&gt; f(n + k + 1), inv(n + k + 1), invf(n + k + 1);\n    vector&lt;short&gt; mobius(n + 1);\n    f[0] = f[1] = inv[0] = inv[1] = invf[0] = invf[1] = 1;\n    for (int i = 2; i &lt;= n + k; i++) {\n        f[i] = (1ULL * f[i - 1] * i) % mod;\n        inv[i] = (1ULL * inv[mod % i] * (mod - mod / i)) % mod;\n        invf[i] = (1ULL * invf[i - 1] * inv[i]) % mod;\n    }\n\n    mobius[1] = 1;\n    for (int i = 1; i &lt;= n; i++) {\n        if (mobius[i]) {\n            for (int j = i + i; j &lt;= n; j += i) {\n                mobius[j] -= mobius[i];\n            }\n        }\n    }\n\n    long long ans = 0;\n    for (int d = 1; d &lt;= n; d++) {\n        int lt = n / d;\n        long long plt = C(lt + k - 1, k, f, invf);\n        if (mobius[d] == -1) {\n            ans = (1ULL * ans + mod - plt) % mod;\n        }\n        else \n            if (mobius[d] == 1) {\n                ans = (1ULL * ans + plt) % mod;\n            }\n    }\n    cout &lt;&lt; ans;\n}\n</code></pre>"},{"location":"mediu/mobius/#ok-dar-putem-mai-bine","title":"Ok, dar putem mai bine?","text":"<p>Ne folosim de ideea prezentat\u0103 la problema anterioar\u0103. $$     f(n) = {n-k+1 \\choose k} - \\sum_{d=2}^{n} f\\left(\\left\\lfloor \\frac{n}{d} \\right\\rfloor \\right). $$</p> <p>Observa\u021bie</p> <p>Deducem cu puternicele noastre sim\u021buri c\u0103 modulul (\\(M\\))  \u00een problema asta este mult mai mic dec\u00e2t \\(N\\), astfel putem s\u0103 calcul\u0103m combin\u0103rile mult mai rapid:</p> <ul> <li>\\(n \\leq M \\rightarrow\\) putem precalcula combin\u0103rile \u00een \\(O(M)\\).</li> <li>\\(\\displaystyle n &gt; M \\rightarrow {n \\choose k} \\      \\ \\text{modulo} \\ \\  M = {\\lfloor \\frac{n}{mod} \\rfloor \\choose \\lfloor \\frac{k}{mod} \\rfloor} \\cdot {n \\bmod M \\choose k \\bmod M} \\ \\  \\text{modulo} \\ \\ M\\)</li> </ul> <pre><code>#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int mod = 3e6 + 17, N = 1e6 + 2;\nifstream fin (\"tupleco.in\");\nofstream fout (\"tupleco.out\");\n#define cin fin\n#define cout fout\nstruct Mint {\n    int val;\n    Mint (int x = 0) {\n        val = x % mod;\n    }\n    Mint (long long x) {\n        val = x % mod;\n    }\n    Mint operator+(Mint oth) {\n        return val + oth.val;\n    }\n    Mint operator*(Mint oth) {\n        return 1LL * val * oth.val;\n    }\n    Mint operator-(Mint oth) {\n        return val - oth.val + mod;\n    }\n    Mint fp (Mint a, long long n){\n        Mint p = 1;\n        while (n) {\n            if (n &amp; 1) {\n                p = p * a;\n            }\n            a = a * a;\n            n /= 2;\n        }\n        return p;\n    }\n    Mint operator/(Mint oth) {\n        Mint invers = fp(oth, mod - 2);\n        return 1LL * val * invers.val;\n    }\n    friend ostream &amp;operator&lt;&lt;(ostream &amp;os, const Mint &amp;lol) {\n        os &lt;&lt; lol.val;\n        return os;\n    }\n};\nvector&lt;Mint&gt; f(mod), invf(mod), inv(mod);\nMint C (int n, int k) {\n    if (n &lt; 0 || k &lt; 0 || n &lt; k)\n        return 0;\n    if (n &gt;= mod) {\n        return C(n / mod, k / mod) * C(n % mod, k % mod);\n    }\n    return f[n] * invf[n - k] * invf[k];\n}\nint n, k;\nunordered_map&lt;int, Mint&gt; mp;\nMint fr(int n) {\n    if (mp[n].val) {\n        return mp[n];\n    }\n    int dr = 2;\n    Mint total = C(n + k - 1, k);\n    while (dr &lt;= n) {\n        int ptr = n / (n / dr);\n        int lt = n / dr;\n        total = total - (fr(lt) * (ptr - dr + 1));\n        dr = ptr + 1;\n    }\n    mp[n] = total;\n    return total;\n}\nint main() {\n    f[0] = f[1] = inv[0] = inv[1] = invf[1] = invf[0] = 1;\n    for (int i = 2; i &lt; mod; i++) {\n        f[i] = f[i - 1] * i;\n        inv[i] = inv[mod % i] * (mod - mod / i);\n        invf[i] = invf[i - 1] * inv[i];\n    }\n\n    cin &gt;&gt; k &gt;&gt; n;\n    cout &lt;&lt; fr(n);\n}\n</code></pre>"},{"location":"mediu/mobius/#probleme-suplimentare","title":"Probleme suplimentare","text":""},{"location":"mediu/mobius/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Pastile</li> <li>countall</li> <li>Gya-chan and the gcd operation</li> <li>Cowpability</li> </ul>"},{"location":"mediu/mobius/#probleme-de-pe-alte-siteuri","title":"Probleme de pe alte siteuri","text":"<ul> <li>List\u0103 de probleme cu Mobius</li> <li>Sum of gcd of Tuples (Hard)</li> </ul>"},{"location":"mediu/mobius/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Math note \u2014 M\u00f6bius inversion</li> <li>M\u00f6bius Function</li> <li>Prefix Sums of Multiplicative Functions </li> <li>M\u00f6bius inversion formula </li> </ul>"},{"location":"mediu/numere_mari/","title":"Numere mari","text":"<p>Autori: Susan, \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Fie \\(\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}\\) un num\u0103r \u00een baza \\(10\\), format din \\(n\\) cifre. Aici, \\(a_i\\) pentru \\(0 \\leq i &lt; n\\) sunt cifrele num\u0103rului, cu fiecare \\(a_i\\) satisf\u0103c\u00e2nd \\(0 \\leq a_i \\leq 9\\), \u0219i \\(a_{n-1} \\neq 0\\). Valoarea num\u0103rului este dat\u0103 de:</p> \\[ \\overline{a_{n-1} a_{n-2} \\cdots a_1 a_0} = \\sum_{k=0}^{n-1} a_k \\cdot 10^k \\] <p>Aceast\u0103 sum\u0103 poate fi descompus\u0103 \u00een:</p> \\[ \\overline{a_{n-1} a_{n-2} \\cdots a_1 a_0} = a_{n-1} \\cdot 10^{n-1} + a_{n-2} \\cdot 10^{n-2} + \\ldots + a_1 \\cdot 10^1 + a_0 \\cdot 10^0 \\] <p>Similar, fie \\((\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0})_b\\) un num\u0103r \u00een baza \\(b\\), format din \\(n\\) cifre, unde \\(a_i\\) \u00eendepline\u0219te acelea\u0219i condi\u021bii ca mai sus. Valoarea num\u0103rului este dat\u0103 de:</p> \\[ \\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}_b = \\sum_{k=0}^{n-1} a_k \\cdot b^k \\] <p>Aceast\u0103 sum\u0103 poate fi descompus\u0103 \u00een:</p> \\[ \\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0}_b = a_{n-1} \\cdot b^{n-1} + a_{n-2} \\cdot b^{n-2} + \\ldots + a_1 \\cdot b^1 + a_0 \\cdot b^0 \\] <p>Numerele mari sunt esen\u021biale pentru calcule ce dep\u0103\u0219esc limita de \\(2^{63} - 1\\). Acestea se bazeaz\u0103 pe reprezentarea cifric\u0103 a numerelor. De exemplu, s\u0103 reprezent\u0103m num\u0103rul \\(82534\\) folosind defini\u021bia numerelor \u00een baza \\(10\\):</p> \\[ \\begin{align*} 82534 &amp;= 80000 + 2000 + 500 + 30 + 4\\\\ &amp;= 8 \\cdot 10000 + 2 \\cdot 1000 + 5 \\cdot 100 + 3 \\cdot 10 + 4 \\cdot 1\\\\ &amp;= 8 \\cdot 10^{4} + 2 \\cdot 10^3 + 5 \\cdot 10^2 + 3 \\cdot 10^1 + 4 \\cdot 10^0 \\\\ \\end{align*} \\]","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#reprezentarea-numerelor-in-memorie","title":"Reprezentarea numerelor \u00een memorie","text":"<p>Reprezentarea pe cifre a numerelor ne duce cu g\u00e2ndul la reprezentarea num\u0103rului folosind un vector. Astfel, o abordare comun\u0103 pentru manipularea numerelor mari \u00een algoritmic\u0103 este reprezentarea acestora prin intermediul unui vector de cifre. Consider\u0103m un num\u0103r mare, pe care \u00eel descompunem \u00een cifrele sale componente \u0219i le stoc\u0103m \u00eentr-un vector.</p> <p>Exemplu</p> <p>De exemplu, num\u0103rul \\(82534\\) poate fi stocat \u00eentr-un vector \\(v\\) astfel:</p> \\[ \\begin{array}{r|cccccccc} i &amp; 0 &amp; 1 &amp; 2 &amp; 3 &amp; 4\\\\ \\hline v[i] &amp; 4 &amp; 3 &amp; 5 &amp; 2 &amp; 8 \\\\ \\end{array} \\]","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#reprezentarea-inversa","title":"Reprezentarea invers\u0103","text":"<p>Fie un num\u0103r natural \\(N\\) cu cifrele $\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0} $ \u00een baza 10. Reprezentarea invers\u0103 a lui \\(N\\) \u00eentr-un vector \\(v\\) de dimensiune \\(n\\) este definit\u0103 astfel:</p> \\[ v[i] = a_{n-i},\\,\\forall\\ 0 \\leq i &lt; n \\] <p>unde \\(n\\) este num\u0103rul de cifre ale num\u0103rului natural \\(N\\), iar \\(v[0]\\) reprezint\u0103 cifra unit\u0103\u021bilor, \\(v[1]\\) cifra zecilor \u0219.a.m.d.</p> <p>Observa\u021bie</p> <p>Numerotarea cifrelor de la coad\u0103, ca \u00een exemplul anterior, este op\u021bional\u0103, dar este indicat\u0103 pentru simplificare, deoarece este mult mai simplu s\u0103 efectu\u0103m opera\u021biile dac\u0103 p\u0103str\u0103m num\u0103rul \u00een memorie \u00een ordine invers\u0103 fa\u021b\u0103 de cum l-am scrie \u00een mod obi\u0219nuit. Practic, ad\u0103ugarea unor valori la pozi\u021biile mai nesemnificative este o opera\u021bie mult mai des \u00eent\u00e2lnit\u0103 dec\u00e2t ad\u0103ugarea la \u00eenceputul num\u0103rului, iar c\u00e2nd e nevoie, putem cre\u0219te lungimea num\u0103rului plas\u00e2nd noua cifr\u0103 pe pozi\u021bia \\(n\\), \\(v[n]\\) \u021bin\u00e2nd aceast\u0103 valoare.</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#citirea-si-afisarea-unui-numar-mare","title":"Citirea \u0219i afi\u0219area unui num\u0103r mare","text":"<p>Pentru citirea unui num\u0103r mare, vom citi lungimea num\u0103rului (num\u0103rul de cifre) \u0219i apoi cifrele sale, \u00eencep\u00e2nd de la cea mai pu\u021bin semnificativ\u0103 cifr\u0103 (cifra unit\u0103\u021bilor). Pentru afi\u0219are, proced\u0103m invers, \u00eencep\u00e2nd de la cea mai semnificativ\u0103 cifr\u0103.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Lungimea maxim\u0103 a num\u0103rului\nconst int NMAX = 1000;\n\n// Vectorul care va stoca cifrele num\u0103rului\nint cifre[NMAX];\n\n// Lungimea num\u0103rului\nint n;\n\nint main() {\n    cin &gt;&gt; n;\n\n    // Citim cifrele de la coad\u0103 spre cap\n    for (int i = n - 1; i &gt;= 0; i--) {\n        cin &gt;&gt; cifre[i];\n    }\n\n    // Afi\u0219\u0103m num\u0103rul\n    for (int i = n - 1; i &gt;= 0; i--) {\n        cout &lt;&lt; cifre[i];\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#optimizarea-prin-stocarea-lungimii-v0","title":"Optimizarea prin stocarea lungimii v[0]","text":"<p>O \u00eembun\u0103t\u0103\u021bire semnificativ\u0103 a acestei metode este reprezentat\u0103 de utilizarea primei pozi\u021bii a vectorului, \\(v[0]\\), pentru a stoca lungimea num\u0103rului. Aceasta face mai u\u0219oar\u0103 manipularea lungimii \u0219i permite modific\u0103ri mai u\u0219oare ale num\u0103rului, cum ar fi ad\u0103ugarea sau eliminarea cifrelor.</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#reprezentarea-inversa_1","title":"Reprezentarea invers\u0103","text":"<p>Fie un num\u0103r natural $N $ cu cifrele $\\overline{a_{n-1} a_{n-2} \\ldots a_1 a_0} $ \u00een baza 10. Reprezentarea invers\u0103 a lui \\(N\\) \u00eentr-un vector \\(v\\) de dimensiune $n $ este definit\u0103 astfel:</p> \\[ \\begin{gather*} v[0] = n\\\\ v[i + 1] = a_{n-i},\\,\\forall\\ 0 \\leq i &lt; n  \\end{gather*} \\] <p>unde \\(v[0]\\) reprezint\u0103 cifra unit\u0103\u021bilor, \\(v[1]\\) cifra zecilor \u0219.a.m.d., \u0219i \\(n\\) este num\u0103rul de cifre ale num\u0103rului natural \\(N\\).</p> <p>Exemplu</p> <p>De exemplu, num\u0103rul \\(82534\\) va fi stocat astfel:</p> \\[ \\begin{array}{r|ccccccccc} i &amp; \\boldsymbol{0} &amp; 1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\\\ \\hline v[i] &amp; \\boldsymbol{5} &amp; 4 &amp; 3 &amp; 5 &amp; 2 &amp; 8 \\\\ \\end{array} \\] <p>Aici, \\(v[0]=5\\) indic\u0103 num\u0103rul de cifre din \\(N\\), iar cifrele sunt stocate \u00een ordine invers\u0103 \u00eencep\u00e2nd de la \\(v[1]\\).</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#procesarea-eficienta-a-numerelor-mari-in-c","title":"Procesarea eficient\u0103 a numerelor mari \u00een C++","text":"<p>Un aspect comun este citirea numerelor mari atunci c\u00e2nd acestea sunt prezentate ca un \u0219ir continuu de cifre, f\u0103r\u0103 separatoare precum spa\u021biile. O tehnic\u0103 eficient\u0103 pentru a aborda aceast\u0103 problem\u0103 implic\u0103 utilizarea string-urilor. Aceast\u0103 metod\u0103 are avantajul de a permite citirea numerelor indiferent de lungimea lor, f\u0103r\u0103 a necesita specificarea acesteia \u00een prealabil.</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#pasul-1-citirea-numarului-ca-string","title":"Pasul 1: Citirea num\u0103rului ca string","text":"<p>Primul pas este citirea \u00eentregului num\u0103r ca un string. Aceasta este o abordare flexibil\u0103 care nu este constr\u00e2ns\u0103 de lungimea num\u0103rului. De exemplu, pentru a citi un num\u0103r mare:</p> <pre><code>string numarMare;\ncin &gt;&gt; numarMare;\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#pasul-2-conversia-stringului-in-vector-de-cifre","title":"Pasul 2: Conversia stringului \u00een vector de cifre","text":"<p>Dup\u0103 citirea num\u0103rului, urm\u0103torul pas este conversia fiec\u0103rui caracter al stringului \u00eentr-o cifr\u0103 numeric\u0103 individual\u0103 \u0219i stocarea acesteia \u00eentr-un vector. Aceast\u0103 conversie este realizat\u0103 prin sc\u0103derea valorii ASCII a caracterului <code>'0'</code> din fiecare caracter al stringului. De asemenea, lungimea num\u0103rului este salvat\u0103 \u00een prima pozi\u021bie a vectorului pentru a facilita accesul \u0219i manipularea ulterioar\u0103 a cifrelor.</p> <p>Iat\u0103 cum arat\u0103 implementarea:</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Lungimea maxim\u0103 a num\u0103rului\nconst int NMAX = 1000;\n\n// Vectorul care va stoca cifrele num\u0103rului\nint cifre[NMAX];\n\n// Lungimea num\u0103rului\nint n;\n\nint main() {\n    string numarMare;\n    cin &gt;&gt; numarMare;\n\n    // Stoc\u0103m lungimea numarului \u00een cifre[0].\n    cifre[0] = numarMare.size();\n\n    // Citim num\u0103rul de la coad\u0103 la cap, convertind\n    // fiecare caracter \u00een valoarea sa numeric\u0103.\n    for (int i = 0; i &lt; cifre[0]; ++i) {\n        cifre[cifre[0] - i] = numarMare[i] - '0';\n    }\n\n    // Afi\u0219area num\u0103rului\n    for (int i = cifre[0]; i &gt;= 1; i--) {\n        cout &lt;&lt; cifre[i];\n    }\n    cout &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Aceast\u0103 abordare simplific\u0103 semnificativ citirea numerelor mari</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#utilizarea-vectorint-din-stl-pentru-stocare","title":"Utilizarea <code>vector&lt;int&gt;</code> din STL pentru stocare","text":"<p>C\u00e2nd am f\u0103cut citirea cu string-uri, am folosit <code>numarMare.size()</code> pentru a afla lungimea string-ului. Putem folosi aceea\u0219i metod\u0103 pentru a afla \u0219i lungimea num\u0103rului fara s\u0103 o stoc\u0103m in \\(v[0]\\), dar pentru a putea realiza asta, trebuie s\u0103 folosim <code>vector&lt;int&gt;</code>, astfel nemaifiind nevoie s\u0103 stoc\u0103m dimensiunea \u00een \\(v[0]\\).</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#crearea-vectorului-si-inserareastergerea-cifrelor-la-inceput","title":"Crearea vectorului si inserarea/\u0219tergerea cifrelor la inceput","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvoid afisareNumar(const vector&lt;int&gt;&amp; cifre) {\n    // Pornim de la cifre.size() - 1, deoarece vectorul e indexat de la zero.\n    for (int i = cifre.size() - 1; i &gt;= 0; --i) {\n        cout &lt;&lt; cifre[i];\n    }\n    cout &lt;&lt; \"\\n\";\n}\n\nvoid inserareCifra(vector&lt;int&gt;&amp; cifre, int cifra) {\n    // Inserarea unei cifre noi are loc \u00een fa\u021b\u0103, deoarece folosim reprezentarea\n    // invers\u0103.\n    cifre.push_back(cifra);\n}\n\nvoid stergereCifra(vector&lt;int&gt;&amp; cifre) {\n    // Analog, prima cifr\u0103 se \u0219terge din spate.\n    cifre.pop_back();\n}\n\nint main() {\n    // Putem ini\u021bializa astfel vectorul cu un num\u0103r predefinit, 12 \u00een acest\n    // exemplu.\n    vector&lt;int&gt; cifre = {2, 1};\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n\n    // Inserarea unei cifre noi \u00een fa\u021b\u0103.\n    inserareCifra(cifre, 9);\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n\n    // \u0218tergem ultima cifr\u0103.\n    stergereCifra(cifre);\n\n    cout &lt;&lt; \"Numarul de cifre: \" &lt;&lt; cifre.size() &lt;&lt; \"\\n\";\n    afisareNumar(cifre);\n}\n</code></pre> <p>Observ\u0103m c\u0103 astfel dimensiunea vectorului poate varia, un lucru care ne poate ajuta extrem de mult atunci c\u00e2nd nu \u0219tim cat de lung va fi num\u0103rul final.</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#implementarea-diverselor-operatii-pe-numerele-mari","title":"Implementarea diverselor opera\u021bii pe numerele mari","text":"<p>Pentru implementarea opera\u021biilor pe numere mari, avem de-a face cu c\u00e2teva cazuri ce vor fi prezentate \u00een ordinea frecven\u021bei lor \u00een practic\u0103, urm\u00e2nd ca la final s\u0103 fie puse toate \u00eempreun\u0103 \u00eentr-o implementare complet\u0103 a unei clase de numere mari. Aceast\u0103 metod\u0103 ce se recomand\u0103 \u00een special celor cu mai mult\u0103 experien\u021b\u0103. \u00cen subcapitolele ce urmeaz\u0103, vom presupune c\u0103 ambii termeni ai opera\u021biilor sunt numere mari, cu excep\u021bia \u00eemp\u0103r\u021birii \u0219i a \u00eenmul\u021bii, unde vom trata ca operanzi at\u00e2t numere mari, c\u00e2t \u0219i numere mici (adic\u0103 numere care nu sunt mari).</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#adunarea-numerelor-mari","title":"Adunarea numerelor mari","text":"<p>Adunarea a dou\u0103 numere mari se va realiza \u00een mod similar cu modul \u00een care a\u021bi fost obi\u0219nui\u021bi s\u0103 aduna\u021bi numere la \u0219coal\u0103 \u00een clasele mici, cifr\u0103 cu cifr\u0103 \u0219i \u021bin\u00e2nd cont de transportul cifrelor adi\u021bionale.</p> <pre><code>// Adunarea fiec\u0103rei cifre din b la cifra corespunz\u0103toare din a\nfor (int i = 1; i &lt;= b[0]; i++) {\n    a[i] += b[i];\n}\n\n// `a` trebuie s\u0103 aib\u0103 num\u0103rul potrivit de cifre pentru a putea \u00eenc\u0103pea adunarea,\n// a\u0219adar alegem maximul dintre lungimile celor dou\u0103 numere.\na[0] = max(a[0], b[0]);\n\n// Gestionarea transportului\nfor (int i = 1; i &lt;= a[0]; i++) {\n    // Avem un transport!\n    if (a[i] &gt;= 10) {\n        // Dac\u0103 e ultima cifr\u0103, doar cre\u0219tem num\u0103rul de cifre.\n        if (i == a[0]) {\n            a[0]++;\n        }\n\n        // Adaug\u0103 transportul la cifra urm\u0103toare, \u0219i re\u021bine doar ultima cifr\u0103.\n        a[i + 1]++;\n        a[i] -= 10;\n    }\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#scaderea-numerelor-mari","title":"Sc\u0103derea numerelor mari","text":"<p>Sc\u0103derea a dou\u0103 numere mari se va realiza \u00een mod similar cu modul \u00een care a\u021bi fost obi\u0219nui\u021bi s\u0103 sc\u0103de\u021bi numere la \u0219coal\u0103 \u00een clasele mici, cifr\u0103 cu cifr\u0103 \u0219i \u021bin\u00e2nd cont de \u00eemprumutul cifrelor necesare pentru efectuarea opera\u021biilor.</p> <pre><code>// Sc\u0103derea fiec\u0103rei cifre din b din cifra corespunz\u0103toare din a\nfor (int i = 1; i &lt;= b[0]; i++) {\n    a[i] -= b[i];\n}\n\n// Gestionarea \u00eemprumutului\nfor (int i = a[0]; i &gt;= 1; i--) {\n    // Dac\u0103 cifra este negativ\u0103, \u201ene \u00eemprumut\u0103m\u201d\n    // Ad\u0103ug\u0103m 10 la cifra curent\u0103 \u0219i sc\u0103dem 1 de la cifra urm\u0103toare pentru a \n    // face \u00eemprumutul.\n    if (a[i] &lt; 0) {\n        a[i] += 10;\n        a[i + 1]--;\n    }\n}\n\n// Elimin\u0103 zerourile nesemnificative din fa\u021ba num\u0103rului\nwhile (a[a[0]] == 0) {\n    a[0]--;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#compararea-a-doua-numere-mari","title":"Compararea a dou\u0103 numere mari","text":"<p>Pentru a compara dou\u0103 numere mari, avem dou\u0103 cazuri simple de tratat, urm\u00e2nd ca restul implement\u0103rii s\u0103 fie similar cu modul \u00een care am compara dou\u0103 \u0219iruri de caractere.</p> <p>Dac\u0103 cele dou\u0103 numere au un num\u0103r diferit de cifre, putem trage concluzia \u00een mod evident, iar \u00een caz contrar, vom lua cifr\u0103 cu cifr\u0103, de la cea mai semnificativ\u0103 la cea mai pu\u021bin semnificativ\u0103.</p> <pre><code>// -1 dac\u0103 a &lt; b\n// 0 dac\u0103 a == b\n// 1 dac\u0103 a &gt; b\nint comparaCifre(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) {\n    // a are mai multe cifre\n    if (a[0] &gt; b[0]) {\n        return 1;\n    }\n\n    // b are mai multe cifre\n    if (a[0] &lt; b[0]) {\n        return -1;\n    }\n\n    // Au acela\u0219i num\u0103r de cifre, deci compar\u0103m cifr\u0103 cu cifr\u0103.\n    for (int i = a[0]; i &gt;= 1; i--) {\n        if (a[i] == b[i]) {\n            continue;\n        }\n\n        return (a[i] &gt; b[i]) ? 1 : -1;\n    }\n\n    return 0;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#inmultirea-unui-numar-mare-cu-un-numar-mic","title":"\u00cenmul\u021birea unui num\u0103r mare cu un num\u0103r mic","text":"<p>Acest subcaz al \u00eenmul\u021birii poate fi implementat mult mai u\u0219or, implementarea prelu\u00e2nd multe elemente din cele ale adun\u0103rii a dou\u0103 numere mari. Vom presupune c\u0103 vom \u00eenmul\u021bi num\u0103rul mare cu \\(x\\).</p> <pre><code>long long val = 0;\n\nfor (int i = 1; i &lt;= a[0]; i++) {\n    // Includem produsul dintre cifra curent\u0103 \u0219i x\n    val += 1LL * a[i] * x;\n    // Stoc\u0103m ultima cifr\u0103 a acestei sume...\n    a[i] = val % 10;\n    // ...\u0219i o scoatem din sum\u0103.\n    val /= 10;\n}\n\n// Gestionarea transportului r\u0103mas dup\u0103 \u00eenmul\u021bire. \n// Pentru fiecare cifr\u0103 din val, l\u0103rgim num\u0103rul \u0219i stoc\u0103m ultima cifr\u0103 din val \n// ca prima cifr\u0103 din num\u0103r.\nfor (; val; val /= 10) {\n    a[0]++;\n    a[a[0]] = val % 10;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#inmultirea-a-doua-numere-mari","title":"\u00cenmul\u021birea a dou\u0103 numere mari","text":"<p>\u00cenmul\u021birea a dou\u0103 numere mari va necesita lucrul cu toate cifrele num\u0103rului, complexitatea algoritmului devenind \\(O(n_A \\cdot n_B)\\), unde \\(n_A\\) reprezint\u0103 num\u0103rul de cifre al lui \\(A\\), iar \\(n_B\\), num\u0103rul de cifre al lui \\(B\\). Din nou, implementarea va fi asem\u0103n\u0103toare cu cea \u00eenv\u0103\u021bat\u0103 \u00een clasele mici la \u0219coal\u0103.</p> <pre><code>// Num\u0103rul nostru este cel pu\u021bin la fel de mare ca suma cifrelor lor + 1.\nvector&lt;long long&gt; ans(a[0] + b[0] + 1);\n\n// Facem produsul fiec\u0103rei cifre din a cu fiecare cifr\u0103 din b\nfor (int i = 1; i &lt;= a[0]; i++) {\n    for (int j = 1; j &lt;= b[0]; j++) {\n        ans[i + j - 1] += 1LL * b[j] * a[i];\n    }\n}\n\n// Ajustarea dimensiunii vectorului a pentru a \u021bine cont de posibilele\n// transporturi\na[0] += b[0] - 1;\n\nfor (int i = 1; i &lt;= a[0]; i++) {\n\n    // Avem un transport\n    if (ans[i] &gt;= 10) {\n\n        // Dac\u0103 este ultima cifr\u0103...\n        if (i == a[0]) {\n            // ...cre\u0219tem dimensiunea \u0219i o ad\u0103ug\u0103m.\n            a[0]++;\n            ans.push_back(ans[i] / 10);\n        } else {\n            // Adaug\u0103 transportul la cifra urm\u0103toare.\n            ans[i + 1] += ans[i] / 10;\n        }\n\n        // P\u0103streaz\u0103 cifra curent\u0103.\n        ans[i] %= 10;\n    }\n}\n\n// Copierea cifrelor din ans \u00eenapoi \u00een a\nfor (int i = 1; i &lt; (int)ans.size(); i++) {\n    a[i] = ans[i];\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#impartirea-unui-numar-mare-la-un-numar-mic","title":"\u00cemp\u0103r\u021birea unui num\u0103r mare la un num\u0103r mic","text":"<p>La fel ca la \u00eenmul\u021bire, vom lucra cifr\u0103 cu cifr\u0103 \u0219i vom avea grij\u0103 s\u0103 lu\u0103m transportul cifr\u0103 cu cifr\u0103. Vom presupune c\u0103 vom \u00eemp\u0103r\u021bi num\u0103rul mare la \\(x\\).</p> <pre><code>long long val = 0;\n\nfor (int i = a[0]; i &gt;= 1; i--) {\n    // Actualizeaz\u0103 val pentru a include cifra curent\u0103\n    val = val * baza + a[i];\n\n    // Stocheaz\u0103 c\u00e2tul \u00eemp\u0103r\u021birii lui val la x \u00een pozi\u021bia curent\u0103\n    a[i] = val / x;\n\n    // Stocheaz\u0103 restul \u00eemp\u0103r\u021birii \u00een val\n    val %= x;\n}\n\n// Elimin\u0103, zerourile nesemnificative din fa\u021ba num\u0103rului\nwhile (a[a[0]] == 0) {\n    a[0]--;\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#afisarea-unui-numar-mare","title":"Afi\u0219area unui num\u0103r mare","text":"<p>Atunci c\u00e2nd lucr\u0103m cu o baz\u0103 mai mare ca \\(10\\), afi\u0219area num\u0103rului poate deveni un pic mai complicat\u0103, fiind nevoie de aten\u021bie suplimentar\u0103 pentru a face lucrurile s\u0103 func\u021bioneze. Aici am pus o implementare mai generalizat\u0103, unde \\(b\\) este baza pe care o folosim (implicit e \\(10\\), dar poate fi ajustat\u0103).</p> <pre><code>bool ok = false;\n\n// Parcurgem de la cea mai semnificativ\u0103 cifr\u0103 c\u0103tre cea mai pu\u021bin semnificativ\u0103 \n// cifr\u0103\nfor (int i = a[0]; i &gt;= 1; i--) {\n    if (ok) {\n        // Valoarea curent\u0103 s\u0103 fie cel pu\u021bin 1\n        long long val = max(1LL, a[i]);\n\n        // Ad\u0103ug\u0103m zerouri la \u00eenceput pentru a p\u0103stra formatul corect.\n        while (val * 10 &lt; b) {\n            cout &lt;&lt; 0;\n            val *= 10;\n        }\n    }\n\n    // Dac\u0103 cifra curent\u0103 nu este zero, am \u00eenceput s\u0103 afi\u0219\u0103m\n    // adic\u0103 am sc\u0103pat de zerourile ini\u021biale.\n    if (a[i]) {\n        ok = true;\n    }\n\n    cout &lt;&lt; a[i];\n}\n</code></pre>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#optimizari-ce-se-pot-face-la-implementare","title":"Optimiz\u0103ri ce se pot face la implementare","text":"<p>Prima \u0219i cea mai evident\u0103 optimizare const\u0103 \u00een lucrul cu o baz\u0103 mai mare ca \\(10\\), de regul\u0103 putere a lui \\(10\\). Se recomand\u0103 folosirea unei baze \u00eentre \\(10^6\\) \u0219i \\(10^8\\), pentru a evita overflow-urile ce ar putea ap\u0103rea de la stocarea individual\u0103 a fiec\u0103rei pozi\u021bii drept un num\u0103r de \\(10\\) sau mai multe cifre. Aceast\u0103 optimizare poate fi util\u0103 mai ales \u00een situa\u021bia \u00een care foarte multe calcule sunt necesare sau limita de timp este str\u00e2ns\u0103. Un astfel de exemplu reprezint\u0103 problemele de programare dinamic\u0103 \u00een care trebuie afi\u0219at num\u0103rul complet de solu\u021bii (totu\u0219i, \u00een prezent, o mare parte din acele probleme cer r\u0103spunsul modulo un num\u0103r prim).</p> <p>De asemenea, a\u0219a cum ve\u021bi observa mai t\u00e2rziu, exist\u0103 diverse metode de a optimiza opera\u021biile de \u00eenmul\u021bire, folosind diver\u0219i algoritmi precum algoritmul lui Karatsuba sau FFT, dar ace\u0219tia nu fac obiectul discu\u021biei noastre din acest articol.</p>","tags":["vectori","matematica"]},{"location":"mediu/numere_mari/#probleme-si-resurse-suplimentare","title":"Probleme \u0219i resurse suplimentare","text":"<ul> <li>Clas\u0103 de numere mari</li> <li>Lucrul cu numere mari</li> <li>Probleme cu numere mari</li> <li>perm3 de pe infoarena</li> <li>pastile, lot juniori 2015</li> <li>num\u0103r, OJI 2010 IX</li> </ul>","tags":["vectori","matematica"]},{"location":"mediu/sortare_topologica/","title":"Sortare Topologic\u0103","text":"<p>Autor : Radu Moc\u0103na\u0219u</p>"},{"location":"mediu/sortare_topologica/#cunostinte-necesare","title":"Cuno\u0219tin\u021be necesare:","text":"<ul> <li>Grafuri.</li> <li>Recursivitate.</li> <li>Liste de Adiacen\u021b\u0103.</li> <li>C\u00e2teva no\u021biuni legate de vectorii STL.</li> </ul>"},{"location":"mediu/sortare_topologica/#teorie","title":"Teorie","text":"<p>\u00centr-un graf orientat \u0219i aciclic, definim sortarea topologic\u0103 ca fiind o ordine a nodurilor (nu neap\u0103rat unic\u0103), astfel \u00eenc\u00e2t, dac\u0103 not\u0103m cu \\(P\\) lista pozi\u021biilor nodurilor, iar \\(A\\) \u0219i \\(B\\) sunt dou\u0103 noduri, cu muchie de la \\(A\\) la \\(B\\),  $$P_A &lt; P_B $$</p>"},{"location":"mediu/sortare_topologica/#spre-exemplu","title":"Spre exemplu:","text":"<p><pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; C((3))\nA --&gt; D((4))\nA --&gt; E((5))\nE --&gt; C</code></pre> \u00cen acest graf, o sortare topologic\u0103 valid\u0103 ar fi: <code>1, 2, 5, 3, 4</code> , deoarece \\(1\\) se afl\u0103 \u00eenaintea lui \\(2\\), \\(5\\) \u00eenaintea lui \\(3\\), etc. Un alt exemplu ar fi <code>1, 4, 5, 2, 3</code> . O ordine incorect\u0103 ar fi \u00eens\u0103 <code>1, 4, 2, 3, 5</code> , deoarece \\(5\\) se afl\u0103 dup\u0103 \\(3\\), de\u0219i exist\u0103 muchie de la \\(5\\) la \\(3\\).</p>"},{"location":"mediu/sortare_topologica/#un-alt-exemplu","title":"Un alt exemplu:","text":"<p><pre><code>graph LR\nA((1)) --&gt; B((2))\nB --&gt; D((4))\nC((3)) --&gt; A\nD --&gt; C</code></pre> Acest graf con\u021bine un ciclu (de fapt chiar este unul), mai exact \\(1, 2, 3, 4\\) . Astfel, putem alege 2 noduri, \\(A\\) \u0219i \\(B\\), astfel \u00eenc\u00e2t ele apar\u021bin aceluia\u0219i ciclu (se poate ajunge de la \\(A\\) la \\(B\\) \u0219i viceversa). Dar asta implic\u0103 faptul c\u0103 \u00een sortarea topologic\u0103, \\(A\\) se afl\u0103 \u00een fa\u021ba lui \\(B\\), dar \u0219i c\u0103 \\(B\\) se afl\u0103 \u00eenaintea lui \\(A\\), ceea ce duce la o contradic\u021bie. A\u0219adar, \u00eentr-un graf ce con\u021bine un ciclu, nu exist\u0103 nicio sortare topologic\u0103.</p>"},{"location":"mediu/sortare_topologica/#algoritmul","title":"Algoritmul","text":"<p>\u00cent\u00e2i, vom presupune c\u0103 graful este aciclic.</p> <p>Numim vecin al unui nod \\(U\\), un nod \\(V\\), astfel \u00eenc\u00e2t exist\u0103 muchie de la \\(U\\) la \\(V\\). \u00cens\u0103, \u0219tim c\u0103 pentru orice dou\u0103 noduri \\(U\\) \u0219i \\(V\\), pentru care exist\u0103 muchie de la \\(U\\) la \\(V\\), \\(U\\) se afl\u0103 \u00eenaintea lui \\(V\\) \u00een ordinea topologic\u0103.</p> <p>A\u0219adar, \u00een sortarea topologic\u0103, orice nod se afl\u0103 \u00eenaintea vecinilor s\u0103i.</p> <p>\u00cen acela\u0219i timp, \u00eentr-o parcurgere <code>DFS</code>, vom intra \u00een vecinii unui nod dup\u0103 ce intr\u0103m \u00een acesta. Putem defini timpul de ie\u0219ire al unui nod ca fiind momentul la care ne \u00eentoarcem din recursivitate \u00eenapoi la el (pentru simplitate, timpii pot fi numerota\u021bi de la \\(1\\) la \\(n\\), unde \\(n\\) este num\u0103rul de noduri). Astfel, timpul de ie\u0219ire al unui nod va fi tot timpul mai mare dec\u00e2t cel al vecinilor s\u0103i, deci pentru a afla ordinea topologic\u0103, trebuie doar s\u0103 sort\u0103m nodurile descresc\u0103tor dup\u0103 timpii de ie\u0219ire.</p> <p>Pentru a face acest lucru mai simplu, putem doar s\u0103 ad\u0103ug\u0103m nodurile \u00eentr-o list\u0103 goal\u0103, pe care o vom inversa la sf\u00e2r\u0219it. S\u0103 ne uit\u0103m la urm\u0103toarea secven\u021b\u0103 de cod:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Valoare maxima arbitrara pentru numarul maxim de noduri\nconst int NMAX = 10002;\n\n// Listele de adiacenta\nstd::vector&lt;std::vector&lt;int&gt;&gt; lista_adj(NMAX);\n\n// Lista nodurilor sortate dupa timpii de iesire\nstd::vector&lt;int&gt; ord;\n\n// Daca un nod a mai fost vizitat pana acum sau nu\nstd::vector&lt;bool&gt; viz(NMAX);\n\nvoid dfs(int nod) {\n\n    viz[nod] = 1;\n    // Parcurgem lista vecinilor\n    for (auto vecin : lista_adj[nod]) {\n        // Ne intereseaza doar cei care nu au mai fost vizitati\n        if (!viz[vecin]) {\n            dfs(vecin);\n        }\n    }\n\n    // La intoarcerea din recursivitate adaugam nodul in lista\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    // Citire\n    std::cin &gt;&gt; n &gt;&gt; m;\n\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        lista_adj[u].push_back(v);\n    }\n\n    // Incepem parcurgerea dfs\n    dfs(1);\n\n    // Inversam lista nodurilor sortate dupa timpii de iesire\n    std::reverse(ord.begin(), ord.end());\n\n    // Afisare\n    for (auto nod : ord) {\n        std::cout &lt;&lt; nod &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Acest cod este \u00eens\u0103 gre\u0219it \u0219i nu va da rezultatul corect pentru anumite cazuri. S\u0103 lu\u0103m urm\u0103torul exemplu:</p> <pre><code>graph LR\nA((1)) --&gt; B((2))\nC((3)) --&gt; A\nC --&gt; B</code></pre> <p>\u00cencep\u00e2nd dintr-un nod arbitrar (\u00een acest caz, \\(1\\)), noi vom vizita doar nodurile \u00een care putem ajunge din el. \u00cens\u0103, \u00een exemplul dat, asta \u00eenseamn\u0103 c\u0103 vom ignora nodul \\(3\\), care \u00een sortare s-ar afla \u00eenaintea lui \\(1\\).</p> <p>Pentru a rezolva asta, putem parcurge lista tuturor nodurilor \u0219i s\u0103 verific\u0103m pentru fiecare dac\u0103 este vizitat sau nu. Pentru orice nod nevizitat, \u0219tim c\u0103 nu se poate ajunge la el din niciun nod vizitat, deci este corect s\u0103 spunem c\u0103 orice nod nevizitat se poate afla \u00eenaintea nodurilor deja vizitate.</p> <p>A\u0219adar, pentru orice nod nevizitat, putem \u00eencepe o parcurgere <code>DFS</code> din el \u0219i putem ad\u0103uga \u00een continuare nodurile \u00een lista final\u0103, \u00een func\u021bie de timpul lor de ie\u0219ire.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Valoare maxima arbitrara pentru numarul maxim de noduri\nconst int NMAX = 10002;\n\n// Listele de adiacenta\nstd::vector&lt;std::vector&lt;int&gt;&gt; lista_adj(NMAX);\n\n// Lista nodurilor sortate dupa timpii de iesire\nstd::vector&lt;int&gt; ord;\n\n// Daca un nod a mai fost vizitat pana acum sau nu\nstd::vector&lt;bool&gt; viz(NMAX);\n\nvoid dfs(int nod) {\n\n    viz[nod] = 1;\n    // Parcurgem lista vecinilor\n    for (auto vecin : lista_adj[nod]) {\n        // Ne intereseaza doar cei care nu au mai fost vizitati\n        if (!viz[vecin]) {\n            dfs(vecin);\n        }\n    }\n\n    // La intoarcerea din recursivitate adaugam nodul in lista\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    // Citire\n    std::cin &gt;&gt; n &gt;&gt; m;\n\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        lista_adj[u].push_back(v);\n    }\n\n    // Iteram prin lista nodurilor\n    for (int i = 1; i &lt;= n; i++) {\n        // Daca este nevizitat, incepem parcurgerea DFS din el\n        if (!viz[i]) {\n            dfs(i);\n        }\n    }\n\n    // Inversam lista nodurilor sortate dupa timpii de iesire\n    std::reverse(ord.begin(), ord.end());\n\n    // Afisare\n    for (auto nod : ord) {\n        std::cout &lt;&lt; nod &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre> <p>Acest cod este corect \u0219i va returna o sortare topologic\u0103 valid\u0103 (nu neap\u0103rat unic\u0103).</p>"},{"location":"mediu/sortare_topologica/#exemplu-de-problema-cses-course-schedule","title":"Exemplu de Problema: CSES - Course Schedule","text":""},{"location":"mediu/sortare_topologica/#cerinta","title":"Cerin\u021b\u0103:","text":"<p>Se dau \\(n\\) cursuri, numerotate de la \\(1\\) la \\(n\\) \u0219i \\(m\\) condi\u021bii ce trebuie \u00eendeplinite, de forma a doi indici, \\(i\\) \u0219i \\(j\\), cu proprietatea ca acel curs cu num\u0103rul \\(i\\) trebuie terminat \u00eenaintea cursului cu num\u0103rul \\(j\\).</p> \\[1 \\leqslant i &lt; j \\leqslant n\\] <p>Se cere s\u0103 se afi\u0219eze o ordine \u00een care s\u0103 fie f\u0103cute aceste cursuri, astfel \u00eenc\u00e2t toate condi\u021biile s\u0103 fie \u00eendeplinite. Dac\u0103 nu exist\u0103 nicio solu\u021bie, se va afi\u0219a \"IMPOSSIBLE\".</p>"},{"location":"mediu/sortare_topologica/#solutie","title":"Solu\u021bie:","text":"<p>Nu este greu s\u0103 ne d\u0103m seama c\u0103 acele 'condi\u021bii' pot fi reprezentate ca ni\u0219te muchii orientate \u00eentr-un graf, iar ordinea valid\u0103 a realiz\u0103rii task-urilor va fi cea din sortarea topologic\u0103 a grafului rezultat. \u00cen cazul \u00een care graful con\u021bine cicluri, algoritmul tot va returna o anumit\u0103 ordine a nodurilor. Astfel, putem parcurge din nou fiecare condi\u021bie \u0219i s\u0103 verific\u0103m dac\u0103 fiecare condi\u021bie e \u00eendeplinit\u0103, iar dac\u0103 nu e, \u00eenseamn\u0103 c\u0103 nu avem solu\u021bie. Putem verifica acest lucru u\u0219or \u021bin\u00e2nd minte \u00eentr-un vector pozi\u021biile nodurilor din sortarea topologic\u0103 \u0219i s\u0103 le compar\u0103m, cum este eviden\u021biat \u0219i \u00een acest cod:</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Algoritmul descris mai sus, doar ca am schimbat un pic denumirile\nstd::vector&lt;std::vector&lt;int&gt;&gt; G(100005);\n\n// Vector cu toate muchiile\nstd::vector&lt;std::pair&lt;int, int&gt;&gt; edges;\n\nstd::vector&lt;int&gt; ord;\n\nstd::vector&lt;bool&gt; viz(100005);\n\n// Pozitia fiecarui nod in ordinea topologica\nstd::vector&lt;int&gt; poz(100005);\n\nvoid dfs(int nod) {\n    viz[nod] = 1;\n    for (auto x : G[nod]) {\n        if (!viz[x]) {\n            dfs(x);\n        }\n    }\n    ord.push_back(nod);\n}\n\nint main() {\n    int n, m, u, v;\n\n    std::cin &gt;&gt; n &gt;&gt; m;\n    while (m--) {\n        std::cin &gt;&gt; u &gt;&gt; v;\n        G[u].push_back(v);\n        // Adaugam muchia in lista de muchii\n        edges.push_back({u, v});\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (!viz[i]) {\n            dfs(i);\n        }\n    }\n\n    std::reverse(ord.begin(), ord.end());\n\n    for (int i = 0; i &lt; ord.size(); i++) {\n        poz[ord[i]] = i + 1;\n    }\n\n    // Parcurgem din nou toate muchiile si verificam\n    for (auto e : edges) {\n        if (poz[e.first] &gt; poz[e.second]) {\n            // Am gasit o muchie pentru care nu este respectata ordinea topologica\n            std::cout &lt;&lt; \"IMPOSSIBLE\";\n            return 0;\n        }\n    }\n\n    // Daca ordinea respecta toate conditiile, o afisam\n    for (auto x : ord) {\n        std::cout &lt;&lt; x &lt;&lt; \" \";\n    }\n    return 0;\n}\n</code></pre>"},{"location":"mediu/sortare_topologica/#resurse-utile","title":"Resurse Utile","text":""},{"location":"mediu/sortare_topologica/#probleme-si-articole-recomandate","title":"Probleme \u0219i Articole Recomandate","text":"<ul> <li>USACO Guide</li> <li>Sortare Topologica - Infoarena</li> <li>Path - Infoarena</li> <li>Leximin - Kilonova</li> </ul>"},{"location":"mediu/sortare_topologica/#probleme-aditionale","title":"Probleme adi\u021bionale","text":"<ul> <li>Easygraph - Infoarena</li> <li>xy - Kilonova</li> <li>Somnoros - Kilonova</li> <li>Alpin - Infoarena</li> </ul>"},{"location":"mediu/stiva/","title":"Stiva","text":"<p>Autor: Traian Mihai Danciu</p>"},{"location":"mediu/stiva/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>Stiva este ca un teanc de obiecte. Ea are \\(4\\) opera\u021bii principale:</p> <ol> <li>push(value): Adaug\u0103 value pe v\u00e2rful stivei.</li> <li>top(): Spune care este valoarea de pe v\u00e2rful stivei.</li> <li>pop(): Scoate elementul de pe v\u00e2rful stivei.</li> <li>empty(): Spune dac\u0103 stiva este goal\u0103.</li> </ol> <p>Observa\u021bie</p> <p>Valorile vor fi returnate dup\u0103 regula LIFO, adic\u0103 last in, first out.</p>"},{"location":"mediu/stiva/#problema-stack","title":"Problema stack","text":"<p>Aceast\u0103 problem\u0103 ne cere s\u0103 implement\u0103m exact opera\u021biile descrise mai sus. Acesta este link-ul la implementare.</p>"},{"location":"mediu/stiva/#stiva-din-stl","title":"Stiva din STL","text":"<p>Stiva poate fi implementat\u0103 \u0219i cu func\u021biile din STL. Pentru mai multe detalii, vede\u021bi implementarea \u0219i cppreference.</p>"},{"location":"mediu/stiva/#problema-stack_max_min","title":"Problema stack_max_min","text":"<p>Problema ne d\u0103 un \u0219ir de numere \u0219i 4 \u00eentreb\u0103ri pentru c\u00e2te o pozi\u021bie: 1. Cel mai apropiat indice la st\u00e2nga, unde elementul este mai mare dec\u00e2t pozi\u021bia din \u00eentrebare. 2. Cel mai apropiat indice la st\u00e2nga, unde elementul este mai mic dec\u00e2t pozi\u021bia din \u00eentrebare. 3. Cel mai apropiat indice la dreapta, unde elementul este mai mare dec\u00e2t pozi\u021bia din \u00eentrebare. 4. Cel mai apropiat indice la dreapta, unde elementul este mai mic dec\u00e2t pozi\u021bia din \u00eentrebare.</p> <p>Vom precalcula, pentru fiecare element, r\u0103spunsul la fiecare tip de \u00eentrebare. Aici vom descrie algoritmul doar pentru primul tip, deoarece celelalte se rezolv\u0103 analog.</p> <p>Vom parcurge vectorul de la st\u00e2nga la dreapta, iar pe o stiv\u0103 vom re\u021bine indicii cu elemente mai mici sau egale cu elementul curent. Cu alte cuvinte, pentru fiecare element, scoatem de pe stiv\u0103 toate elementele mai mici sau egale cu el. Dac\u0103 stiva este goal\u0103, atunci r\u0103spunsul este \\(-1\\), altfel este indicele elementului de pe v\u00e2rful stivei. Apoi, \u00eel ad\u0103ug\u0103m pe el \u00eensu\u0219i \u00een stiv\u0103.</p> <p>Observa\u021bie: Pe stiv\u0103 vom re\u021bine indici, nu valori.</p> <p>Vom face o simulare a acestui algoritm, folosindu-ne de exemplul din problem\u0103, \\(v = [1 \\ 2 \\ 3 \\ 6 \\ 4 \\ 5 \\ 3 \\ 2 \\ 1 \\ 10]\\). Ca \u00een problem\u0103, vectorul va fi indexat de la \\(0\\). 1. Suntem la indicele 0, \\(stiva = []\\). R\u0103spunsul va fi -1. 2. Suntem la indicele 1, \\(stiva = [0]\\), dar \u00eel scoatem, iar apoi \\(stiva = []\\). R\u0103spunsul va fi -1. 3. Suntem la indicele 2, \\(stiva = [1]\\), dar \u00eel scoatem, iar apoi \\(stiva = []\\). R\u0103spunsul va fi -1. 4. Suntem la indicele 3, \\(stiva = [2]\\), dar \u00eel scoatem, iar apoi \\(stiva = []\\). R\u0103spunsul va fi -1. 5. Suntem la indicele 4, \\(stiva = [3]\\). R\u0103spunsul va fi 3. 6. Suntem la indicele 5, \\(stiva = [3 \\ 4]\\), dar \u00eel scoatem pe 4. R\u0103spunsul va fi 3. 7. Suntem la indicele 6, \\(stiva = [3 \\ 5]\\). R\u0103spunsul va fi 5. 8. Suntem la indicele 7, \\(stiva = [3 \\ 5 \\ 6]\\). R\u0103spunsul va fi 6. 9. Suntem la indicele 8, \\(stiva = [3 \\ 5 \\ 6 \\ 7]\\). R\u0103spunsul va fi 7. 10. Suntem la indicele 9, \\(stiva = [3 \\ 5 \\ 6 \\ 7 \\ 8]\\), dar le scoatem pe toate, iar apoi \\(stiva = []\\). R\u0103spunsul va fi -1.</p> <p>Aceast\u0103 rezolvare are complexitatea \\(\\mathcal{O}(N)\\), pentru c\u0103 fiecare element va fi pus pe stiv\u0103 \u0219i scos, deci se vor face maxim 2 opera\u021bii pentru fiecare.</p> <p>Detaliii de implementare: vom re\u021bine o matrice \\(raspuns[tip - 1][i]\\) care va reprezenta r\u0103spunsul la o \u00eentrebare de tipul \\(tip \\ i\\). De asemenea, vom folosi o santinel\u0103, care va fi o valoare care va fi mereu mai mic\u0103 (sau mai mare, \u00een func\u021bie de caz) dec\u00e2t orice valoare din vector. Pentru mai multe detalii, vezi implementarea.</p> <p>Link implementare</p>"},{"location":"mediu/stiva/#probleme-rezolvate","title":"Probleme rezolvate","text":""},{"location":"mediu/stiva/#problema-skyline","title":"Problema skyline","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stiva/#problema-maximum-rectangle","title":"Problema Maximum Rectangle","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stiva/#problema-unific-oji-2013-vii","title":"Problema unific - OJI 2013 VII","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stiva/#problema-swap-oni-2013-baraj-juniori","title":"Problema swap - ONI 2013 Baraj Juniori","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stiva/#problema-ehab-and-prefix-mexs-codeforces-round-649","title":"Problema Ehab and Prefix MEXs - Codeforces Round 649","text":"<p>Implementarea se afl\u0103 aici.</p>"},{"location":"mediu/stiva/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>Maximum Building I - CSES (Este aceea\u0219i problem\u0103 ca Maximum Rectangle)</li> <li>inunda\u021bie - ONI 2022 VI (Cerin\u021bele 2 \u0219i 3 pot fi rezolvate folosind o stiv\u0103, necesit\u0103 \u0219i c\u0103utare binar\u0103).</li> <li>fuziune - ONI 2023 Baraj Juniori (Problem\u0103 asem\u0103n\u0103toare cu unific, dar necesit\u0103 lucru cu numere mari \u0219i numere prime)</li> <li>\u0219iruri - ONI 2022 VI (Alt\u0103 problem\u0103 asem\u0103n\u0103toare cu unific)</li> <li>tower - Shumen 2016 Juniori (Nu v\u0103 speria\u021bi c\u0103 este de la Shumen, problema este doar o aplica\u021bie la stack_max_min)</li> <li>maxp - ONI 2013 VIII (O alt\u0103 aplica\u021bie la problema stack_max_min)</li> <li>CF 1905C (Problem\u0103 a c\u0103rei rezolvare se folose\u0219te de tehnica de la stack_max_min)</li> <li>CF 1905D (Problem\u0103 a c\u0103rei rezolvare se folose\u0219te de tehnica de la stack_max_min)</li> <li>CF 1909C (Problem\u0103 care are o rezolvare cu tehnica de la stack_max_min)</li> <li>reactii - ONI 2009 X (Problem\u0103 asem\u0103n\u0103toare cu unific)</li> <li>dag - ONI 2019 Baraj Seniori (Problem\u0103 care se folose\u0219te de tehnica de la stack_max_min)</li> <li>leftmax - OJI 2020 X (Problem\u0103 care se folose\u0219te de tehinca de la stack_max_min)</li> </ul>"},{"location":"mediu/stiva/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Un video despre stiv\u0103, pentru a v\u0103 ajuta s\u0103 \u00een\u021belege\u021bi mai bine acest concept.</li> <li>Un video despre analiza amortizat\u0103, v\u0103 va ajuta s\u0103 \u00een\u021belege\u021bi mai bine rezolvarea problemei stack_max_min \u0219i de ce are complexitatea \\(\\mathcal{O}(N)\\)</li> <li>Algopedia - Stive</li> <li>Algopedia - Analiza amortizat\u0103, mai multe detalii despre problema stack_max_min</li> <li>Articolul de pe USACO despre stiv\u0103</li> </ul>"},{"location":"mediu/ternary_search/","title":"Ternary search","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["sortare","cautari","matematica"]},{"location":"mediu/ternary_search/#introducere","title":"Introducere","text":"<p>Un algoritm de c\u0103utare ternar\u0103 este o tehnic\u0103 \u00een informatic\u0103 pentru a g\u0103si minimul sau maximul unei func\u021bii unimodale (care are un singur punct/interval cu valoare maxim\u0103/minim\u0103). </p> <p>Spre deosebire de alte c\u0103ut\u0103ri similare precum c\u0103utarea binar\u0103, c\u0103utarea ternar\u0103 este util\u0103 pentru a afla dac\u0103 valoarea extrem\u0103 nu se g\u0103se\u0219te \u00een prima sau ultima treime a spa\u021biului de c\u0103utare, algoritmul repet\u00e2ndu-se pentru celelalte dou\u0103 treimi ale intervalului c\u0103utat. </p> <p>C\u0103utarea ternar\u0103 este un exemplu de algoritm de tipul divide et impera, al\u0103turi de c\u0103utarea binar\u0103 \u0219i al\u021bi algoritmi similari. </p>","tags":["sortare","cautari","matematica"]},{"location":"mediu/ternary_search/#functia-in-sine","title":"Func\u021bia \u00een sine","text":"<p>Pentru a putea aplica c\u0103utarea ternar\u0103, trebuie ca func\u021bia s\u0103 fie (des)cresc\u0103toare (de regul\u0103, strict) p\u00e2n\u0103 la un punct \\(x\\) unde g\u0103sim cea mai mic\u0103 pozi\u021bie care ne d\u0103 valoarea maxim\u0103/minim\u0103 a func\u021biei, urm\u00e2nd c\u0103 func\u021bia s\u0103 fie mai apoi constant\u0103 p\u00e2n\u0103 la un punct \\(y\\), iar apoi func\u021bia va avea monotonia opus\u0103 fa\u021b\u0103 de cea p\u00e2n\u0103 la punctul \\(x\\).</p> <p>Cu alte cuvinte, func\u021bia cre\u0219te p\u00e2n\u0103 la punctul \\(x\\), apoi e constant\u0103 \u00een intervalul \\([x, y]\\), iar apoi scade de la punctul \\(y\\). Similar, putem spune \u0219i pentru cazul opus al unei func\u021bii unimodale.</p>","tags":["sortare","cautari","matematica"]},{"location":"mediu/ternary_search/#algoritmul-standard","title":"Algoritmul standard","text":"<p>S\u0103 presupunem c\u0103 avem o func\u021bie \\(f\\) care este definit\u0103 pe intervalul \\([a, b]\\). Asem\u0103n\u0103tor c\u0103ut\u0103rii binare, vom \u00eencepe prin a c\u0103uta acel punct extrem pe \u00eentreg intervalul. La fiecare pas, vom lua punctele \\(m_1\\) \u0219i \\(m_2\\), care vor fi situate la \\(\\frac{1}{3}\\) respectiv \\(\\frac{2}{3}\\) de cap\u0103tul din st\u00e2nga al intervalului, iar \u00een func\u021bie de valorile \\(f(m_1)\\) \u0219i \\(f(m_2)\\), avem urm\u0103toarele cazuri, acestea fiind similare \u0219i pentru o func\u021bie mai \u00eent\u00e2i descresc\u0103toare.</p> <ul> <li>Dac\u0103 \\(f(m_1) &lt; f(m_2)\\), maximul nu poate fi \u00een intervalul \\([a, m_1]\\) deoarece   \\(f(m_2)\\) este mai mare dec\u00e2t \\(f(m_1)\\).</li> <li>Dac\u0103 \\(f(m_1) &gt; f(m_2)\\), maximul nu poate fi \u00een intervalul \\([m_2, b]\\) deoarece   \\(f(m_1)\\) este mai mare dec\u00e2t \\(f(m_2)\\).</li> <li>Dac\u0103 \\(f(m_1) = f(m_2)\\), maximul nu poate fi dec\u00e2t \u00een intervalul \\([m_1, m_2]\\)   deoarece \\(f(m_1)\\) \u0219i \\(f(m_2)\\) sunt de p\u0103r\u021bi opuse ale punctului sau punctelor   maxime.</li> </ul> <p>Dup\u0103 ce am redus c\u0103utarea la o lungime suficient de mic\u0103 pentru a preveni erori de precizie, putem trata intervalul r\u0103mas folosind brute force pentru a ajunge la r\u0103spunsul dorit. Alternativ, putem apela algoritmul de un num\u0103r finit de ori, similar cu modul \u00een care am rula c\u0103utarea binar\u0103 pe numere reale. </p> <p>Complexitatea algoritmului este \\(O(\\log n)\\) unde \\(n\\) este dimensiunea intervalului de c\u0103utare. Se poate remarca faptul c\u0103 spre deosebire de c\u0103utarea binar\u0103, constanta este una mai mare deoarece \u00een medie reducem intervalul de c\u0103utare cu \\(\\frac{1}{3}\\) la un pas.</p> <pre><code>// f(i) este o func\u021bie oarecare\nlong long ternara(int epsilon) {\n    int st = 0;\n    int dr = 1000000000;\n\n    long long ans = -(1LL &lt;&lt; 60);\n\n    while (st &lt;= dr) {\n        int mid1 = st + (dr - st) / 3;\n        int mid2 = dr - (dr - st) / 3;\n\n        if (dr - st + 1 &lt;= epsilon) {\n            for (int i = st; i &lt;= dr; ++i) {\n                ans = max(ans, f(i));\n            }\n            break;\n        }\n\n        long long xa = f(mid1);\n        long long xb = f(mid2);\n\n        ans = max(ans, max(xa, xb));\n\n        if (xa == xb) {\n            st = mid1;\n            dr = mid2;\n        } else if (xa &lt; xb) {\n            st = mid1;\n        } else {\n            dr = mid2;\n        }\n    }\n    return ans;\n}\n</code></pre>","tags":["sortare","cautari","matematica"]},{"location":"mediu/ternary_search/#golden-section-search","title":"Golden Section Search","text":"<p>Pe l\u00e2ng\u0103 c\u0103utarea ternar\u0103, putem folosi pentru a optimiza procesul de c\u0103utare \u0219i c\u0103utarea Golden Section, care spre deosebire de c\u0103utarea ternar\u0103, \u00eemparte intervalul astfel \u00eenc\u00e2t cele dou\u0103 valori de mijloc s\u0103 fie puse la distanta \\(r = \\frac{3 - \\sqrt{5}}{2}\\), distant\u0103 care este egal\u0103 cu \\(\\frac{1}{\\phi}\\), unde \\(\\phi\\) este num\u0103rul de aur, egal cu aproximativ \\(1.618\\).</p> <pre><code>#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nconstexpr double gr = 1.618033988749895;\n\nconstexpr double gss(double (*f)(double), double a, double b,\n                     const double eps = 1e-5) {\n    double c = b - (b - a) / gr;\n    double d = a + (b - a) / gr;\n\n    while (abs(b - a) &gt; eps) {\n        // Pentru maxim, se inverseaz\u0103 semnul\n        if (f(c) &lt; f(d)) {\n            b = d;\n        } else {\n            a = c;\n        }\n\n        // Recalculam c si d pentru a evita pierderea preciziei\n        // lucru ce poate duce la raspunsuri gresite sau loop infinit\n        c = b - (b - a) / gr;\n        d = a + (b - a) / gr;\n    }\n\n    return (b + a) / 2;\n}\n\nint main() {\n    auto f = [](double x) { return (x - 1) * (x - 2); };\n\n    const double result = gss(f, 1, 5);\n\n    std::cout &lt;&lt; \"Minim la x = \" &lt;&lt; result &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>","tags":["sortare","cautari","matematica"]},{"location":"mediu/ternary_search/#problema-exemplu-devu-and-his-brother","title":"Problema exemplu - Devu and his Brother","text":"<p>\u00cen aceast\u0103 problem\u0103 avem doi vectori \\(a\\) \u0219i \\(b\\) \u0219i putem cre\u0219te/sc\u0103dea o valoare dintr-unul din cei doi vectori cu costul \\(1\\). Vrem s\u0103 afl\u0103m costul minim pentru ca minimul din vectorul \\(a\\) s\u0103 fie cel pu\u021bin egal cu maximul din vectorul \\(b\\). </p> <p>Se poate observa c\u0103 e clar c\u0103 vrem s\u0103 cre\u0219tem valorile din \\(a\\) \u0219i s\u0103 sc\u0103dem valorile din \\(b\\). De asemenea, se poate observa c\u0103 pe m\u0103sur\u0103 ce vrem s\u0103 aducem r\u0103spunsul la o oarecare \"median\u0103\", costul va fi tot mai mic. Aceste lucruri ne duc spre o abordare bazat\u0103 pe o c\u0103utare ternar\u0103 a r\u0103spunsului.</p> <p>Astfel, vom c\u0103uta ternar r\u0103spunsul \u00een intervalul \\([1, 10^9]\\) r\u0103spunsul aplic\u00e2nd algoritmul descris mai sus, implementarea fiind cea de mai sus.</p>","tags":["sortare","cautari","matematica"]},{"location":"mediu/ternary_search/#probleme-suplimentare","title":"Probleme suplimentare","text":"<ul> <li>CF 439D</li> <li>copii3 infoarena</li> <li>CEOI 2017 - Sure Bet</li> <li>CF 1355 E</li> <li>CF 1848 D</li> <li>CCO 18-Gradient Descent</li> </ul>","tags":["sortare","cautari","matematica"]},{"location":"mediu/ternary_search/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Ternary Search - CP Algorithms</li> <li>Ternary Search on Integers  - Codeforces</li> <li>Tutorial On Tof (Ternary Search) - Codeforces</li> <li>Solutia de la copii3 - infoarena</li> <li>Ternary Search - Wikipedia</li> <li>Numerical Methods with Programming - Golden Section Search</li> <li>Golden Section Search - Wikipedia</li> </ul>","tags":["sortare","cautari","matematica"]},{"location":"mediu/tree-part2/","title":"Tree part2","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>","tags":["arbori","grafuri","structuri de date"]},{"location":"mediu/tree-part2/#introducere","title":"Introducere","text":"<p>Pentru a putea folosi acest articol la adev\u0103rata lui valoare, se recomand\u0103 citirea articolului (aici trebuie pus href la treebasics) pentru a v\u0103 familiariza cu no\u021biunile discutate aici. De asemenea, pentru anumite concepte, vor fi necesare cuno\u0219tin\u021be suplimentare \u00een ceea ce prive\u0219te structurile de date, programarea dinamic\u0103 \u0219i lucrul cu STL.</p>","tags":["arbori","grafuri","structuri de date"]},{"location":"mediu/tree-part2/#liniarizarea-arborelui","title":"Liniarizarea arborelui","text":"<p>Prima no\u021biune care este necesar\u0103 pentru \u00een\u021belegerea unei mari p\u0103r\u021bi din cuno\u0219tin\u021bele de aici este dat\u0103 de liniarizarea arborelui. Acest procedeu este esen\u021bial pentru a putea transpune informa\u021bia din arbore pentru integrarea structurilor de date \u00eempreun\u0103 cu informa\u021biile deja existente \u00een arbore. Cel mai frecvent algoritm de liniarizare const\u0103 \u00een folosirea unei parcurgeri DFS pentru a trece prin nodurile din arbore \u00een ordinea \u00een care apar, not\u00e2nd pentru fiecare din ele pozi\u021bia la care am intrat \u00een subarborele acelui nod, precum \u0219i pozi\u021bia la care am ie\u0219it din subarborele acelui nod. De aici, putem aplica orice structur\u0103 de date preferat\u0103 pentru a aplica query-urile pe un anumit subarbore. </p> <pre><code>vector&lt;vector&lt;int&gt;&gt; v;\n\nint n, pos, L[200002], R[200002];\nvoid dfs(int parent, int node) {\n    pos++;\n    L[node] = pos;\n\n    for (auto nxt : v[node]) {\n        if (nxt != parent) {\n            dfs(node, nxt);\n        }\n    }\n\n    R[node] = pos;\n}\n</code></pre>","tags":["arbori","grafuri","structuri de date"]},{"location":"mediu/tree-part2/#binary-lifting","title":"Binary Lifting","text":"<p>De multe ori, avem nevoie s\u0103 g\u0103sim \u00eentr-un arbore (sau \u00eentr-o construc\u021bie pe care o putem modela ca un arbore) cu \\(n\\) noduri cel de-al \\(k\\)-lea str\u0103mo\u0219 pentru un nod dat. Dup\u0103 cum \u0219ti\u021bi din articolul anterior, un str\u0103mo\u0219 este un nod la care putem ajunge dac\u0103 urc\u0103m de-a lungul arbore, din nod \u00een nod p\u00e2n\u0103 la r\u0103d\u0103cin\u0103. O prim\u0103 metod\u0103 de a afla acest str\u0103mo\u0219 este de a merge fie folosind un vector de p\u0103rin\u021bi calculat anterior, fie folosind o parcurgere, merg\u00e2nd prin to\u021bi cei \\(k\\) str\u0103mo\u0219i. Totu\u0219i, complexitatea acestui algoritm este \\(O(k)\\), fiind mult prea \u00eencet \u00een cazul \u00een care avem de calculat aceste r\u0103spunsuri pentru mai multe asemenea noduri. </p> <p>\u00cen acest caz, se pune problema parcurgerii celor \\(k\\) mut\u0103ri \u00eentr-o manier\u0103 care s\u0103 ne permit\u0103 aflarea acestui r\u0103spuns \u00eentr-un timp c\u00e2t mai rapid, aici pun\u00e2ndu-se problema cum putem scrie un anumit num\u0103r \u00eentr-o sum\u0103 de c\u00e2t mai pu\u021bine numere pentru a putea r\u0103spunde la aceste \u00eentreb\u0103ri, f\u0103r\u0103 s\u0103 folosim prea mult\u0103 memorie. A\u0219a cum sugereaz\u0103 \u0219i numele articolului, vom folosi reprezentarea binar\u0103 a numerelor pentru a putea calcula aceste r\u0103spunsuri. Cu alte cuvinte, pentru fiecare nod \u0219tim deja primul lui str\u0103mo\u0219, ceea ce ne d\u0103 ideea de a afla str\u0103mo\u0219ii pentru pozi\u021biile corespunz\u0103toare puterilor lui \\(2\\) mai mici sau egale cu \\(n\\). </p> <p>Astfel, vom integra \u00een parcurgerea DFS obi\u0219nuit\u0103 construc\u021bia acestei matrici, unde <code>anc[i][j]</code> va reprezenta cel de-al \\(2^i\\)-lea str\u0103mo\u0219 al nodului \\(j\\). Pentru a afla <code>anc[i][j]</code>, dac\u0103 \\(i = 0\\), atunci <code>anc[i][j]</code> va fi p\u0103rintele nodului \\(j\\), altfel, va fi <code>anc[i-1][anc[i-1][nod]]</code>, practic va fi cel de-al \\(2^{i-1}\\)-lea str\u0103mo\u0219 al celui de-al \\(2^{i-1}\\) lea str\u0103mo\u0219 al nodului curent, astfel folosind proprietatea c\u0103 o putere a lui \\(2\\) e dublul puterii precedente a lui \\(2\\), construind acest \u0219ir din aproape \u00een aproape. </p> <p>Pentru a afla apoi un str\u0103mo\u0219 situat la pozi\u021bia \\(x\\) fa\u021b\u0103 de un nod \\(y\\), tot ce va trebui s\u0103 facem va fi s\u0103 parcurgem invers, \u00eencep\u00e2nd de la nodul curent, folosindu-ne de reprezentarea binar\u0103 a nodului dat. </p> <pre><code>// anc[i][j] = nodul situat la distanta 2^i de nodul j\n\nint n, q, anc[20][200002], lvl[200002];\nvector&lt;int&gt; v[200002];\n\nvoid dfs(int tata, int nod) {\n    // Primul stramos este parintele nodului curent\n    anc[0][nod] = tata;\n\n    // Al 2^i-lea stramos al nodului curent e al 2^(i-1)\n    // lea stramos al 2^(i-1) lea stramos al nodului curent\n    for (int i = 1; i &lt;= 18; ++i) {\n        anc[i][nod] = anc[i - 1][anc[i - 1][nod]];\n    }\n\n    for (int i = 0; i &lt; v[nod].size(); ++i) {\n        int vecin = v[nod][i];\n        if (vecin == tata) {\n            continue;\n        }\n\n        // Avem nevoie de nivelul nodului pe arbore pentru cazul cu -1\n        lvl[vecin] = lvl[nod] + 1;\n        dfs(nod, vecin);\n    }\n}\n\n// Cel de-al k-lea stramos al lui nod\nint solve(int nod, int stp) {\n\n    // Parcurgem nivelele pentru a afla stramosul dorit\n    for (int i = 18; i &gt;= 0; --i) {\n        if (stp &gt;= (1 &lt;&lt; i)) {\n            nod = anc[i][nod], stp -= (1 &lt;&lt; i);\n        }\n    }\n    return nod;\n}\n</code></pre>","tags":["arbori","grafuri","structuri de date"]},{"location":"mediu/tree-part2/#lowest-common-ancestor","title":"Lowest Common Ancestor","text":"<p>De foarte multe ori, se pune problema afl\u0103rii celui mai mic str\u0103mo\u0219 comun \u00eentre dou\u0103 sau mai multe noduri, \u00eentr-un timp c\u00e2t mai eficient. De\u0219i la fel ca la subproblema precedent\u0103, putem g\u0103si r\u0103spunsul folosind o metod\u0103 brut\u0103, folosirea binary lifting se va dovedi instrumental\u0103 pentru aflarea LCA-ului \u00een \\(O(\\log n)\\). Cu alte cuvinte, mai \u00eent\u00e2i vom vrea s\u0103 aducem nodurile la acela\u0219i nivel, iar mai apoi, urc\u0103m \u00een arbore p\u00e2n\u0103 c\u00e2nd ajungem fix \u00eenainte de nodul care ne va da r\u0103spunsul. Cazul c\u00e2nd un nod este str\u0103mo\u0219ul altuia se trateaz\u0103 anterior. Codul de mai jos se bazeaz\u0103 pe precalcul\u0103rile men\u021bionate mai sus.</p> <pre><code>int solve(int a, int b) {\n    if (lvl[a] &lt; lvl[b]) {\n        swap(a, b);\n    }\n\n    for (int i = 18; i &gt;= 0; --i) {\n        if (lvl[a] - (1 &lt;&lt; i) &gt;= lvl[b]) {\n            a = anc[i][a];\n        }\n    }\n\n    if (a == b) {\n        return a;\n    }\n\n    for (int i = 18; i &gt;= 0; --i) {\n        if (dp[i][a] != dp[i][b]) {\n            a = anc[i][a], b = anc[i][b];\n        }\n    }\n\n    return anc[0][a];\n}\n</code></pre>","tags":["arbori","grafuri","structuri de date"]},{"location":"mediu/tree-part2/#alte-probleme-si-resurse-utile","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Euler Tour Technique</li> <li>Binary Lifting + LCA</li> <li>LCA, predat la CPPI Craiova</li> <li>Milk Visits USACO Silver</li> <li>Sap</li> <li>Tutorial - Binary lifting</li> <li>Tutorial video Errichto (Binary lifting)</li> </ul>","tags":["arbori","grafuri","structuri de date"]},{"location":"mediu/treebasics/","title":"Introducere","text":"<p>Arborii sunt un tip particular de grafuri, ace\u0219tia fiind denumirea folosit\u0103 pentru a defini grafurile neorientate conexe \u0219i aciclice. Se poate remarca faptul c\u0103 reprezentarea grafic\u0103 a acestora seaman\u0103 foarte mult cu configura\u021bia unui arbore din p\u0103dure, diferen\u021ba major\u0103 fiind faptul c\u0103 r\u0103d\u0103cina arborelui este plasat\u0103 de obicei \u00een partea de sus a desenului, \u00een contrast cu pozi\u021bia real\u0103 a unei r\u0103d\u0103cini. Nu suntem totu\u0219i la ora de biologie, a\u0219a c\u0103 vom continua cu definirea arborilor.</p> <p>Dintre propriet\u0103\u021bile pe care le au arborii, vom enumera cele mai importante dintre ele, acestea fiind utilizate \u00een mod alternativ \u00een enun\u021buri pentru a defini acela\u0219i lucru.</p> <ul> <li>Graf neorientat conex \u0219i aciclic.</li> <li>Graf neorientat conex cu \\(n\\) noduri \u0219i \\(n-1\\) muchii.</li> <li>Graf neorientat conex cu proprietatea c\u0103 \u00eentre oricare dou\u0103 noduri exist\u0103 un drum unic. Aceast\u0103 proprietate ne permite folosirea DFS pentru aflarea drumurilor minime \u00een arbore, o particularitate ce nu se \u00eent\u00e2lne\u0219te la alte tipuri de grafuri, unde BFS sau al\u021bi algoritmi mai specializa\u021bi de drumuri minime sunt necesare. </li> </ul> <p>Aceste propriet\u0103\u021bi speciale pe care arborii le au fa\u021b\u0103 de grafurile obi\u0219nuite fac rezolvarea multor probleme cu arbori mult mai facil\u0103 dec\u00e2t \u00een mod uzual. \u00cen acest articol vom discuta tipurile de arbori, modalit\u0103\u021bile de a fi parcur\u0219i precum \u0219i c\u00e2teva probleme elementare care pun \u00een eviden\u021b\u0103 modul \u00een care folosim arborii. </p>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#terminologie-de-baza","title":"Terminologie de baz\u0103","text":"<p>Pe l\u00e2ng\u0103 termenii folosi\u021bi la grafuri, vom mai defini c\u00e2\u021biva termeni care sunt frecvent utiliza\u021bi \u00een contextul arborilor. </p> <ul> <li>Un nod cu gradul \\(1\\) se nume\u0219te frunz\u0103.</li> <li>Definim nivelul unui nod ca fiind distan\u021ba de la r\u0103d\u0103cin\u0103 la acesta.</li> <li>Pentru o muchie \\((x, y)\\) cu \\(nivel_x &lt; nivel_y\\), vom spune c\u0103 \\(x\\) este p\u0103rintele lui \\(y\\).</li> <li>\u00cen\u0103l\u021bimea unui subarbore reprezint\u0103 distan\u021ba maxim\u0103 a unui nod fa\u021b\u0103 de r\u0103d\u0103cina arborelui.</li> <li>Dac\u0103 avem dou\u0103 noduri \\(x\\) \u0219i \\(y\\) cu \\(nivel_x &lt; nivel_y\\) \u0219i distan\u021ba de la \\(x\\) la \\(y\\) este \\(nivel_y - nivel_x\\), atunci \\(x\\) este str\u0103mo\u0219 al lui \\(y\\). \u00cen contrast, \\(y\\) este un descendent al lui \\(x\\).</li> <li>Totalitatea nodurilor care sunt descenden\u021bii unui nod \\(x\\) formeaz\u0103 subarborele nodului \\(x\\).</li> </ul>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#tipuri-de-arbori","title":"Tipuri de arbori","text":"<p>\u00cen func\u021bie de particularit\u0103\u021bile pe care le au arborii, putem vorbi de urm\u0103toarele tipuri de arbori.</p> <ul> <li>Arbori cu r\u0103d\u0103cin\u0103 - arbori la care \u0219tim nodul de la care vom \u00eencepe parcurgerile. De regul\u0103, r\u0103d\u0103cina se afl\u0103 \u00een primul nod al arborelui. </li> <li>Arbore stea - arbore \u00een care toate nodurile sunt conectate cu o muchie la un singur alt nod. </li> <li>Arbore lan\u021b - arbore care are forma unui lan\u021b.</li> <li>Arbore binar - arbore cu proprietatea c\u0103 orice nod are cel mult doi fii. Datorit\u0103 importan\u021bei lor, vom insista mai mult asupra lor pentru anumite defini\u021bii viitoare.</li> </ul>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#arbori-binari","title":"Arbori binari","text":"<p>Un arbore binar este un arbore cu proprietatea c\u0103 orice nod are cel mult doi fii. \u00cen func\u021bie de tipul acestui arbore putem defini urm\u0103toarele feluri de arbori binari. </p> <ul> <li>Arbore binar strict - un arbore binar \u00een care fiecare nod, cu excep\u021bia celor terminale, are exact doi descenden\u021bi.</li> <li>Arbore binar plin - un arbore binar \u00een care fiecare nivel \\(k \\in{0,1,2,\\dots,h}\\), unde \\(h\\) este \u00een\u0103l\u021bimea arborelui, con\u021bine \\(2^k\\) noduri.</li> <li>Arbore binar complet - un arbore binar \u00een care fiecare nivel \\(k \\in{0,1,2,\\dots,h}\\), unde \\(h\\) este \u00een\u0103l\u021bimea arborelui, con\u021bine \\(2^k\\) noduri, cu excep\u021bia ultimului nivel, nivelul \\(k\\) con\u021bine eventual mai pu\u021bin de \\(2^h\\) noduri, acestea fiind grupate de regul\u0103 \u00een partea st\u00e2ng\u0103..</li> <li>Arbore binar echilibrat - un arbore binar \u00een care pentru fiecare nod, \u00een\u0103l\u021bimea subarborilor din st\u00e2nga \u0219i din dreapta difer\u0103 cu cel mult \\(1\\). </li> <li>Arbore binar de c\u0103utare - un arbore binar \u00een care fiecare nod are o cheie unic\u0103 de identificare care respect\u0103 urm\u0103toarele condi\u021bii: pentru orice subarbore, cheile nodurilor din subarborele st\u00e2ng sunt mai mici dec\u00e2t cheia r\u0103d\u0103cinii, iar pentru orice subarbore, cheile nodurilor din subarborele drept sunt mai mari dec\u00e2t cheia r\u0103d\u0103cinii.</li> </ul>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#parcurgerile-preordine-inordine-postordine","title":"Parcurgerile preordine, inordine, postordine}","text":"<p>\u00cen func\u021bie de ordinea \u00een care parcurgem nodurile \u00eentr-un arbore binar, putem avea urm\u0103toarele tipuri de parcurgere:</p>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#parcurgerea-preordine-rsd","title":"Parcurgerea preordine (RSD)","text":"<ul> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent. </li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent. </li> </ul> <p>Parcurgerea preordine e o parcurgere ordonat\u0103 topologic, deoarece un nod p\u0103rinte va fi mereu vizitat \u00eenaintea copiilor s\u0103i.</p>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#parcurgerea-inordine-srd","title":"Parcurgerea inordine (SRD)","text":"<ul> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent. </li> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent. </li> </ul> <p>\u00centr-un arbore binar de c\u0103utare construit astfel \u00eenc\u00e2t fiecare nod e mai mare dec\u00e2t nodurile din subarborele st\u00e2ng \u0219i mai mic dec\u00e2t nodurile din subarborele drept, parcurgerea \u00eenordine returneaz\u0103 valorile \u00een ordine cresc\u0103toare.</p>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#parcurgerea-postordine-sdr","title":"Parcurgerea postordine (SDR)","text":"<ul> <li>Vizit\u0103m recursiv subarborele st\u00e2ng al nodului curent. </li> <li>Vizit\u0103m recursiv subarborele drept al nodului curent. </li> <li>Vizit\u0103m mai \u00eent\u00e2i nodul curent</li> </ul> <p>Parcurgerea postordine poate fi util\u0103 pentru a ob\u021bine expresia postfix a unui arbore binar pentru evaluarea unei expresii.</p>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#aplicatii-ale-arborilor-binari","title":"Aplica\u021bii ale arborilor binari","text":"<p>Arborii binari, datorit\u0103 structurii lor foarte versatile, ajung s\u0103 reprezinte o funda\u021bie solid\u0103 \u00een vederea \u00een\u021belegerii foarte multor algoritmi \u0219i structuri de date arborescente, foarte multe implement\u0103ri ale structurilor de date din STL av\u00e2nd la baz\u0103 arborii binari \u00een diverse forme. </p>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#problema-exemplu-aflarea-dimensiunilor-subarborilor-unui-nod","title":"Problem\u0103 exemplu - aflarea dimensiunilor subarborilor unui nod","text":"<p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui s\u0103 parcurgem arborele (de preferat, folosind un DFS) de la r\u0103d\u0103cin\u0103, cu scopul de a ajunge pe r\u00e2nd la toate frunzele arborelui. Pentru fiecare frunz\u0103, dimensiunea subarborelui s\u0103u va fi \\(1\\), iar pentru fiecare nod care nu e frunz\u0103, va fi suma subarborilor fiilor s\u0103i. \u00cen final, vom avea un algoritm ce ruleaz\u0103 \u00een \\(O(n)\\).</p> <pre><code>vector&lt;vector&lt;int&gt; &gt; tree;\nint sz[100001];\nvoid dfs (int nod, int tata) {\n    sz[nod] = 1;\n    for (int i = 0; i &lt; (int) tree[nod].size(); i++) {\n        int fiu = tree[nod][i];\n        if (fiu != tata) {\n            dfs(fiu, nod);\n            sz[nod] += sz[fiu];\n        }\n    }\n}\n</code></pre>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#problema-exemplu-aflarea-diametrului-unui-arbore","title":"Problem\u0103 exemplu - aflarea diametrului unui arbore","text":"<p>Definim diametrul unui graf ca fiind distan\u021ba minim\u0103 cea mai mare \u00eentre dou\u0103 noduri din graf. De\u0219i \u00een mod normal, aceast\u0103 problem\u0103 este NP-hard, \u00een cazul unui arbore exist\u0103 un algoritm simplu care func\u021bioneaz\u0103 \u00een \\(O(n)\\). Pentru a putea ob\u021bine aceast\u0103 distan\u021b\u0103, avem nevoie de dou\u0103 parcurgeri, ambele pot fi DFS sau BFS. </p> <p>Prima parcurgere este dintr-un nod oarecare, scopul fiind s\u0103 afl\u0103m cel mai \u00eendep\u0103rtat nod de acesta. Apoi, vom rula a doua parcurgere din acest nod cel mai \u00eendep\u0103rtat pentru a afla distan\u021ba maxim\u0103 de la acesta la celelalte noduri din arbore. \u00centr-un final, vom ob\u021bine r\u0103spunsul c\u0103utat \u00een \\(O(n)\\) folosind doar dou\u0103 parcurgeri.</p> <pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nint n, root = 1, a, b;\nvector&lt;vector&lt;int&gt; &gt; graph;\nvector&lt;int&gt; dist;\n\nvoid dfs (int parent, int node) {\n    if (dist[node] &gt; dist[root])\n        root = node;\n    for (int i = 0; i &lt; (int) graph[node].size(); i++) {\n        int nxt = graph[node][i];\n        if(nxt == parent) {\n            continue;\n        }\n        dist[nxt] = dist[node] + 1;\n        dfs(node, nxt);\n    }\n}\nint main() {\n    cin &gt;&gt; n;\n    graph.resize(n+1);\n    dist.resize(n+1);\n    for(int i = 1; i &lt; n; i++) {\n        cin &gt;&gt; a &gt;&gt; b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n    dfs(0, root);\n    dist[root] = 0;\n    dfs(0, root);\n    cout &lt;&lt; dist[root] &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["arbori","grafuri"]},{"location":"mediu/treebasics/#alte-probleme-si-resurse-utile","title":"Alte probleme \u0219i resurse utile","text":"<ul> <li>Introduction to Tree Algorithms</li> <li>Grafuri \u0219i arbori - no\u021biuni de baz\u0103</li> <li>Subordinates</li> <li>Grarb infoarena</li> <li>Tree Diameter</li> <li>Mootube USACO Silver</li> <li>Milk Visits USACO Silver</li> <li>Sap</li> </ul>","tags":["arbori","grafuri"]},{"location":"mediu/two_pointers/","title":"Two pointers","text":"","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#fundamente-si-cunostinte-necesare","title":"Fundamente \u0219i cuno\u0219tin\u021be necesare","text":"<p>Tehnica Two pointers este o tehnic\u0103 pe care o putem folosi \u00een foarte multe tipuri de probleme \u00een care avem de c\u0103utat subsecven\u021be cu diverse propriet\u0103\u021bi, condi\u021bia principal\u0103 fiind aceea c\u0103 vrem s\u0103 g\u0103sim o pereche de valori sau de indici ce respect\u0103 anumite reguli, f\u0103r\u0103 s\u0103 dep\u0103\u0219im o anumit\u0103 valoare sau o anumit\u0103 condi\u021bie. Aceast\u0103 tehnic\u0103 apare \u00een foarte multe tipuri de probleme ce se dau la concursurile de informatic\u0103, de foarte multe ori reprezent\u00e2nd o optimizare la posibile solu\u021bii cu c\u0103utare binar\u0103 sau alte structuri de date ce ar ad\u0103uga un factor de complexitate \u00een plus la solu\u021bie.</p> <p>\u00cen articol voi \u00eencepe prin a explica tipurile de probleme unde putem folosi Two pointers, urm\u00e2nd ca apoi s\u0103 prezint c\u00e2teva probleme de diverse dificult\u0103\u021bi, explic\u00e2nd principalele strategii de abordare a acestor tipuri de probleme \u0219i pun\u00e2nd accentul \u0219i pe implement\u0103ri clare, care au drept scop evitarea gre\u0219elilor tipice c\u00e2nd vine vorba de implementarea acestei metode.</p> <p>Pentru a folosi aceast\u0103 metod\u0103, e nevoie s\u0103 st\u0103p\u00e2nim lucrul cu secven\u021be \u0219i ideal \u0219i c\u0103utarea binar\u0103, deoarece pentru multe dintre exemplele ce vor fi men\u021bionate, exist\u0103 solu\u021bii \u0219i folosind acest algoritm. Nu \u00een ultimul r\u00e2nd, pentru anumite probleme e posibil s\u0103 fie nevoie de structuri de date adi\u021bionale, cum ar fi map sau set .</p> <p>\u00cen ceea ce prive\u0219te modul \u00een care \u00eencepem implement\u0103rile, avem dou\u0103 tipuri majore de implement\u0103ri, \u00een func\u021bie de algoritm. Merit\u0103 men\u021bionat faptul c\u0103 ace\u0219ti pointeri sunt de fapt variabile corespunz\u0103toare indicilor din vector la care ne afl\u0103m la momentul respectiv. </p> <p>\u00cen primul r\u00e2nd, vorbim de problemele \u00een care vrem s\u0103 plec\u0103m de la prima pozi\u021bie \u0219i s\u0103 proces\u0103m secven\u021bele care respect\u0103 o anumit\u0103 proprietate monoton\u0103 (cresc\u0103toare sau descresc\u0103toare). \u00cen acest caz, vom avea ambii pointeri cu indexul de \u00eenceput de la 1 \u0219i vom avansa cu pointerul din dreapta at\u00e2ta timp c\u00e2t \u00eenc\u0103 se mai respect\u0103 condi\u021bia cerut\u0103 din enun\u021b.</p> <p>De asemenea, mai exist\u0103 probleme \u00een care plec\u0103m cu pointerul st\u00e2ng de la prima pozi\u021bie \u0219i cu pointerul drept de la ultima pozi\u021bie \u0219i vrem s\u0103 mergem cu ace\u0219ti pointeri \u00een direc\u021bii opuse, deoarece c\u0103ut\u0103m o proprietate ce are o varia\u021bie descresc\u0103toare fa\u021b\u0103 de scopul problemei.</p>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#problema-1-subarray-sums-i","title":"Problema 1 - Subarray Sums I","text":"<p>Dat fiind un vector cu \\(n\\) elemente numere naturale, determina\u021bi num\u0103rul de subsecven\u021be din vector pentru care suma elementelor este egal\u0103 cu \\(x\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 ne folosim de faptul c\u0103 toate numerele din \u0219irul dat sunt pozitive, ceea ce face rezolvarea mult mai u\u0219oar\u0103. Astfel, vom putea afla pentru fiecare pozi\u021bie de \u00eenceput a \u0219irului, care este pozi\u021bia cea mai din dreapta astfel \u00eenc\u00e2t suma valorilor din acel interval s\u0103 fie mai mic\u0103 sau egal\u0103 cu \\(x\\). Dac\u0103 acea sum\u0103 este egal\u0103 cu \\(x\\), vom incrementa r\u0103spunsul. Vom avea grij\u0103 la fiecare pas s\u0103 increment\u0103m variabila \\(st\\), av\u00e2nd grij\u0103 s\u0103 sc\u0103dem valoarea curent\u0103 din sum\u0103 mai \u00eent\u00e2i.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint n, v[200002], x;\nint st, dr, sum, ans;\n\nint main() {\n    ios_base::sync_with_stdio(false);  \n    cin.tie(nullptr);\n\n    cin &gt;&gt; n &gt;&gt; x;\n    for (int i = 1; i &lt;= n; i++) {\n        cin &gt;&gt; v[i];\n    }\n\n    st = dr = 1;\n    sum = ans = 0;\n    while (st &lt;= n) {\n        while (dr &lt;= n &amp;&amp; sum &lt; x) {\n            sum += v[dr];\n            dr++;\n        }\n        if (sum == x) {\n            ans++;\n        }\n        sum -= v[st];\n        st++;\n    }\n    cout &lt;&lt; ans;\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#problema-2-sum-of-two-values","title":"Problema 2 - Sum of Two Values","text":"<p>Se d\u0103 un vector cu \\(n\\) valori pozitive \u0219i o valoare \\(x\\). Scrie\u021bi un program care s\u0103 determine dou\u0103 valori aflate pe pozi\u021bii distincte care adunate s\u0103 dea suma \\(x\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, trebuie s\u0103 folosim o variant\u0103 diferit\u0103 a tehnicii celor doi pointeri. Astfel, de data asta vom \u00eencepe cu un pointer la pozi\u021bia \\(1\\), iar cu cel\u0103lalt la pozi\u021bia \\(n\\). Pe parcurs, vom avea trei cazuri \u00een func\u021bie de suma \\(a_{p_1} + a_{p_2}\\), iar dac\u0103 g\u0103sim dou\u0103 pozi\u021bii cu suma valorilor egal\u0103 cu \\(x\\), afi\u0219\u0103m pozi\u021biile corespunz\u0103toare, altfel modific\u0103m \\(p_1\\) sau \\(p_2\\) dup\u0103 caz. Dac\u0103 nu g\u0103sim nicio pereche, afi\u0219\u0103m IMPOSSIBLE.</p> <pre><code>#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint n, x, a[200002], b[200002];\n\nint main() {\n    cin &gt;&gt; n &gt;&gt; x;\n    for (int i = 1; i &lt;= n; ++i) {\n        cin &gt;&gt; a[i];\n        b[i] = a[i];\n    }\n\n    sort(a + 1, a + n + 1);\n    int p1 = 1, p2 = n;\n\n    while (p1 &lt; p2) {\n        if (a[p1] + a[p2] == x) {\n            int valA = a[p1];\n            int valB = a[p2];\n\n            for (int i = 1; i &lt;= n; ++i) {\n                if (b[i] == valA) {\n                    cout &lt;&lt; i &lt;&lt; \" \";\n                    valA = 0;\n                } else if (b[i] == valB) {\n                    cout &lt;&lt; i &lt;&lt; \" \";\n                    valB = 0;\n                }\n            }\n            return 0;\n        } else {\n            if (a[p1] + a[p2] &gt; x) {\n                --p2;\n            } else {\n                ++p1;\n            }\n        }\n    }\n\n    cout &lt;&lt; \"IMPOSSIBLE\";\n    return 0;\n} \n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#problema-3-nane","title":"Problema 3 - Nane","text":"<p>Nane de pe Jiu, mare algoritmician fiind, v\u0103 provoac\u0103 s\u0103 rezolva\u021bi o problem\u0103 prea u\u0219oar\u0103 pentru el. Nane v\u0103 d\u0103 \\(N\\) numere naturale \u0219i un num\u0103r \\(K\\). Numim subsecven\u021b\u0103 special\u0103 o subsecven\u021b\u0103 pentru care efectu\u00e2nd opera\u021bia OR pe bi\u021bi pentru elementele din subsecven\u021b\u0103 (s\u0103 numim aceast\u0103 opera\u021bie sum\u0103 OR) ob\u021binem un rezultat care are, \u00een reprezentare binar\u0103, cel mult \\(K\\) bi\u021bi de \\(1\\). Dou\u0103 subsecven\u021be sunt diferite dac\u0103 cel pu\u021bin o pozi\u021bie din una nu se reg\u0103se\u0219te \u00een cealalt\u0103. Scrie\u021bi un program care s\u0103 determine num\u0103rul de subsecven\u021be speciale.</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, vom folosi metoda celor doi pointeri pentru a afla num\u0103rul de secven\u021be care au suma OR cu cel mult \\(k\\) de \\(1\\), actualiz\u0103rile fiind foarte similare cu cele de la celelalte probleme de acest tip. De asemenea, deoarece vorbim de suma OR, trebuie s\u0103 folosim c\u00e2te un vector de frecven\u021b\u0103 pentru fiecare bit pentru a evita calculele adi\u021bionale.</p> <pre><code>#include &lt;fstream&gt;\n#define ll long long\nusing namespace std;\n\nint n, k, v[100002], fr[32];\n\nll ans;\n\nbool ok() {\n    int cnt = 0;\n    for (int i = 0; i &lt;= 30; ++i) {\n        if (fr[i]) {\n            ++cnt;\n        }\n    }\n    if (cnt &lt;= k) {\n        return 1;\n    }\n    return 0;\n}\n\nvoid add(int poz, int val) {\n    for (int i = 0; i &lt;= 30; ++i) {\n        if ((v[poz] &amp; (1 &lt;&lt; i))) {\n            fr[i] += val;\n        }\n    }\n}\nint main() {\n    ifstream cin(\"nane.in\");\n    ofstream cout(\"nane.out\");\n\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1; i &lt;= n; ++i) cin &gt;&gt; v[i];\n    int st = 1;\n    int dr = 1;\n    while (st &lt;= n) {\n        while (dr &gt; n || !ok()) {\n            if (ok()) {\n                ans += dr - st;\n                add(st, -1);\n                ++st;\n            } else {\n                add(st, -1);\n                ++st;\n                ans += dr - st;\n            }\n        }\n        while (dr &lt;= n &amp;&amp; ok()) {\n            add(dr, 1);\n            ++dr;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#problema-4-jjooii","title":"Problema 4 - JJOOII","text":"<p>Se consider\u0103 un \u0219ir format din \\(N\\) caractere din mul\u021bimea {J, O, I}. Se nume\u0219te JOI-\u0219ir de nivel \\(K\\) un \u0219ir format din \\(K\\) litere J, \\(K\\) litere O \u0219i \\(K\\) litere I (\u00een aceast\u0103 ordine). De exemplu, JJOOII este un JOI-\u0219ir de nivel \\(2\\). Bitaro dore\u0219te s\u0103 transforme \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\), utiliz\u00e2nd urm\u0103toarele \\(3\\) opera\u021bii, de oric\u00e2te ori \u0219i \u00een orice ordine:</p> <ul> <li>Opera\u021bia \\(1\\): Bitaro \u0219terge primul caracter din \\(S\\);</li> <li>Opera\u021bia \\(2\\): Bitaro \u0219terge ultimul caracter din \\(S\\);</li> <li>Opera\u021bia \\(3\\): Bitaro \u0219terge un caracter din interiorul lui \\(S\\) (care nu este   nici primul nici ultimul).</li> </ul> <p>Deoarece opera\u021biile de tip \\(3\\) necesit\u0103 mult timp, Bitaro dore\u0219te s\u0103 transforme \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\) folosind un num\u0103r minim de opera\u021bii de tip \\(3\\). Scrie\u021bi un program care, cunosc\u00e2nd \\(N\\), \\(S\\) \u0219i \\(K\\), determin\u0103 num\u0103rul minim de opera\u021bii de tip \\(3\\) necesare pentru a transforma \u0219irul \\(S\\) \u00eentr-un JOI-\u0219ir de nivel \\(K\\). Dac\u0103 acest lucru nu este posibil, programul va afi\u0219a valoarea \\(-1\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui mai \u00eent\u00e2i s\u0103 afl\u0103m unde sunt situate literele J, O \u0219i I \u00een \u0219irul nostru de caractere. Ulterior, pe m\u0103sur\u0103 ce fix\u0103m secven\u021bele de \\(k\\) de J, avem pointeri care duc la secven\u021bele corespunz\u0103toare de O \u0219i I din celelalte dou\u0103 \u0219iruri, calculele ulterioare devenind destul de u\u0219oare.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint vj[200001], vo[200001], vi[200001];\n\nint lj, lo, li;\n\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n\n    string s;\n    cin &gt;&gt; s;\n\n    for (int i = 0; i &lt; n; i++) {\n        if (s[i] == 'J') {\n            vj[++lj] = i;\n        }\n        if (s[i] == 'O') {\n            vo[++lo] = i;\n        }\n        if (s[i] == 'I') {\n            vi[++li] = i;\n        }\n    }\n\n    int pj = 1;\n    int po = 1;\n    int pi = 1;\n\n    int ans = n + 1;\n\n    for (int pj = 0; pj + k - 1 &lt; lj; ++pj) {\n        int po = 0;\n        while (po + k - 1 &lt; lo &amp;&amp; vo[po] &lt;= vj[pj + k - 1]) {\n            po++;\n        }\n\n        if (po + k - 1 &lt; lo) {\n            int pi = 0;\n            while (pi + k - 1 &lt; li &amp;&amp; vi[pi] &lt;= vo[po + k - 1]) {\n                pi++;\n            }\n\n            if (pi + k - 1 &lt; li) {\n                int start = vj[pj];\n                int end = vi[pi + k - 1];\n                int segment_length = (end - start + 1) - 3 * k;\n\n                ans = min(ans, segment_length);\n            }\n        }\n    }\n\n    cout &lt;&lt; (ans == n + 1 ? -1 : ans);\n    return 0;\n}\n</code></pre>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#probleme-suplimentare","title":"Probleme suplimentare","text":"","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Probleme cu two pointers</li> <li>Infoarena 3secv</li> <li>JOI JJOOII 2</li> <li>NOI Singapore Global Warming</li> <li>Baraj Seniori 2023 sirbun</li> <li>Infoarena nane</li> <li>USACO Social   Distancing</li> <li>USACO MooTube</li> <li>USACO Wormhole   Sort</li> <li>USACO Sprinklers</li> <li>USACO Cow Dating</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#probleme-de-pe-codeforces","title":"Probleme de pe Codeforces","text":"<ul> <li>Towers -   Codeforces</li> <li>Two Pointers -   Codeforces</li> <li>Two Pointers Step 1 - Codeforces   EDU</li> <li>Two Pointers Step 2 - Codeforces   EDU</li> <li>Two Pointers Step 3 - Codeforces   EDU</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"mediu/two_pointers/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Two Pointers - USACO Guide</li> <li>Link ce trebuie accesat pentru inscrierea la cursul despre DSU facut de ITMO   Academy</li> <li>Curs despre Two Pointers - Codeforces (este necesar un cont pentru a putea   accesa acest curs, plus accesarea linkului de mai   sus)</li> <li>Using the Two Pointers   Technique</li> <li>Edu - Two pointers</li> <li>Competitive Programmer's Handbook - Capitolul   8</li> </ul>","tags":["vectori","sortare","cautari"]},{"location":"usor/cautari/","title":"C\u0103utarea binar\u0103","text":"<p>Autor: Andrei-Cristian Ivan</p> <p>S\u0103 presupunem c\u0103 avem un \u0219ir de \\(N\\) numere \u0219i memorie astfel \u00eenc\u00e2t s\u0103 putem re\u021bine doar \u0219irul (plus evident alte variabile, dar nu foarte multe). Noi primim mai multe \u00eentreb\u0103ri, de forma: Exist\u0103 valoarea \\(X\\) \u00een \u0219ir?</p> <p>\u00cen mod evident, o solu\u021bie foarte trivial\u0103 este s\u0103 parcurgem manual \u0219irul pentru fiecare \u00eentrebare, \u0219i s\u0103 vedem dac\u0103 elementul cerut apare sau nu \u00een \u0219ir, astfel ob\u021bin\u00e2nd complexitate total\u0103 de \\(O(N \\cdot Q)\\). Singura noastr\u0103 problem\u0103 este c\u0103 noi o s\u0103 avem \\(N\\) \u0219i \\(Q\\) undeva \u00een jur de \\(10^6\\), ceea ce va face ca aceast\u0103 abordare s\u0103 pice clar \u00een timp, deci va trebui g\u0103sit\u0103 o solu\u021bie mult mai eficient\u0103. Aici intervine algoritmul de c\u0103utare binar\u0103.</p>","tags":["vectori"]},{"location":"usor/cautari/#prezentarea-algoritmului","title":"Prezentarea algoritmului","text":"<p>Not\u0103</p> <p>De acum \u00eencolo, se va presupune c\u0103 \u0219irul nostru este sortat cresc\u0103tor. C\u0103utarea binar\u0103 pe un \u0219ir nesortat va da mereu r\u0103spunsuri eronate.</p> <p>\u00cen algoritmul de c\u0103utare binar\u0103 se va pleca de la analiza \u0219irului pe \u00eentreaga sa lungime, \u0219i se va fixa punctul de mijloc din sir. Dac\u0103 valoarea pozi\u021biei din mijloc este mai mic\u0103 dec\u00e2t valoarea c\u0103utat\u0103, atunci sigur valoarea c\u0103utat\u0103 se poate (c\u0103 nu \u0219tim sigur dac\u0103 exist\u0103!) afla \u00een a doua jum\u0103tate, altfel, se poate afla \u00een prima jum\u0103tate. Mai departe, nu va mai fi necesar sa analiz\u0103m tot \u0219irul, ci doar jum\u0103tatea relevant\u0103 (cea \u00een care consider\u0103m noi c\u0103 exist\u0103 o \u0219ans\u0103 s\u0103 g\u0103sim valoarea noastr\u0103), \u0219i algoritmul se va repeta p\u00e2n\u0103 c\u00e2nd lungimea devine \\(1\\) \u0219i putem determina r\u0103spunsul. Dat fiind faptul c\u0103 noi la fiecare pas \u00eemp\u0103r\u021bim la \\(2\\) lungimea \u0219irului, acest lucru ne va da complexitate logaritmic\u0103 la determinarea r\u0103spunsului, deci vom avea complexitate \\(O(Q \\log N)\\) (dac\u0103 \u0219irul nostru nu este sortat din input, se mai adaug\u0103 \u0219i un \\(O(N \\log N)\\) la complexitate), cu memorie \\(O(N)\\).</p> <p>Pentru o \u00een\u021belegere mai clar\u0103 a algoritmului, s\u0103 presupunem urm\u0103torul exemplu: se d\u0103 un \u0219ir sortat cresc\u0103tor unde apar toate numerele de la \\(1\\) la \\(100\\), \u0219i se cere s\u0103 determin\u0103m dac\u0103 exist\u0103 \u00een \u0219ir valoarea \\(72\\).</p> <p> </p> <p>O \u00eentrebare la care trebuie totu\u0219i dat r\u0103spuns este: De ce \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi \u0219i de ce nu \u00een \\(3\\) treimi? Da, \\(\\log_3 N &lt; \\log_2 N\\), dar num\u0103rul de verific\u0103ri efectuate va fi mai mare la \u00eemp\u0103r\u021birea \u00een \\(3\\) treimi, deci \u00een continuare este mai eficient s\u0103 \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi. \u00cen mod inductiv se va demonstra pentru orice \u00eemp\u0103r\u021bire posibil\u0103.</p>","tags":["vectori"]},{"location":"usor/cautari/#o-implementare-banala","title":"O implementare banal\u0103","text":"<p>Cea mai des \u00eent\u00e2lnit\u0103 implementare a c\u0103ut\u0103rii binare este urm\u0103toarea:</p> <pre><code>int cb_naiv(int n) {\n    int l = 1;\n    int r = n;\n    int ans = -1;\n\n    while (l &lt;= r) {\n        int mij = (l + r) / 2;\n        if (conditie) {\n            ans = mij;\n            l = mij + 1;\n        } else {\n            r = mij - 1;\n        }\n    }\n\n    return ans;\n}\n</code></pre> <p>Implementarea de mai sus este una corect\u0103, dar se pot \u00eent\u00e2lni urm\u0103toarele bug-uri:</p> <ul> <li> <p>Schimbarea \u00een \\(l = mij\\) \u0219i \\(r = mij\\) va face ca programul nostru s\u0103 ruleze   \u00eentr-o bucl\u0103 infinit\u0103 (deoarece ambele valori vor atinge la un moment dat   valoarea \\(mij\\), \u0219i deci va fi respectat\u0103 mereu condi\u021bia \\(l \\leq r\\))</p> </li> <li> <p>\u00cen timp ce-l calcul\u0103m pe \\(mij\\), ne putem lua overflow (dac\u0103 prin absurd   ajungem s\u0103 c\u0103utam fix pe la valorile maxime pe care le poate re\u021bine tipul   nostru de date, este inevitabil un overflow generat de \\(l + r\\)). De aceea,   urm\u0103toarea variant\u0103 prezentat\u0103 se va axa fix pe rezolvarea acestui bug.</p> </li> </ul>","tags":["vectori"]},{"location":"usor/cautari/#o-implementare-corecta","title":"O implementare corect\u0103","text":"<pre><code>int cb_corect(int n) {\n    int l = 1;\n    int r = n;\n    int ans = -1;\n\n    while (l &lt; r) {\n        int mij = l + (r - l) / 2;\n\n        if (conditie) {\n            ans = mij;\n            l = mij + 1;\n        } else {\n            r = mij - 1;\n        }\n    }\n\n    return ans;\n}\n</code></pre> <p>Aceast\u0103 c\u0103utare binar\u0103 se bazeaz\u0103 pe principiul men\u021bionat mai sus: noi \u00eenjum\u0103t\u0103\u021bim de fiecare dat\u0103 lungimea \u0219irului pe care \u00eencerc\u0103m s\u0103 c\u0103ut\u0103m ceea ce ne intereseaz\u0103. Formula de mai sus pentru calcularea mijlocului este echivalent\u0103 cu cea din prima c\u0103utare, dar mai mult, nu are cum s\u0103 ne dea overflow.</p> <p>De fiecare dat\u0103 c\u00e2nd mijlocul nostru verific\u0103 condi\u021bie, noi facem un \u201esalt\u201d de la o pozi\u021bie \\(l\\) la alta. La finalul c\u0103ut\u0103rii, indicele \\(l\\) final va fi defapt o sum\u0103 a salturilor, iar ca pe orice num\u0103r \u00eentreg, noi acest num\u0103r \u00eel putem descompune \u00eentr-o alt\u0103 baz\u0103 numeric\u0103. Hai s\u0103 vedem cum putem rafina aceast\u0103 idee cu o alt\u0103 implementare mai jos.</p>","tags":["vectori"]},{"location":"usor/cautari/#cautarea-binara-a-lui-mihai-patrascu","title":"C\u0103utarea binar\u0103 a lui Mihai P\u0103tra\u0219cu","text":"<pre><code>void cb3_patrascu(int n) {\n    int l = 0;\n\n    for (int bit = 31; bit &gt;= 0; --bit) {\n        int putere = 1 &lt;&lt; bit;\n        if ((l | putere) &lt;= n &amp;&amp; conditie) {\n            l |= putere;\n        }\n    }\n}\n</code></pre> <p>Baza \u00een care noi vom descompune suma va fi baza \\(2\\), pentru a men\u021bine \u00een continuare complexitatea \\(\\log_2 N\\). Ini\u021bial, vom pleca cu un exponent \\(e\\), unde \\(2^e\\) va reprezenta lungimea secven\u021bei pe care o analiz\u0103m (aten\u021bie s\u0103 nu ie\u0219im din vector!). Chiar dac\u0103 noi vom analiza ini\u021bial o lungime care este putere de \\(2\\), care foarte probabil s\u0103 fie diferit\u0103 de \\(N\\), se poate demonstra foarte u\u0219or c\u0103 noi (dac\u0103 o s\u0103 fie necesar), vom putea c\u0103uta valori \u0219i \u00een acea secven\u021b\u0103 neacoperit\u0103 ini\u021bial. L\u0103s\u0103m aceast\u0103 demonstra\u021bie ca tem\u0103 pentru cititor.</p> <p>C\u0103utarea de mai sus poart\u0103 \u0219i numele de C\u0103utarea binar\u0103 a lui Mihai P\u0103tra\u0219cu, sau c\u0103utarea pe bi\u021bi.</p> <p>\u00cen mare parte, aceste c\u0103ut\u0103ri binare ne vor da aceea\u0219i complexitate peste tot, \u00een schimb, c\u00e2nd vrem s\u0103 implement\u0103m algoritmul de Lowest Common Ancestor (LCA) cu Binary Lifting, c\u0103utarea binar\u0103 pe bi\u021bi reduce algoritmul de la \\(O(\\log^2{H})\\) la \\(O(\\log{H})\\), unde \\(H\\) reprezint\u0103 ad\u00e2ncimea maxim\u0103 a arborelui.</p>","tags":["vectori"]},{"location":"usor/cautari/#cautarea-binara-pe-raspuns","title":"C\u0103utarea binar\u0103 pe r\u0103spuns","text":"<p>Aici trebuie completat</p>","tags":["vectori"]},{"location":"usor/cautari/#functii-de-sistem-pentru-cautarea-binara","title":"Func\u021bii de sistem pentru c\u0103utarea binar\u0103","text":"<p>\u0218i aici trebuie completat</p>","tags":["vectori"]},{"location":"usor/cautari/#concluzii-si-lecturi-suplimentare","title":"Concluzii \u0219i lecturi suplimentare","text":"<p>C\u0103utarea binar\u0103 este unul dintre cele mai fundamentale principii ale algoritmicii, fiind absolut necesar pentru a optimiza probleme unde ni se cere s\u0103 determin\u0103m existen\u021ba unei valori \u00eentr-un \u0219ir, sau determinarea unui num\u0103r maxim/minim care s\u0103 respecte o condi\u021bie impus\u0103 de problem\u0103 etc.</p> <p>Pentru aprofundarea a algoritmului, recomand rezolvarea urm\u0103toarelor probleme \u0219i citirea urm\u0103toarelor articole:</p> <p>\u0218i aici trebuie destule probleme \u0219i exemple</p> <ul> <li>Problema cautbin (Infoarena)</li> <li>Binary Search - USACO Guide</li> <li>Cursurile Edu de pe Codeforces, este necesar\u0103 \u00eenregistrarea anterioar\u0103</li> </ul>","tags":["vectori"]},{"location":"usor/divizibilitate/","title":"Divizibilitatea","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, \u0218tefan-Iulian Alecu</p> <p>De-a lungul parcursului vostru \u00een domeniul algoritmicii, precum \u0219i de multe ori \u00een diferite olimpiade \u0219i concursuri de informatic\u0103, va trebui s\u0103 rezolva\u021bi multe probleme care se bazeaz\u0103 pe un fundament matematic, studiul teoriei din spatele divizibilit\u0103\u021bii numerelor naturale precum \u0219i a algoritmilor de aflare a numerelor prime, num\u0103rului de divizori, lucrului eficient cu numerele prime devenind toate foarte importante pentru asimilarea \u00een cel mai bun mod posibil a acestui capitol. Totu\u0219i, acest document reprezint\u0103 doar un punct de plecare \u00een ceea ce prive\u0219te aplica\u021biile teoriei numerelor \u00een algoritmic\u0103, alte concepte fiind discutate \u00een documentele ulterioare. Aceste no\u021biuni se vor g\u0103si foarte des \u00een problemele de informatic\u0103 pentru clasele de gimnaziu \u0219i clasa a IX-a.</p>"},{"location":"usor/divizibilitate/#notiuni-introductive","title":"No\u021biuni introductive","text":"<p>Defini\u021bie</p> <p>Un num\u0103r \\(x\\) este numit divizor al altui num\u0103r \\(y\\), dac\u0103 \\(y\\) se poate scrie ca produsul dintre \\(x\\) \u0219i un alt num\u0103r \u00eentreg \\(t\\).</p> <p>Observa\u021bie</p> <p>Orice num\u0103r \\(n\\) se \u00eemparte la \\(1\\) \u0219i la el \u00eensu\u0219i.</p> <p>Defini\u021bie</p> <p>Definim un divizor comun al unei perechi de numere \\((a, b)\\) ca fiind un num\u0103r \\(c\\) care este un divizor at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\).</p> <p>CMMDC \u0219i CMMMC</p> <p>Definim cel mai mare divizor comun (cmmdc) al unei perechi de numere \\((a, b)\\) ca fiind cel mai mare num\u0103r care este un divizor at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\). Vom nota \\(x = (a, b)\\). Definim cel mai mic multiplu comun (cmmmc) al unei perechi de numere \\([a, b]\\) ca fiind cel mai mic num\u0103r care este un multiplu at\u00e2t al lui \\(a\\), c\u00e2t \u0219i al lui \\(b\\). Vom nota \\(x = [a, b]\\).</p> <p>Observa\u021bie</p> <p>\\(a \\cdot b = (a, b) \\cdot [a, b]\\). Drept concluzie, \\((a, b) = \\frac{a \\cdot b}{[a, b]}\\). </p> <p>Pentru aflarea celui mai mare divizor comun a dou\u0103 numere, exist\u0103 doi algoritmi principali. Primul dintre ei se bazeaz\u0103 pe sc\u0103deri repetate, la fiecare pas sc\u0103z\u00e2ndu-se din num\u0103rul mai mare, num\u0103rul mai mic p\u00e2n\u0103 c\u00e2nd cele dou\u0103 valori devin egale. De\u0219i pentru multe perechi de numere acest algoritm este destul de eficient, atunci c\u00e2nd diferen\u021ba dintre numere este foarte mare, algoritmul va rula \u00een timp cvasi-liniar (de exemplu, pentru numerele \\(3\\) \u0219i \\(10^9\\), un calculator are nevoie de c\u00e2teva secunde s\u0103 afle cmmdc-ul folosind acest algoritm).</p> <p>De aceea vom folosi algoritmul lui Euclid prin \u00eemp\u0103r\u021biri repetate pentru a ajunge la r\u0103spuns. Acest algoritm pleac\u0103 de la ideea c\u0103 o sl\u0103biciune major\u0103 a algoritmului prin sc\u0103deri este dat\u0103 de situa\u021bia c\u00e2nd raportul dintre num\u0103rul mai mare \u0219i cel mai mic este foarte mare, c\u00e2nd practic efectu\u0103m aceea\u0219i opera\u021bie de foarte multe ori. De aceea, \u00een loc de sc\u0103deri, la fiecare pas vom afla restul \u00eemp\u0103r\u021birii num\u0103rului mai mare la cel mai mic, \u00eenlocuind posibilele opera\u021bii de sc\u0103dere cu o singur\u0103 \u00eemp\u0103r\u021bire, algoritmul devenind mult mai eficient. </p> <p>Exemplu</p> <p>De exemplu, s\u0103 analiz\u0103m numerele \\(40\\) \u0219i \\(18\\).</p> <ul> <li>\\(a = 40, b = 18\\). \\(a \\% b = 4\\), noile valori fiind \\(a = 18, b = 4\\);</li> <li>\\(a = 18, b = 4\\). \\(a \\% b = 2\\), noile valori fiind \\(a = 4, b = 2\\);</li> <li>\\(a = 4, b = 2\\). \\(a \\% b = 0\\), noile valori fiind \\(a = 2, b = 0\\);</li> <li>\\(a = 2, b = 0\\). Deoarece \\(b = 0\\), continuarea algoritmului ne-ar duce la \u00eemp\u0103r\u021biri la \\(0\\), opera\u021bie ce nu este valid\u0103.</li> </ul> <p>Mai jos pute\u021bi g\u0103si implementarea \u00een C++ a cmmdc-ului \u0219i a cmmmc-ului, program ce afl\u0103 cmmdc \u0219i cmmmc pentru \\(t\\) perechi de numere. Complexitatea algoritmului este \\(O(\\log n)\\) pentru fiecare test.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconstexpr auto cmmdc(int a, int b) {\n    while (b &gt; 0) {\n        int c = a % b;\n        a = b;\n        b = c;\n    }\n    return a;\n}\n\nconstexpr auto cmmmc(int a, int b) { \n    return 1LL * a / cmmdc(a, b) * b; \n}\n\nint main() {\n    int t;\n    cin &gt;&gt; t;\n\n    while (t--) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n\n        auto gcd = cmmdc(a, b);\n        auto lcm = cmmmc(a, b);\n        cout &lt;&lt; gcd &lt;&lt; \" \" &lt;&lt; lcm &lt;&lt; '\\n';\n    }\n    return 0;\n}\n</code></pre> <p>Not\u0103</p> <p>C++17 ofer\u0103 <code>std::gcd()</code> \u0219i <code>std::lcm()</code> \u00een <code>&lt;numeric&gt;</code>, deci nu este nevoie s\u0103 reimplementa\u021bi algoritmul dac\u0103 ave\u021bi acces la un asemenea compilator. </p>"},{"location":"usor/divizibilitate/#lucrul-cu-divizorii-unui-numar","title":"Lucrul cu divizorii unui num\u0103r","text":"<p>Numere prime \u0219i compuse</p> <p>Un num\u0103r \\(n \\geq 2\\) este num\u0103r prim dac\u0103 \u0219i numai dac\u0103 are doar \\(2\\) divizori: \\(1\\) \u0219i \\(n\\), \u00een caz contrar fiind num\u0103r compus.</p> <p>Observa\u021bii</p> <ol> <li>\\(0\\) \u0219i \\(1\\) nu sunt nici numere prime, nici numere compuse.</li> <li>\\(2\\) este singurul num\u0103r prim par, celelalte numere prime fiind impare.</li> </ol> <p>Descompunerea \u00een factori primi se bazeaz\u0103 pe Teorema fundamental\u0103 a aritmeticii, dat\u0103 mai jos:</p> <p>Teorema fundamental\u0103 a aritmeticii</p> <p>Orice num\u0103r natural \\(n &gt; 1\\) se poate scrie \u00een mod unic sub forma  $$ n = \\prod_{i = 1}^k p_i^{e_i} $$ unde \\(p_1 &lt; p_2 &lt; \\dots &lt; p_k\\) sunt numere prime, iar \\(e_i \\in \\mathbb{N}^\\ast~\\forall 1 \\leq i \\leq k\\).</p> <p>Observa\u021bie</p> <p>Se poate observa c\u0103 num\u0103rul maxim de numere prime la care se \u00eemparte un num\u0103r \\(n\\) este foarte mic. De exemplu, pentru \\(n \\leq 10^{9}\\), sunt cel mult \\(9\\) numere prime \u00een reprezentarea ca produs de factori primi.</p> <p>Pentru a afla divizorii unui num\u0103r natural \\(n\\), cel mai simplu (dar \u0219i ineficient) algoritm const\u0103 \u00een a verifica pe r\u00e2nd fiecare num\u0103r \\(1\\) la \\(n\\) \u0219i s\u0103 verific\u0103m dac\u0103 \\(n\\) se \u00eemparte exact la acel num\u0103r. Pentru a optimiza acest algoritm, va trebui s\u0103 folosim o alt\u0103 observa\u021bie important\u0103.</p> <p>Observa\u021bie</p> <p>Dac\u0103 \\(n\\) se \u00eemparte exact la \\(x\\), se va \u00eemp\u0103r\u021bi exact \u0219i la \\(\\frac{n}{x}\\). A\u0219adar, \\(x^2 \\leq n\\) sau \\(x \\leq \\sqrt{n}\\). Asta ne duce la ideea s\u0103 verific\u0103m doar divizorii p\u00e2n\u0103 la \\(\\sqrt{n}\\), observa\u021bie ce se va dovedi fundamental\u0103 \u00een calculele \u0219i algoritmii pe care \u00ee\u00ee vom scrie pentru toate aceste probleme.</p> <p>Astfel, vom putea afla orice informa\u021bie legat\u0103 de divizorii unui num\u0103r \u00een \\(O(\\sqrt{n})\\), fie c\u0103 e vorba de num\u0103rul de divizori, divizorii primi, descompunerea \u00een factori primi \u0219i a\u0219a mai departe.</p> <p>Totu\u0219i, putem verifica cu u\u0219urin\u021b\u0103 pentru un num\u0103r \\(n\\) dac\u0103 \\(d\\) este divizor al acestuia, folosind o simpl\u0103 condi\u021bie aritmetic\u0103</p> <pre><code>if (n % d == 0) {\n    cout &lt;&lt; d &lt;&lt; \" este divizor al lui \" &lt;&lt; n &lt;&lt; '\\n';\n}\n</code></pre>"},{"location":"usor/divizibilitate/#problema-divizibilitate-de-pe-kilonova","title":"Problema divizibilitate de pe Kilonova","text":"<p>Cerin\u021b\u0103</p> <p>Se d\u0103 un num\u0103r \\(t\\) \u0219i \\(t\\) numere naturale. S\u0103 se afle pentru fiecare dintre ele r\u0103spunsul la una din urm\u0103toarele \u00eentreb\u0103ri:</p> <ul> <li> <p>\\(1 \\ n\\): S\u0103 se afle dac\u0103 \\(n\\) este prim sau nu. \u00cen caz afirmativ se va afi\u0219a <code>YES</code>, altfel se va afi\u0219a <code>NO</code>.</p> </li> <li> <p>\\(2 \\ n\\): S\u0103 se afle c\u00e2\u021bi divizori are \\(n\\) \u2014 de exemplu, dac\u0103 \\(n = 12\\), se va afi\u0219a \\(6\\) (\\(1\\), \\(2\\), \\(3\\), \\(4\\), \\(6\\), \\(12\\) sunt divizorii lui \\(12\\)).</p> </li> <li> <p>\\(3 \\ n\\): S\u0103 se afle num\u0103rul divizorilor primi ai lui \\(n\\) \u2014 de exemplu, dac\u0103 \\(n = 21\\), se va afi\u0219a \\(2\\).</p> </li> <li> <p>\\(4 \\ n\\): S\u0103 se afi\u0219eze descompunerea \u00een factori primi pe care o are un num\u0103r, fiecare factor fiind scris pe o linie, \u00een ordine cresc\u0103toare a numerelor prime \u2014 de exemplu, dac\u0103 \\(n = 60\\), se vor afi\u0219a pe \\(3\\) linii separate:</p> </li> </ul> <pre><code>2 2\n3 1\n5 1\n</code></pre> <p>Fiecare tip de \u00eentrebare a fost implementat folosind o func\u021bie separat\u0103 pentru a ar\u0103ta diferen\u021bele ce pot ap\u0103rea de la un tip de \u00eentrebare la alta.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nconstexpr bool isPrime(int n) {\n    // n == 0 || n == 1\n    if (n &lt;= 1) {\n        return false;\n    }\n\n    // n == 2 || n == 3\n    if (n &lt;= 3) {\n        return true;\n    }\n\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n\n    // Iter\u0103m prin to\u021bi divizorii primi, care-s de forma 6k \u00b1 1\n    for (int d = 5; d * d &lt;= n; d += 6) {\n        if (n % d == 0 || n % (d + 2) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nconstexpr int countDivisors(int n) {\n    int count = 0;\n\n    for (int div = 1; div * div &lt;= n; ++div) {\n        if (n % div == 0) {\n            // Dac\u0103 div = n/div, atunci \u00eenseamn\u0103 c\u0103 avem un singur \n            // divizor distinct.\n            count += (div == n / div) ? 1 : 2;\n        }\n    }\n    return count;\n}\n\nconstexpr int countPrimeDivisors(int n) {\n    int count = 0;\n\n    for (int div = 2; div * div &lt;= n; ++div) {\n        if (n % div == 0) {\n            count++;\n\n            // Elimin\u0103m to\u021bi multiplii de i, deoarece am contorizat \n            // deja divizorul.\n            while (n % div == 0) {\n                n /= div;\n            }\n        }\n    }\n\n    if (n &gt; 1) {\n        count++;\n    }\n\n    return count;\n}\n\nvoid printPrimeDivisors(int n) {\n    for (int div = 2; div * div &lt;= n; ++div) {\n        if (n % div == 0) {\n            int cnt = 0;\n\n            // Dac\u0103 am g\u0103sit un divizor, calcul\u0103m exponentul s\u0103u.\n            while (n % div == 0) {\n                cnt++;\n                n /= div;\n            }\n\n            cout &lt;&lt; div &lt;&lt; \" \" &lt;&lt; cnt &lt;&lt; '\\n';\n        }\n    }\n\n    if (n &gt; 1) {\n        cout &lt;&lt; n &lt;&lt; \" 1\\n\";\n    }\n}\n\nvoid solveQuery(int type, int n) {\n    switch (type) {\n        case 1:\n            cout &lt;&lt; (isPrime(n) ? \"YES\" : \"NO\") &lt;&lt; '\\n';\n            break;\n        case 2:\n            cout &lt;&lt; countDivisors(n) &lt;&lt; '\\n';\n            break;\n        case 3:\n            cout &lt;&lt; countPrimeDivisors(n) &lt;&lt; '\\n';\n            break;\n        case 4:\n            printPrimeDivisors(n);\n            break;\n        default:\n            break;\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t;\n    cin &gt;&gt; t;\n\n    while (t--) {\n        int type, number;\n        cin &gt;&gt; type &gt;&gt; number;\n\n        solveQuery(type, number);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"usor/divizibilitate/#probleme-si-lectura-suplimentara","title":"Probleme \u0219i lectur\u0103 suplimentar\u0103","text":"<p>Aici mai trebuie probleme </p> <ul> <li>Probleme cu divizibilitate de pe kilonova</li> <li>Number theory  \u2014  Storing information about multiples/divisors</li> <li>Articol de pe USACO Guide</li> <li>Counting Divisors of a Number in \\(N^\\frac{1}{3}\\)</li> </ul>"},{"location":"usor/graphs/","title":"Graphs","text":"<p>Autori: \u0218tefan-Cosmin D\u0103sc\u0103lescu, \u0218tefan-Iulian Alecu</p> <p>\u00cen cele ce urmeaz\u0103 vom prezenta o structur\u0103 de date cu foarte multe aplica\u021bii at\u00e2t \u00een algoritmic\u0103, c\u00e2t \u0219i \u00een via\u021ba de zi cu zi, acestea fiind grafurile. Problema afl\u0103rii existen\u021bei unor conexiuni sau afl\u0103rii distan\u021bei minime \u00eentre dou\u0103 noduri reprezint\u0103 un punct de plecare pentru majoritatea algoritmilor pe grafuri, teoria folosit\u0103 \u00een algoritmic\u0103 fiind una vast\u0103 \u0219i plin\u0103 de abord\u0103ri ce se dovedesc a fi esen\u021biale \u00een foarte multe situa\u021bii, at\u00e2t competi\u021bionale, c\u00e2t \u0219i \u00een aplica\u021bii practice.</p>"},{"location":"usor/graphs/#notiuni-introductive","title":"No\u021biuni introductive","text":""},{"location":"usor/graphs/#terminologie","title":"Terminologie","text":"<p>Un graf este o structur\u0103 care corespunde unui grup de obiecte, \u00een care unele perechi de obiecte sunt \u00eentr-un anumit sens \u201elegate\u201d reciproc. Obiectele corespund unor abstrac\u021bii matematice numite \u00eentr-un graf noduri/v\u00e2rfuri (numite \u0219i puncte) \u0219i fiecare leg\u0103tur\u0103 dintre perechile de obiecte asociate se nume\u0219te muchie (numit\u0103 \u0219i arc sau linie, prin care este \u0219i reprezentat\u0103).</p> <p>O defini\u021bie mai riguroas\u0103 ce se va dovedi util\u0103 este prezentat\u0103 aici:</p> <p>No\u021biunea de graf</p> <p>Un graf \\(G = (V, E)\\) este o structur\u0103 matematic\u0103 compus\u0103 din dou\u0103 mul\u021bimi:</p> <ul> <li> <p>\\(V\\) (mul\u021bimea v\u00e2rfurilor sau nodurilor), care reprezint\u0103 obiectele;</p> </li> <li> <p>\\(E \\subseteq V \\times V\\) (mul\u021bimea muchiilor sau arcelor), care   reprezint\u0103 leg\u0103turile \u00eentre perechi de v\u00e2rfuri.</p> </li> </ul> <p>Fiecare element $ v \\in V$ este numit v\u00e2rf (sau nod), iar fiecare element $ e = (u, v) \\in E$ este numit muchie (sau arc). \u00cen mod obi\u0219nuit, grafurile sunt reprezentate grafic printr-un set de puncte (corespunz\u0103toare v\u00e2rfurilor) conectate prin linii sau curbe (corespunz\u0103toare muchiilor).</p> <p>Voi continua prin a defini termeni ce se dovedesc a fi esen\u021biali pentru \u00een\u021belegerea grafurilor.</p> <p>Graf orientat \u0219i neorientat</p> <p>Un graf neorientat \\(G = (V, E)\\) este un graf \u00een care perechile de v\u00e2rfuri \\((u, v) \\in E\\) sunt neordonate. Aceasta \u00eenseamn\u0103 c\u0103, dac\u0103 \\((u, v) \\in E\\) este o muchie de la \\(u\\) la \\(v\\), atunci \u0219i \\((v, u) \\in E\\).</p> <p>Prin compara\u021bie, un graf orientat este un graf \u00een care perechile de v\u00e2rfuri \\((u, v) \\in E\\) sunt ordonate. Aceasta \u00eenseamn\u0103 c\u0103, dac\u0103 \\((u, v) \\in E\\), atunci \\((v, u) \\not\\in E\\).</p> <p>Noduri adiacente</p> <p>Dou\u0103 noduri \\(u\\) \u0219i \\(v\\) sunt adiacente \u00een graful \\(G = (V, E)\\) dac\u0103 exist\u0103 o muchie $ (u, v) \\in E $. Adic\u0103, exist\u0103 o leg\u0103tur\u0103 direct\u0103 \u00eentre \\(u\\) \u0219i \\(v\\).</p> <p>Formal: $$ u \\text{ \u0219i } v \\text{ sunt adiacente} \\iff (u, v) \\in E \\text{ sau } (v, u) \\in E \\text{ (\u00een cazul grafurilor neorientate)} $$</p> <p>Inciden\u021b\u0103</p> <p>Folosim no\u021biunea de inciden\u021b\u0103 pentru a descrie rela\u021bia dintre noduri \u0219i muchii. O muchie \\((u, v) \\in E\\) este incident\u0103 cu nodurile \\(u\\) \u0219i \\(v\\).</p> <p>Gradul unui nod</p> <p>Definim gradul unui nod \\(v\\) dintr-un graf \\(G = (V, E)\\) ca fiind num\u0103rul de muchii incidente cu \\(v\\).</p> <p>\u00centr-un graf neorientat, gradul nodului \\(v\\), notat \\(\\deg(v)\\), este num\u0103rul de muchii care au \\(v\\) ca una dintre extremit\u0103\u021bi.</p> \\[\\deg(v) = |\\{(u, v) \\in E \\text{ sau } (v, u) \\in E \\mid u \\in V\\}|\\] <p>\u00centr-un graf orientat, se pot defini dou\u0103 tipuri de grad: - Gradul intern (num\u0103rul de muchii care intr\u0103 \u00een nodul \\(v\\)), notat \\(\\deg^-(v)\\):    $$    \\deg^-(v) = |{(u, v) \\in E \\mid u \\in V}|    $$ - Gradul extern (num\u0103rul de muchii care ies din nodul \\(v\\)), notat \\(\\deg^+(v)\\):    $$    \\deg^+(v) = |{(v, u) \\in E \\mid u \\in V}|    $$</p> <p>Observa\u021bie</p> <p>\u00centr-un graf neorientat \\(G = (V, E)\\):</p> \\[ \\sum_{v \\in V} \\deg(v) = 2k,\\,k \\in \\mathbb{N} \\] <p>Explica\u021bia este dat\u0103 de faptul c\u0103 pentru fiecare muchie ad\u0103ugat\u0103, gradul a dou\u0103 noduri cre\u0219te cu \\(1\\).</p> <p>Lan\u021b</p> <p>Numim lan\u021b o secven\u021b\u0103 de noduri \\((v_1, v_2, ..., v_k)\\) cu proprietatea c\u0103 \\((v_i, v_{i + 1}) \\in E\\) oricare ar fi \\(1 \\leq i \\leq k\\). Un lan\u021b este elementar dac\u0103 \\(v_i \\neq v_j\\) oricare ar fi \\(1 \\leq i &lt; j \\leq k\\). Un lan\u021b este simplu dac\u0103 \\((v_i, v_{i + 1}) \\neq (v_j, v_{j+1})\\) oricare ar fi \\(1 \\leq i &lt; j \\leq k\\).</p> <p>Altfel spus, un lan\u021b elementar este un lan\u021b cu nodurile distincte, iar un lan\u021b simplu este un lan\u021b cu muchii distincte.</p> <p>Ciclu</p> <p>O secven\u021b\u0103 de muchii \\((v_1, v_2, ..., v_k, v_1)\\) formeaz\u0103 un ciclu dac\u0103 \\((v_i, v_{i + 1}) \\in E\\) pentru orice \\(1 \\leq i &lt; k\\) \u0219i \\((v_k, v_1) \\in E\\). Un ciclu este simplu dac\u0103 \\(v_i \\neq v_j\\) pentru orice \\(1 \\leq i &lt; j &lt; k\\).</p> <p>Altfel spus, un ciclu reprezint\u0103 o secven\u021b\u0103 de muchii ce nu se repet\u0103, pleac\u0103 de la un nod \\(v_1\\) \u0219i parcurg\u00e2nd \u00een ordine acele muchii, se ajunge tot la nodul \\(v_1\\). Un ciclu simplu este un ciclu \u00een care nu se repet\u0103 noduri.</p> <p>Lungimea unui lan\u021b</p> <p>Lungimea unui lan\u021b \\((v_1, v_2, ..., v_k)\\) este \\(k-1\\) (num\u0103rul de muchii). Uneori, aceasta se define\u0219te ca fiind num\u0103rul de noduri, a\u0219adar lungimea acestui lan\u021b este \\(k\\).</p> <p>Graf par\u021bial \u0219i subgraf</p> <p>Definim graf par\u021bial al unui graf dat ca fiind ceea ce r\u0103m\u00e2ne din graful dat p\u0103str\u00e2nd toate nodurile \u0219i elimin\u00e2nd eventual unele muchii, f\u0103r\u0103 a ad\u0103uga muchii noi.</p> <p>Formal spus, un graf par\u021bial \\(G' = (V, E')\\) a grafului \\(G = (V, E)\\) este un graf unde \\(E' \\subseteq E\\).</p> <p>Definim subgraf al unui graf dat ca fiind ceea ce r\u0103m\u00e2ne din graful dat elimin\u00e2nd unele noduri \u0219i doar muchiile incidente lor, deci nu \u0219i alte muchii \u0219i f\u0103r\u0103 s\u0103 ad\u0103ug\u0103m alte muchii.</p> <p>Formal spus, un subgraf \\(G' = (V', E')\\) al unui graf \\(G = (V, E)\\) este un graf unde \\(V' \\subseteq V\\) \u0219i \\(E' \\subseteq \\{(u, v) \\in E \\mid u, v \\in V'\\}\\).</p> <p>Observa\u021bie</p> <p>Num\u0103rul de subgrafuri ale unui graf \\(G = (V, E)\\) este \\(2^{|V|}\\), iar num\u0103rul de grafuri par\u021biale este \\(2^{|E|}\\), unde \\(|V| = n\\) este num\u0103rul de noduri, iar \\(|E| = m\\) este num\u0103rul de muchii al grafului.</p>"},{"location":"usor/graphs/#cateva-tipuri-speciale-de-grafuri","title":"C\u00e2teva tipuri speciale de grafuri","text":"<p>Se remarc\u0103 faptul c\u0103 \u00een func\u021bie de tipul grafului, mai putem defini urm\u0103toarele tipuri de grafuri, care se vor folosi \u00een diferite aplica\u021bii. De notat ca pentru unele din aceste tipuri, vom avea probleme unde vom explica \u00een detaliu no\u021biunile \u0219i aplica\u021biile unde folosim aceste concepte.</p> <p>Graf complet \\(K_n\\)</p> <p>Definim un graf complet \\(K_n = (V, E)\\) cu \\(|V| = n\\) ca fiind un graf unde \\((v_i, v_j) \\in E\\ \\forall 1 \\leq i &lt; j \\leq n\\). Altfel spus, fiecare nod este conectat cu toate celelalte noduri.</p> <p>Num\u0103rul de muchii ale unui graf complet \\(K_n\\) este \\(|E| = \\frac{n(n-1)}{2}\\).</p> <p>Graf bipartit</p> <p>Definim un graf bipartit \\(G = (A, B, E)\\) ca fiind un graf care poate fi \u00eemp\u0103r\u021bit \u00een dou\u0103 submul\u021bimi \\(V = A \\cup B\\) cu \\(A \\cap B = \\emptyset\\), astfel \u00eenc\u00e2t, dac\u0103 \\(a \\in A\\), atunci acesta se poate conecta doar cu \\(b \\in B\\) \u0219i viceversa.</p> <p>Observa\u021bie</p> <p>Are loc urm\u0103toarea rela\u021bie pentru un graf bipartit \\(G = (A, B, E)\\): $$ \\sum_{a \\in a} \\deg(a) = \\sum_{b \\in B} \\deg(b) = |E| $$</p> <p>Observa\u021bie</p> <p>Un graf este bipartit dac\u0103 \u0219i numai dac\u0103 acesta nu con\u021bine un ciclu de lungime impar\u0103.</p> <p>Graf planar</p> <p>Definim un graf planar ca fiind un graf care are proprietatea c\u0103 poate fi reprezentat grafic f\u0103r\u0103 ca dou\u0103 muchii s\u0103 se intersecteze.</p> <p>Graf regulat</p> <p>Un graf regulat \\(G = (V, E)\\) este un graf \u00een care \\(\\deg(v) = k\\ \\forall v \\in V\\). Adic\u0103, fiecare nod din graf are acela\u0219i num\u0103r de muchii incidente.</p> <p>Un graf regulat cu nodurile de gradul \\(k\\) se nume\u0219te graf \\(k\\)-regulat.</p> <p>Observa\u021bie</p> <p>Condi\u021bia necesar\u0103 \u0219i suficient\u0103 pentru ca un graf \\(k\\)-regulat de ordin \\(n\\) s\u0103 existe este ca \\(n \\geq k + 1\\) \u0219i c\u0103 \\(nk\\) este par.</p> <p>Num\u0103rul de muchii este maxim \u00eentr-un graf complet \\(K_n\\), acesta fiind \\(\\frac{n(n - 1)}{2}\\) cu fiecare nod de gradul \\(n - 1\\). A\u0219adar, \\(k = n - 1\\), sau \\(n = k + 1\\) este \\(n\\) minim pentru un \\(k\\) anume. De asemenea, dup\u0103 rela\u021bia de mai sus, avem \\(\\frac{nk}{2}\\) muchii, deci \\(nk\\) trebuie s\u0103 fie par.</p>"},{"location":"usor/graphs/#lucrul-cu-grafuri-moduri-de-reprezentare-in-memorie","title":"Lucrul cu grafuri. Moduri de reprezentare \u00een memorie","text":"<p>Un concept foarte important \u00een teoria grafurilor reprezint\u0103 modul \u00een care parcurgem aceste structuri de date \u0219i cum putem verifica propriet\u0103\u021bile de care avem nevoie, de la o problem\u0103 la alta.</p> <p>S\u0103 consider\u0103m graful neorientat din figura urm\u0103toare:</p> <p>Acest graf are \\(13\\) noduri \u0219i \\(12\\) muchii, acestea fiind \\((1, 4)\\), \\((1, 3)\\), \\((4, 9)\\), \\((9, 3)\\), \\((4, 2)\\), \\((4, 6)\\), \\((2, 6)\\), \\((2, 5)\\), \\((8, 12)\\), \\((8, 11)\\), \\((8, 10)\\), \\((8, 7)\\).</p> <p>Pentru a reprezenta un graf \u00een memorie, exist\u0103 trei moduri principale de a o face, cu distinc\u021bia c\u0103 \u00een practic\u0103 se va folosi doar reprezentarea prin liste de vecini.</p> <p>Defini\u021bie: Definim matricea de adiacen\u021b\u0103 a unui graf ca fiind o matrice binar\u0103 pentru care \\(a_{ij} = 1\\) dac\u0103 \u0219i numai dac\u0103 avem muchie de la nodul \\(i\\) la nodul \\(j\\) \u0219i \\(a_{ij} = 0\\) \u00een caz contrar.</p> <p>Observa\u021bie: Pentru un graf neorientat, matricea este mereu simetric\u0103, adic\u0103 \\(a_{ij} = a_{ji}\\ \\forall i, j\\).</p> <p>Pentru graful nostru de mai sus, aceasta este matricea de adiacen\u021b\u0103 la care ajungem.</p> <p>List\u0103 de vecini</p> <p>Definim o list\u0103 de vecini ca fiind o list\u0103 (de regul\u0103, alocat\u0103 dinamic) pe care o folosim pentru a \u021bine \u00een memorie pentru fiecare nod doar nodurile adiacente cu acesta, aceast\u0103 metod\u0103 fiind cea mai eficient\u0103 din punct de vedere practic pentru a parcurge grafurile.</p> <p>Exemplu</p> <p>Pentru graful de mai sus, aceasta este lista de vecini:</p> Nod Vecini 1 \\(\\{3,4\\}\\) 2 \\(\\{4,5,6\\}\\) 3 \\(\\{1,9\\}\\) 4 \\(\\{1,2,9\\}\\) 5 \\(\\{2\\}\\) 6 \\(\\{2, 4\\}\\) 7 \\(\\{8\\}\\) 8 \\(\\{7,10,11,12\\}\\) 9 \\(\\{3,4\\}\\) 10 \\(\\{8\\}\\) 11 \\(\\{8\\}\\) 12 \\(\\{8\\}\\) 13 \\(\\emptyset\\) <p>List\u0103 de muchii</p> <p>Definim o list\u0103 de muchii ca fiind o list\u0103 pe care o folosim pentru a \u021bine toate muchiile \u00een memorie. De\u0219i nu este o variant\u0103 prea practic\u0103 de a efectua parcurgerile, aceast\u0103 metod\u0103 poate fi util\u0103 pentru anumi\u021bi algoritmi ce se bazeaz\u0103 \u00een principal pe prelucrarea muchiilor, un astfel de exemplu fiind arborele par\u021bial de cost minim.</p> <p>Exemplu</p> <p>\u00cen cazul nostru, lista de muchii este: \\(\\{1, 4\\}\\),\\(\\{1, 3\\}\\), \\(\\{4,9\\}\\),\\(\\{9,3\\}\\),\\(\\{4,2\\}\\),\\(\\{4,6\\}\\),\\(\\{2,6\\}\\),\\(\\{2,5\\}\\),\\(\\{8,12\\}\\),\\(\\{8,11\\}\\),\\(\\{8,10\\}\\),\\(\\{8,7\\}\\).</p>"},{"location":"usor/graphs/#conexitate-parcurgerea-dfs","title":"Conexitate. Parcurgerea DFS","text":"<p>Problema afl\u0103rii conexit\u0103\u021bii unui graf este una din problemele fundamentale ale teoriei grafurilor, fiind adesea folosit\u0103 drept un exemplu esen\u021bial \u00een explicarea \u0219i \u00een\u021belegerea grafurilor.</p> <p>Graf conex</p> <p>Un graf conex este un graf neorientat \u00een care exist\u0103 o cale \u00eentre oricare dou\u0103 noduri. Cu alte cuvinte, oricare dou\u0103 noduri din graf sunt conectate direct sau indirect printr-o serie de muchii.</p> <p>Componenta conex\u0103</p> <p>O component\u0103 conex\u0103 a unui graf este un subgraf conex maximal, adic\u0103 un subgraf \u00een care oricare dou\u0103 noduri sunt conectate printr-o serie de muchii, iar acest subgraf nu poate fi extins ad\u0103ug\u00e2nd vreun alt nod sau vreo alt\u0103 muchie f\u0103r\u0103 a pierde proprietatea de conexitate.</p> <p>Pentru a rezolva problema afl\u0103rii conexit\u0103\u021bii unui graf, va trebui s\u0103 parcurgem graful folosind unul din algoritmii consacra\u021bi pentru aceast\u0103 problem\u0103. \u00cen cazul de fa\u021b\u0103, vom continua prin a explica parcurgerea \u00een ad\u00e2ncime a grafului (DFS sau depth-first search), una din parcurgerile optime pentru aceast\u0103 problem\u0103.</p> <p>Parcurgerea \u00een ad\u00e2ncime (DFS)</p> <p>Parcurgerea \u00een ad\u00e2ncime (DFS) este un algoritm de explorare a grafului care \u00eencepe de la un nod ales \u0219i viziteaz\u0103 c\u00e2t mai mult posibil din vecinii acestuia \u00eenainte de a se \u00eentoarce \u00eenapoi. Aceasta se realizeaz\u0103 printr-o strategie de backtracking recursiv\u0103 sau prin utilizarea unei stive (stack).</p> <p>DFS \u00eencepe de la un nod \u0219i viziteaz\u0103 toate nodurile pe care le poate atinge \u00een ad\u00e2ncime \u00eenainte de a reveni la nodurile anterioare \u0219i verific\u0103 dac\u0103 un nod a fost deja vizitat pentru a evita bucle infinite.</p> <p>Observa\u021bie</p> <p>Complexitatea parcurgerii \u00een ad\u00e2ncime (DFS) este \\(O(\\lvert V \\rvert + \\lvert E \\lvert)\\), unde \\(\\lvert V \\rvert\\) reprezint\u0103 num\u0103rul de noduri sau v\u00e2rfuri \u0219i \\(\\lvert E \\rvert\\) reprezint\u0103 num\u0103rul de muchii.</p> <p>Observa\u021bie</p> <p>\u00cen probleme se noteaz\u0103 conven\u021bional \\(\\lvert V \\rvert\\) cu \\(N\\) de la noduri, respectiv \\(\\lvert E \\rvert\\) cu \\(M\\) de la muchii. n.red.</p> <p>Observa\u021bie</p> <p>Se remarc\u0103 faptul c\u0103 un nod va fi vizitat la un moment dat doar o singur\u0103 dat\u0103, deci dac\u0103 avem muchiile \\((1, 2)\\), \\((1, 3)\\) \u0219i \\((2, 3)\\), iar DFS-ul pleac\u0103 din \\(1\\), \\(2\\) va fi accesat din \\(1\\), iar \\(3\\) va fi accesat din \\(2\\).</p> <p>Observa\u021bie</p> <p>Se poate remarca faptul c\u0103 ordinea \u00een care vizit\u0103m nodurile \u00een graf depinde de ordinea \u00een care sunt ad\u0103ugate muchiile \u00een graf, acest lucru \u00eenseamn\u0103 c\u0103 nu putem folosi DFS pentru anumite probleme, de exemplu cele la care trebuie aflat\u0103 distan\u021ba minim\u0103 \u00een graf.</p> <p>Ca o recapitulare (sau de fapt compara\u021bie) \u00eentre BFS \u0219i DFS, s\u0103 compar\u0103m fiecare abordare \u00eempreun\u0103 cu o func\u021bie:</p> DFSBFS <pre><code>vector&lt;vector&lt;int&gt;&gt; graph;\n\nvoid dfs(int node, vector&lt;bool&gt;&amp; visited) {\n    visited[node] = true;\n\n    // Ca exemplu\n    cout &lt;&lt; node &lt;&lt; ' '; \n\n    for (int neighbor : graph[node]) {\n        if (!visited[neighbor]) {\n            dfs(neighbor, visited);\n        }\n    }\n}\n</code></pre> <pre><code>vector&lt;vector&lt;int&gt;&gt; graph;\nvector&lt;int&gt; dist; \nqueue&lt;int&gt; q; \n\nvoid bfs(int startNode) {\n    q.push(startNode);\n    dist[startNode] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (auto neighbor : graph[node]) {\n            if (dist[neighbor] == -1) { \n                dist[neighbor] = dist[node] + 1; \n                q.push(neighbor); \n            }\n        }\n    }\n}\n</code></pre>"},{"location":"usor/graphs/#problema-connected-components-de-pe-kilonova","title":"Problema Connected components de pe kilonova","text":"<p>Se d\u0103 un graf neorientat \\(G\\) cu \\(N\\) noduri \u0219i \\(M\\) muchii. S\u0103 se afle c\u00e2te componente conexe are graful dat.</p> <p>Pentru a afla num\u0103rul de componente conexe ale unui graf, putem folosi parcurgerea DFS pentru a afla toate nodurile din care apel\u0103m DFS din func\u021bia <code>main</code>, acesta fiind \u0219i r\u0103spunsul la problema noastr\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nvector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;bool&gt; visited;\n\nvoid dfs(int node) {\n    visited[node] = true;\n\n    for (int next : adj[node]) {\n        if (!visited[next]) {\n            dfs(next);\n        }\n    }\n}\n\nint main() {\n    int n, m;\n    cin &gt;&gt; n &gt;&gt; m;\n\n    adj.resize(n + 1);\n    visited.resize(n + 1, false);\n\n    for (int i = 0; i &lt; m; ++i) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    int cc = 0;\n    for (int i = 1; i &lt;= n; ++i) {\n        if (!visited[i]) {\n            ++cc;\n            dfs(i);\n        }\n    }\n\n    cout &lt;&lt; cc &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>"},{"location":"usor/graphs/#drumuri-minime-parcurgerea-bfs","title":"Drumuri minime. Parcurgerea BFS","text":"<p>Dac\u0103 \u00een cazul parcurgerii DFS putem s\u0103 o aplic\u0103m f\u0103r\u0103 mari probleme pentru o varietate destul de larg\u0103 de probleme cu grafuri, totu\u0219i nu este suficient\u0103 pentru problemele ce \u021bin de distan\u021be. Un exemplu fundamental este acela al afl\u0103rii drumului minim \u00eentre dou\u0103 sau mai multe noduri \u00eentr-un graf dat.</p> <p>Drum minim</p> <p>Un drum minim este lungimea minim\u0103 a unui lan\u021b care leag\u0103 dou\u0103 noduri din graf.</p> <p>Motivul pentru care nu putem afla drumul minim \u00eentre dou\u0103 noduri folosind DFS este acela c\u0103 ordinea \u00een care nodurile sunt parcurse \u00een DFS depinde de ordinea \u00een care sunt date muchiile de la intrare, parcurgerea recursiv\u0103 f\u0103c\u00e2nd aflarea distan\u021belor minime imposibil\u0103. Astfel, vom introduce un alt mod de a parcurge graful nostru.</p> <p>Parcurgerea \u00een l\u0103\u021bime (BFS)</p> <p>Parcurgerea \u00een l\u0103\u021bime** (BFS, engl. breadth-first search) a unui graf ca fiind o parcurgere iterativ\u0103 ce pleac\u0103 de la unul sau mai multe noduri, iar la fiecare pas, dac\u0103 ne afl\u0103m la un nod \\(x\\), vom vizita vecinii nevizita\u021bi ai nodului \\(x\\), ad\u0103ug\u00e2ndu-i \u00eentr-o coad\u0103, nodurile fiind parcurse \u00een ordinea \u00een care au fost ad\u0103ugate \u00een coad\u0103.</p> <p>Observa\u021bie</p> <p>Complexitatea parcurgerii \u00een l\u0103\u021bime (BFS) este \\(O(\\lvert V \\rvert + \\lvert E \\lvert)\\), unde \\(\\lvert V \\rvert\\) reprezint\u0103 num\u0103rul de noduri sau v\u00e2rfuri \u0219i \\(\\lvert E \\rvert\\) reprezint\u0103 num\u0103rul de muchii.</p> <p>Observa\u021bie</p> <p>Se poate remarca faptul c\u0103 ordinea \u00een care vizit\u0103m nodurile \u00een graf va fi aceea\u0219i cu ordinea cresc\u0103toare a distan\u021bei minime fa\u021b\u0103 de nodul sau nodurile ini\u021biale, datorit\u0103 faptului c\u0103 ele vor fi inserate \u00een coad\u0103 \u00een ordinea \u00een care acestea au fost ad\u0103ugate.</p>"},{"location":"usor/graphs/#problema-simple-shortest-path-de-pe-kilonova","title":"Problema Simple Shortest Path de pe kilonova","text":"<p>Se d\u0103 un graf neorientat \\(G\\) cu \\(N\\) noduri \u0219i \\(M\\) muchii, precum \u0219i un nod \\(S\\). S\u0103 se afle lungimea drumului minim dintre \\(S\\) \u0219i fiecare nod din graf, inclusiv \\(S\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, vom pleca cu un BFS din nodul \\(S\\) \u0219i vom afla pe parcurs, distan\u021bele minime fa\u021b\u0103 de toate celelalte noduri.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nint main() {\n    int n, m, s;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n\n    vector&lt;vector&lt;int&gt;&gt; graf(n);\n    vector&lt;int&gt; ans(n, -1);\n    queue&lt;int&gt; q;\n\n    for (int i = 0; i &lt; m; i++) {\n        int a, b;\n        cin &gt;&gt; a &gt;&gt; b;\n        graf[a].push_back(b);\n        graf[b].push_back(a);\n    }\n\n    ans[s] = 0;\n    q.push(s);\n\n    while (!q.empty()) {\n        int nod = q.front();\n        q.pop();\n\n        for (auto x : graf[nod]) {\n            if (ans[x] == -1) {\n                ans[x] = ans[nod] + 1;\n                q.push(x);\n            }\n        }\n    }\n\n    for (const auto&amp; x : ans) {\n        cout &lt;&lt; x &lt;&lt; \" \";\n    }\n\n    cout &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>"},{"location":"usor/graphs/#problema-grarb-de-pe-infoarena","title":"Problema grarb de pe infoarena","text":"<p>Se d\u0103 un graf \\(G\\) neorientat cu \\(N\\) noduri numerotate de la \\(1\\) la \\(N\\) \u0219i \\(M\\) muchii. Determina\u021bi num\u0103rul minim de muchii care trebuie eliminate \u0219i num\u0103rul minim de muchii care trebuie ad\u0103ugate \u00een graful \\(G\\) astfel \u00eenc\u00e2t acesta sa devina arbore.</p> <p>Aceast\u0103 problem\u0103 se \u00eemparte \u00een dou\u0103 subprobleme relativ u\u0219or de identificat - aflarea componentelor conexe ale grafului (dac\u0103 avem \\(nr\\) componente conexe, va fi nevoie de \\(nr - 1\\) muchii pentru a transforma graful \u00eentr-unul conex), precum \u0219i aflarea num\u0103rului de muchii care trebuie scoase pentru a transforma graful \u00een arbore (la final, trebuie s\u0103 ne r\u0103m\u00e2n\u0103 \\(N-1\\) muchii). Astfel, vom avea nevoie de \\(nr - 1\\) muchii noi \u0219i va trebui s\u0103 scoatem \\(M + nr - 1 - (N - 1)\\) = \\(M + nr - N\\) muchii pentru a avea un arbore.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\n\nvector&lt;vector&lt;int&gt;&gt; adj;\nvector&lt;bool&gt; visited;\n\nvoid dfs(int nod) {\n    visited[nod] = true;\n    for (int next : adj[nod]) {\n        if (!visited[next]) dfs(next);\n    }\n}\n\nint main() {\n    ifstream fin(\"grarb.in\");\n    ofstream fout(\"grarb.out\");\n\n    int n, m, nr = 0;\n\n    fin &gt;&gt; n &gt;&gt; m;\n\n    adj.resize(n);\n    visited.resize(n, false);\n\n    for (int i = 1; i &lt;= m; i++) {\n        int a, b;\n        fin &gt;&gt; a &gt;&gt; b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    for (int i = 0; i &lt; n; i++)\n        if (!visited[i]) {\n            dfs(i);\n            nr++;\n        }\n\n    // Num\u0103rul de muchii ce trebuiesc \u0219terse\n    fout &lt;&lt; m + nr - 1 - (n - 1) &lt;&lt; '\\n';\n    // Num\u0103rul de componente conectate\n    fout &lt;&lt; nr - 1 &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>"},{"location":"usor/graphs/#problema-graf-oji-2006-de-pe-kilonova","title":"Problema Graf (OJI 2006) de pe kilonova","text":"<p>Se d\u0103 un graf neorientat conex cu \\(N\\) noduri \u0219i dou\u0103 noduri \\(X\\) \u0219i \\(Y\\), s\u0103 se afle nodurile ce apar\u021bin tuturor lan\u021burilor optime \u00eentre \\(X\\) \u0219i \\(Y\\).</p> <p>Pentru a rezolva aceast\u0103 problem\u0103, va trebui mai \u00eent\u00e2i s\u0103 afl\u0103m folosind o parcurgere de tip BFS distan\u021bele minime de la \\(X\\) \u0219i \\(Y\\) spre toate celelalte noduri. Apoi, pentru fiecare distan\u021b\u0103 \\(d\\) de la \\(0\\) la \\(\\operatorname{dist}(X, Y)\\), vrem s\u0103 afl\u0103m c\u00e2te noduri se afl\u0103 pe unul din drumurile optime de la \\(X\\) la \\(Y\\) la o distan\u021b\u0103 \\(d\\) fa\u021b\u0103 de \\(X\\). \u00cen cele din urm\u0103, vrem s\u0103 afi\u0219\u0103m nodurile situate la distan\u021bele care apar o singur\u0103 dat\u0103 \u00een mul\u021bimea nodurilor ce fac parte din cel pu\u021bin un drum optim de la \\(X\\) la \\(Y\\).</p> <p>Codul surs\u0103 se poate viziona mai jos.</p> <pre><code>#include &lt;fstream&gt;\n#include &lt;queue&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nconstexpr int MAXN = 7500;\n\nvector&lt;vector&lt;int&gt;&gt; graph(MAXN + 1);\nvector&lt;int&gt; ans;\n\nvoid bfs(int startNode, vector&lt;int&gt;&amp; dist) {\n    queue&lt;int&gt; q;\n    q.push(startNode);\n    dist[startNode] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n\n        for (auto neighbor : graph[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\nvector&lt;int&gt; distX, distY, solFreq;\n\nint main() {\n    distX.reserve(MAXN + 1);\n    distY.reserve(MAXN + 1);\n    solFreq.reserve(MAXN + 1);\n\n    ifstream fin(\"graf.in\");\n    ofstream fout(\"graf.out\");\n\n    int n, m, x, y;\n    fin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;\n\n    while (m--) {\n        int a, b;\n        fin &gt;&gt; a &gt;&gt; b;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n    }\n\n    distX.resize(n + 1, -1);\n    distY.resize(n + 1, -1);\n    solFreq.resize(n + 1, 0);\n\n    bfs(x, distX);\n    bfs(y, distY);\n\n    int totalDist = distX[y];\n\n    // Lungimea total\u0103 a drumului va fi egal\u0103 cu distX[y].\n    for (int i = 1; i &lt;= n; i++) {\n        if (distX[i] == -1 || distY[i] == -1) {\n            continue;\n        }\n\n        if (distX[i] + distY[i] == totalDist + 1) {\n            solFreq[distX[i]]++;\n        }\n    }\n\n    for (int i = 1; i &lt;= n; i++) {\n        if (distX[i] == -1 || distY[i] == -1) {\n            continue;\n        }\n\n        if (distX[i] + distY[i] == totalDist + 1 &amp;&amp; solFreq[distX[i]] == 1) {\n            ans.push_back(i);\n        }\n    }\n\n    fout &lt;&lt; ans.size() &lt;&lt; '\\n';\n    for (const auto&amp; node : ans) {\n        fout &lt;&lt; node &lt;&lt; ' ';\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"usor/graphs/#probleme-si-lectura-suplimentara","title":"Probleme \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Aici mai trebuie puse probleme</li> <li>Probleme cu grafuri de pe kilonova</li> <li>Grafuri - no\u021biuni teoretice de baz\u0103</li> <li>Articol introductiv de pe USACO Guide</li> <li>Articol despre parcurgeri de pe USACO Guide</li> <li>Probleme cu grafuri de pe codeforces, ordonate dup\u0103 dificultate</li> </ul>"},{"location":"usor/intro-dp/","title":"Intro dp","text":"<p>Autor: Teodor \u0218tefan Manolea</p> <p>Dac\u0103 citi\u021bi acest document \u00eenseamn\u0103 c\u0103 v\u0103 intereseaz\u0103 s\u0103 afla\u021bi informa\u021bii introductive despre programarea dinamic\u0103.</p>"},{"location":"usor/intro-dp/#introducere","title":"Introducere","text":"<p>Ca s\u0103 \u00eencepem lec\u021bia v\u0103 voi adresa urm\u0103toarea \u00eentrebare: \u201eCe \u00eenseamn\u0103 programarea dinamic\u0103?\u201d</p> <p>Ei bine, ne vom folosi de o analogie ca s\u0103 ne fie mai u\u0219or s\u0103 \u00een\u021belegem:</p> <p>Haide s\u0103 plec\u0103m de la un sistem de referin\u021b\u0103 ideal, s\u0103 zicem c\u0103 avem o ma\u0219in\u0103 Dacia Solenza. Ei bine, c\u00e2nd ne g\u00e2ndim la ea, care ne sunt primele propriet\u0103\u021bi, pe care le are \u00een comun cu orice alt\u0103 ma\u0219in\u0103, care ne vin \u00een cap? P\u0103i, o ma\u0219in\u0103 are un motor, hai s\u0103 zicem c\u0103 ma\u0219ina noastr\u0103 are 200 cai putere. Ce mai are o ma\u0219in\u0103? O greutate, s\u0103 zicem c\u0103 ma\u0219ina noastr\u0103 are 2 tone. Ei bine, aceste propriet\u0103\u021bi, noi o s\u0103 le numim parametri. Acum, ace\u0219ti parametrii, grupa\u021bi \u00eempreun\u0103, formeaz\u0103 o stare, parametrii purt\u00e2nd numele de \u201eParametrii de stare\u201d. Acum hai s\u0103 presupunem c\u0103-i schimb\u0103m motorul ma\u0219inii \u00eentr-unul de la Ferrari, care s\u0103 zicem c\u0103 are 150 cai putere, aceast\u0103 schimbare o putem numi o tranzi\u021bie, a\u0219a cum o s\u0103-i \u0219i spunem de acum \u00eencolo.</p> <p>Aceste st\u0103rii \u0219i tranzi\u021bii stau la baza g\u00e2ndirii dinamice, care reprezint\u0103 defapt programarea dinamic\u0103. Acum c\u0103 avem o analogie de baz\u0103, putem s\u0103 ajungem la o \u201eformula\u201d de baz\u0103 a program\u0103rii dinamice. Ea se va enun\u021ba astfel:</p> Exemplu de tranzi\u021bie <p>Traducerea este urm\u0103toarea:</p> <ul> <li> <p>\"S1\" = Starea 1 (reprezint\u0103 valorile st\u0103rii ini\u021biale)</p> </li> <li> <p>\"\u2192\" = Tranzi\u021bia (reprezint\u0103 func\u021bia care va aplica ni\u0219te instruc\u021biuni bazate   pe valorile parametrilor din S1 \u0219i va transmite rezultatul \u00een S2)</p> </li> <li> <p>\"S2\" = Starea 2 (reprezint\u0103 valorile st\u0103rii finale, care rezult\u0103 din tranzi\u021bie)</p> </li> </ul> <p>Din aceast\u0103 formula putem ajunge la concluzia c\u0103, b\u0103be\u0219te spun\u00e2nd, programarea dinamic\u0103 este \u201eprogramarea pe st\u0103rii\u201d, care are la baz\u0103 un mod de g\u00e2ndire. La programarea dinamic\u0103 i se mai spune \u0219i \u201eDP\u201d, fiind un termen standard vom \u00eencepe s\u0103-l utiliz\u0103m \u0219i noi \u00een documentul prezent!</p>"},{"location":"usor/intro-dp/#clasificare","title":"Clasificare","text":"<p>Av\u00e2nd acum no\u021biunile teoretice de baz\u0103 asupra modului de g\u00e2ndire parcurse, a\u0219 vrea s\u0103 v\u0103 definesc ni\u0219te moduri de clasificare a program\u0103rii dinamice, dup\u0103 modul de a fi scrise, dup\u0103 modul de abordare a lor, dup\u0103 modul \u00een care tranzi\u021bia transmite informa\u021bia de la o stare la alta \u0219i respectiv dup\u0103 ramura tipurilor de probleme a c\u0103rora apar\u021bin ele.</p>"},{"location":"usor/intro-dp/#tipuri-de-scriere","title":"Tipuri de scriere","text":"<ul> <li> <p>Recursiv (Utilizeaz\u0103 recursivitatea standard)</p> </li> <li> <p>Iterativ (Utilizeaz\u0103 complete search)</p> </li> </ul> Pentru un participant la competi\u021bii de informatic\u0103 este esen\u021bial s\u0103 \u0219tie cum se scrie \u00een ambele forme!"},{"location":"usor/intro-dp/#modalitati-de-abordare","title":"Modalit\u0103\u021bi de abordare","text":"<ol> <li> <p>Top-Down DP:</p> <ul> <li> <p>Aceast\u0103 form\u0103 de DP pleac\u0103 de la starea final\u0103 a problemei, ea utiliz\u00e2nd st\u0103rile anterioare, p\u00e2n\u0103 la starea ini\u021bial\u0103 pe care o cunoa\u0219tem, pentru a-\u0219i construi parametrii ei.</p> </li> <li> <p>De obicei aceast\u0103 form\u0103 de DP este scris\u0103 utiliz\u00e2nd recursivitatea</p> </li> </ul> </li> <li> <p>Bottom-Up DP:</p> <ul> <li>Aceast\u0103 form\u0103 de DP pleac\u0103 de la starea ini\u021bial\u0103 a problemei, ea construind parametrii st\u0103rilor urm\u0103toare care la r\u00e2ndul lor vor face asta p\u00e2n\u0103 ce ajungem la construirea parametrilor st\u0103rii finale.</li> <li>De obicei aceast\u0103 form\u0103 de DP este scris\u0103 utiliz\u00e2nd Complete Search-ul</li> </ul> </li> </ol>"},{"location":"usor/intro-dp/#modalitati-de-tranzitie","title":"Modalit\u0103\u021bi de tranzi\u021bie","text":"<ul> <li>Pull-DP: Aceast\u0103 form\u0103 de tranzi\u021bie are la baz\u0103 \u201etragerea\u201d informa\u021biei   necesare pentru formarea parametrilor st\u0103rii curente din starea anterioar\u0103.</li> <li>Push-DP: Aceast\u0103 form\u0103 de tranzi\u021bie are la baz\u0103 \u201e\u00eempingerea\u201d informa\u021biei   necesare pentru formarea st\u0103rii urm\u0103toarea din starea curent\u0103</li> </ul>"},{"location":"usor/intro-dp/#ramuri-ale-dp-ului","title":"Ramuri ale DP-ului","text":"<ul> <li>Counting DP (programare dinamic\u0103 de num\u0103rare)</li> <li>Knapsack DP (programare dinamic\u0103 bazat\u0103 pe problema rucsacului)</li> <li>Bitmasking DP (programare dinamic\u0103 bazat\u0103 pe mascarea bi\u021bilor)</li> <li>Tree DP (programare dinamic\u0103 pentru arbori)</li> </ul>"},{"location":"usor/intro-dp/#probleme-clasice","title":"Probleme clasice","text":"<p>\u00cen continuare, o s\u0103 discut\u0103m despre ni\u0219te probleme clasice \u00een cadrul dp-ului, ele f\u0103c\u00e2nd parte din ramurile de num\u0103rare \u0219i a problemei rucsacului.</p>"},{"location":"usor/intro-dp/#problema-monezii","title":"Problema monezii","text":"<p>Cerin\u021b\u0103</p> <p>Ast\u0103zi, la ora domnului profesor Tetris, \u021bi s-a pus urm\u0103toarea \u00eentrebare: \u201eDac\u0103 eu \u00ee\u021bi dau \\(N\\) tipuri de monede, av\u00e2nd acces la o infinitate de monede \\(C\\) de acele tipuri, afl\u0103 modalitatea optim\u0103 de a ob\u021bine suma \\(S\\)\u201d. Pe momentul orei tu nu ai \u0219tiut cum s\u0103 r\u0103spunzi, \u00cens\u0103 acum, mai determinat ca niciodat\u0103, vrei s\u0103 rezolvi aceast\u0103 problem, av\u00e2nd \u00een fa\u021b\u0103 un document educational de 5 stele Micheline. Rezolv\u0103 problema!</p> <p>Vom defini modalitatea optim\u0103 de a ob\u021bine suma \\(S\\) ca fiind modalitatea prin care utilizezi c\u00e2t mai pu\u021bine monede per total!</p> <p>Restric\u021bii:</p> <ul> <li> <p>$ 1 \\leq N \\leq 500 $</p> </li> <li> <p>$ 1 \\leq S \\leq 100000 $</p> </li> <li> <p>$ 1 \\leq C_i \\leq 2500 $</p> </li> </ul>"},{"location":"usor/intro-dp/#rezolvare","title":"Rezolvare","text":"<p>La \u00eenceput, c\u00e2nd a\u021bi citit aceast\u0103 problem\u0103, probabil v-a\u021bi g\u00e2ndit la o rezolvare Greedy (care mai \u00eencolo o s\u0103 vede\u021bi c\u0103 este Greedy Euristic), prin care a\u021bi fi sortat descresc\u0103tor \u0219irul de monede \u0219i a\u021bi fi \u00eencercat s\u0103 utiliza\u021bi denomina\u021bia cea mai mare, care este mai mic\u0103 ca S, c\u00e2t timp putea\u021bi. Dup\u0103 a\u021bi fi continuat cu urm\u0103toarea denomina\u021bie cea mai mare care respect\u0103 condi\u021bia aceasta pentru suma r\u0103mas\u0103 \u0219.a.m.d. Ca s\u0103 v\u0103 dovedesc c\u0103 nu func\u021bioneaz\u0103 aceast\u0103 modalitate, \u00eencerca\u021bi s\u0103 rezolva\u021bi aceast\u0103 problem\u0103, utiliz\u00e2nd modalitatea anterior prezentat\u0103, av\u00e2nd aceste date de intrare (\\(N\\) num\u0103rul de monezi, apoi \\(S\\) suma \u0219i apoi cele \\(N\\) monezi):</p> <pre><code>3\n31\n7 2 15\n</code></pre> <p>Acum c\u0103 a\u021bi \u00eencercat s\u0103 rezolva\u021bi problema \u00eentr-un mod cunoscut vou\u0103, \u0219i a\u021bi v\u0103zut c\u0103 nu \u00ee\u021bi garanteaz\u0103 un r\u0103spuns, haide\u021bi s\u0103 v\u0103 prezint o solu\u021bie corect\u0103!</p> <p>Pentru aceast\u0103 problem, o s\u0103 v\u0103 prezint solu\u021biile utiliz\u00e2nd ambele modalit\u0103\u021bi de abordare, scriere a sursei \u0219i modalit\u0103\u021bi de tranzi\u021bie.</p> RecursivIterativ <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nconstexpr int MAX_MONEZI = 100000;\n\nusing namespace std;\n\nint N, S;\nvector&lt;int&gt; dp(MAX_MONEZI + 1);\n\nvoid solve(const int suma, const int nr_monede, const vector&lt;int&gt;&amp; monezi) {\n    if (suma == 0) {\n        return;\n    }\n\n    for (const auto moneda : monezi) {\n        if (suma &gt;= moneda) {\n            if (dp[suma - moneda] &gt; nr_monede + 1) {\n                dp[suma - moneda] = nr_monede + 1;\n                solve(suma - moneda, nr_monede + 1, monezi);\n            }\n        }\n    }\n}\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; S;\n\n    vector&lt;int&gt; monezi(N, 0);\n\n    for (auto&amp; moneda : monezi) {\n        cin &gt;&gt; moneda;\n    }\n\n    solve(S, 0, monezi);\n\n    cout &lt;&lt; dp[0];\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\n\nconst int MAXIM_SUMA_MONEZI = 100000;\n\nint N, S;\nint dp[MAXIM_SUMA_MONEZI + 1];\n\nint main() {\n    cin &gt;&gt; N &gt;&gt; S;\n    vector&lt;int&gt; coins(N);\n    for (int i = 0; i &lt; N; i++) {\n        cin &gt;&gt; coins[i];\n    }\n    for (int i : coins) {\n        dp[i] = 1;\n    }\n    for (int i = 1; i &lt; S; i++) {\n        if (dp[i] != 0) {\n            for (int coin : coins) {\n                if (i + coin &lt;= S) {\n                    if (dp[i + coin] == 0) {\n                        dp[i + coin] = dp[i] + 1;\n                    } else {\n                        dp[i + coin] = min(dp[i + coin], dp[i] + 1);\n                    }\n                }\n            }\n        }\n    }\n    cout &lt;&lt; dp[S];\n    return 0;\n}\n</code></pre>"},{"location":"usor/sieve/","title":"Ciurul lui Eratostene \u0219i alte aplica\u021bii","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>"},{"location":"usor/sieve/#cunostinte-necesare","title":"Cuno\u0219tinte necesare","text":"<p>\u00cenaintea citirii acestui articol, se recomand\u0103 citirea articolului despre divizibilitate. De asemenea, pentru unele aplica\u021bii mai avansate, cunoa\u0219terea elementar\u0103 a STL este necesar\u0103.</p>"},{"location":"usor/sieve/#ce-este-ciurul-lui-eratostene","title":"Ce este ciurul lui Eratostene?","text":"<p>Ciurul lui Eratostene este o metod\u0103 eficient\u0103 de afla toate numerele prime \u00eentre \\(1\\) \u0219i \\(n\\), folosindu-ne de propriet\u0103\u021bile corespunz\u0103toare numerelor naturale, precum \u0219i de rela\u021biile dintre divizori \u0219i multipli. Pe l\u00e2ng\u0103 aplica\u021bia sa principal\u0103, se va dovedi a fi un algoritm foarte util pentru foarte multe tipuri de precalcul\u0103ri care sunt centrate \u00een jurul afl\u0103rii divizorilor sau a altor valori ce se calculeaz\u0103 \u00een func\u021bie de divizorii numerelor de la \\(1\\) la \\(n\\).</p> <p>Pentru a afla numerele prime de la \\(1\\) la \\(n\\), vom avea un algoritm simplu, care va lua la r\u00e2nd numerele de la \\(2\\) la \\(n\\) \u0219i pentru fiecare num\u0103r nemarcat de la \\(2\\) la \\(n\\), se vor marca to\u021bi multiplii acestuia. Astfel, numerele nemarcate sunt numerele prime, acestea nefiind marcate anterior de momentul acces\u0103rii lor, iar numerele marcate sunt numerele compuse. Se remarc\u0103 faptul c\u0103 \\(1\\), nefiind num\u0103r prim, nu este luat \u00een considerare.</p> <p>S\u0103 exemplific\u0103m algoritmul pentru numerele de la \\(2\\) la \\(30\\). Voi descrie doar pa\u0219ii ce exemplific\u0103 ce se \u00eent\u00e2mpl\u0103 c\u00e2nd avem de-a face cu numere prime.</p> <ul> <li>La pasul \\(i = 2\\), \\(2\\) este marcat drept num\u0103r prim, iar acesta va marca numerele pare de la \\(4\\) la \\(30\\) drept compuse \\((4, 6, 8, 10, 12, 14, 16, 18, 20\\), \\(22, 24, 26, 28, 30)\\).</li> <li>La pasul \\(i = 3\\), \\(3\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(3\\) de la \\(6\\) la \\(30\\) drept compuse \\((6, 9, 12, 15, 18, 21, 24, 27, 30)\\).</li> <li>La pasul \\(i = 5\\), \\(5\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(5\\) de la \\(10\\) la \\(30\\) drept compuse \\((10, 15, 20, 25, 30)\\).</li> <li>La pasul \\(i = 7\\), \\(7\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(7\\) de la \\(14\\) la \\(30\\) drept compuse \\((14, 21, 28)\\).</li> <li>La pasul \\(i = 11\\), \\(11\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(11\\) de la \\(22\\) la \\(30\\) drept compuse \\((22)\\).</li> <li>La pasul \\(i = 13\\), \\(13\\) este marcat drept num\u0103r prim, iar acesta va marca numerele multiplu de \\(13\\) de la \\(26\\) la \\(30\\) drept compuse \\((26)\\).</li> <li>La pa\u0219ii \\(i = 17\\), \\(i = 23\\), \\(i = 29\\), \\(17\\), \\(23\\) \u0219i \\(29\\) sunt marca\u021bi drept numere prime, dar multiplii lor mai mari ca ei sunt mai mari ca \\(30\\), nemaifiind marca\u021bi drept numere compuse, chiar dac\u0103 sunt, deoarece nu fac parte din scopul rul\u0103rii algoritmului nostru pentru numerele p\u00e2n\u0103 la \\(30\\).</li> </ul> <p></p> <p>Un exemplu de vizualizare pentru numerele de la \\(1\\) la \\(16\\)</p> <p>Algoritmul se dovede\u0219te a fi o optimizare fa\u021b\u0103 de metoda standard de aflare pentru toate numerele de la \\(1\\) la \\(n\\) a primalit\u0103\u021bii, complexitatea devenind \\(O(n \\log \\log n)\\) pentru aflarea primalit\u0103\u021bii pentru toate numerele, respectiv \\(O(n \\log n)\\) pentru majoritatea celorlalte tipuri de prelucr\u0103ri. De asemenea, \u0219i implementarea se dovede\u0219te a fi una foarte scurt\u0103, ciurul put\u00e2nd fi scris \u00een c\u00e2teva r\u00e2nduri. </p> <pre><code>int prim[100001];\nfor (int i = 2; i &lt;= n; i++)\n    if (prim[i] == 0)\n        for (int j = i + i; j &lt;= n; j += i)\n            prim[j] = 1;\n</code></pre> <p>Observa\u021bie</p> <p>E de remarcat c\u0103 numerele prime vor fi cele nemarcate, iar numerele compuse vor fi cele marcate cu \\(1\\).</p>"},{"location":"usor/sieve/#optimizari-ale-implementarii","title":"Optimiz\u0103ri ale implement\u0103rii","text":"<p>De\u0219i algoritmul \u00een sine este deja foarte rapid, \u00een practic\u0103 concuren\u021bii tind s\u0103 aplice diverse optimiz\u0103ri de constant\u0103 inspirate din optimiz\u0103rile ce se pot aplica algoritmului de aflare a divizorilor unui num\u0103r \\(n\\). Printre altele, putem vorbi de \u00eenceperea celui de-al doilea for de la \\(i^2\\) (primul num\u0103r compus care nu a fost marcat anterior va fi mereu \\(i^2\\)) sau de procesarea lui \\(2\\), urmat\u0103 de procesarea numerelor impare din \\(2\\) \u00een \\(2\\).</p> <pre><code>int prim[100001];\nfor (int i = 4; i &lt;= n; i += 2)\n    prim[i] = 1;\nfor (int i = 3; i &lt;= n; i += 2)\n    if (prim[i] == 0)\n        for (int j = i * i; j &lt;= n; j += i * 2)\n            prim[j] = 1;\n</code></pre> <p>Observa\u021bie</p> <p>Trebuie avut grij\u0103 la cel de-al doilea for deoarece expresia int j = i * i; poate cauza overflow dac\u0103 implementarea nu este una corespunz\u0103toare. De aceea, concuren\u021bii pot folosi o optimizare similar\u0103 \u0219i pentru primul for.</p> <pre><code>int prim[100001];\nfor (int i = 4; i &lt;= n; i += 2)\n    prim[i] = 1;\nfor (int i = 3; i * i &lt;= n; i += 2)\n    if (prim[i] == 0)\n        for (int j = i * i; j &lt;= n; j += i * 2)\n            prim[j] = 1;\n\n// afisarea numerelor prime de la 1 la n\nfor (int i = 2; i &lt;= n; i++)\n    if (prim[i] == 0) \n        cout &lt;&lt; i &lt;&lt; \" \";\n</code></pre> <p>Chiar dac\u0103 aceste implement\u0103ri nu \u00eembun\u0103t\u0103\u021besc semnificativ performan\u021ba ciurului lui Eratostene, ele pot fi utile \u00een contextul optimiz\u0103rilor ce ar putea fi folosite la rezolvarea problemelor. </p>"},{"location":"usor/sieve/#alte-aplicatii-ale-ciurului-lui-eratostene","title":"Alte aplica\u021bii ale ciurului lui Eratostene","text":"<p>Dup\u0103 cum am men\u021bionat la \u00eenceputul articolului, ciurul lui Eratostene este un algoritm foarte versatil, put\u00e2nd fi folosit pentru aflarea multor propriet\u0103\u021bi ale numerelor, precum divizorii (primi sau to\u021bi) ai unui num\u0103r, pentru calcule de tipul celor folosite la pinex (link c\u0103tre articol mobius) \u0219i a\u0219a mai departe. C\u00e2teva din implement\u0103rile acestor opera\u021bii vor fi prezentate mai jos, \u00een cadrul problemei educa\u021bionale descris\u0103 \u00een cele ce urmeaz\u0103. </p>"},{"location":"usor/sieve/#problema-ciurul-lui-eratostene-de-pe-kilonova","title":"Problema Ciurul lui Eratostene de pe Kilonova","text":"<p>Se dau \\(q\\) opera\u021bii de forma \\(type \\ value\\). \u00cen func\u021bie de tipul opera\u021biei, va trebui s\u0103 face\u021bi urm\u0103toarele lucruri:</p> <ul> <li>\\(1 \\ value\\): S\u0103 se afi\u0219eze <code>Prime</code> sau <code>Composite</code> dac\u0103 num\u0103rul este prim, respectiv compus.</li> <li>\\(2 \\ value\\): S\u0103 se afi\u0219eze divizorii primi ai lui \\(value\\), \u00een ordine cresc\u0103toare. Dac\u0103 \\(value = 1\\), se va afi\u0219a o linie goal\u0103.</li> <li>\\(3 \\ value\\): S\u0103 se afi\u0219eze divizorii lui \\(value\\), \u00een ordine cresc\u0103toare.</li> </ul> <p>Pentru a rezolva problema (\u0219i \u00een general pentru a rezolva problemele care implic\u0103 folosirea ciurului lui Eratostene), ne vom precalcula toate r\u0103spunsurile folosind varia\u021bii ale ciurului lui Eratostene, una pentru numerele prime \u0219i cealalt\u0103 pentru divizori \u00een general. Pentru a \u021bine \u00een memorie to\u021bi divizorii, vom folosi varianta din STL a vectorilor, deoarece face accesarea datelor mai u\u0219oar\u0103.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt; \n\nusing namespace std;\n\nconst int NMAX = 1000000;\nint q, prime[NMAX + 1];\nvector&lt;vector&lt;int&gt; &gt; divisors, prime_divisors;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    divisors.resize(NMAX + 1);\n    prime_divisors.resize(NMAX + 1);\n\n    for (int i = 1; i &lt;= NMAX; i++)\n        for (int j = i; j &lt;= NMAX; j += i)\n            divisors[j].push_back(i);\n\n    prime[1] = 1;\n    for (int i = 2; i &lt;= NMAX; i++)\n        if (prime[i] == 0)\n            for (int j = i; j &lt;= NMAX; j += i) {\n                prime_divisors[j].push_back(i);\n                if (j != i)\n                    prime[j] = 1;\n            }\n\n    cin &gt;&gt; q;\n\n    for (int i = 1; i &lt;= q; i++) {\n        int type, value;\n        cin &gt;&gt; type &gt;&gt; value;\n        if (type == 1)\n            cout &lt;&lt; (prime[value] == 0 ? \"Prime\" : \"Composite\") &lt;&lt; '\\n';\n        if (type == 2) {\n            for (int j = 0; j &lt; (int) prime_divisors[value].size(); j++)\n                cout &lt;&lt; prime_divisors[value][j] &lt;&lt; \" \";\n            cout &lt;&lt; '\\n';\n        }\n        if(type == 3) {\n            for (int j = 0; j &lt; (int) divisors[value].size(); j++)\n                cout &lt;&lt; divisors[value][j] &lt;&lt; \" \";\n            cout &lt;&lt; '\\n';\n        }\n    }\n    return 0;\n}\n</code></pre>"},{"location":"usor/sieve/#problema-cufar-oji-2018-de-pe-kilonova","title":"Problema Cuf\u0103r - OJI 2018 de pe Kilonova","text":"<p>Vr\u0103jitoarea cea bun\u0103 are un cuf\u0103r \u00een care este \u00eenchis\u0103 piatra magic\u0103 de c\u0103tre piticii l\u0103zii cu ajutorul unui cifru digital. Piticii i-au dat vr\u0103jitoarei o cutie \u00een care sunt \\(n\\) cartona\u0219e. Pe fiecare cartona\u0219 este scris un num\u0103r natural pe care vr\u0103jitoarea \u00eel va folosi s\u0103 deschid\u0103 lada. Valorile scrise pe cartona\u0219e sunt distincte \u00eentre ele.</p> <p>Pentru a afla cifrul trebuie s\u0103 procedeze astfel: extrage fiecare cartona\u0219 din cutie \u0219i apoi determin\u0103 valoarea magic\u0103 asociat\u0103 num\u0103rului natural scris pe cartona\u0219. Pentru fiecare cartona\u0219 valoarea magic\u0103 este dat\u0103 de al \\(k\\)-lea divizor prim al num\u0103rului \u00eenscris pe acesta. Vr\u0103jitoarea trebuie s\u0103 adune valorile magice ob\u021binute pentru cele \\(n\\) cartona\u0219e \u0219i apoi s\u0103 introduc\u0103 \u00een ordine cifrele valorii ob\u021binute, pentru a descuia lada.</p> <p>Pentru a rezolva problema vom afla folosind un ciur to\u021bi divizorii primi ai numerelor mai mici sau egale cu \\(10^6\\), ace\u0219tia fiind folosi\u021bi pentru a calcula r\u0103spunsul la query-uri. Aflarea r\u0103spunsului final devine u\u0219oar\u0103 ulterior efectu\u0103rii acestui pas.</p> <p>Solu\u021bia de \\(100\\) de puncte</p>"},{"location":"usor/sieve/#problema-primprim-oji-2023-de-pe-kilonova","title":"Problema primprim - OJI 2023 de pe Kilonova","text":"<p>Pentru un numa\u0306r natural a definim costul ca fiind valoarea absoluta\u0306 (modulul) diferen\u021bei dintre a \u0219i numa\u0306rul prim cel mai apropiat de a. Asupra unui \u0219ir de \\(n\\) numere naturale, situate pe pozi\u021bii numerotate de la \\(1\\) la \\(n\\), se aplica\u0306, \u00een ordine, o succesiune de \\(q\\) opera\u021bii. O opera\u021bie consta\u0306 dintr-o \u00eenlocuire \u0219i o afi\u0219are \u0219i este descrisa\u0306 sub forma \\(i \\ x \\ p\\), cu semnifica\u021bia: mai \u00eenta\u0302i \u00eenlocuim cu \\(x\\) elementul din \u0219ir de pe pozi\u021bia \\(i\\); apoi afi\u0219a\u0306m suma minima\u0306 totala\u0306 a costurilor unor elemente convenabil selectate de pe \\(p\\) pozi\u021bii distincte din \u0219ir.</p> <p>Cunosca\u0302nd \\(n\\) \u0219i cele \\(n\\) elemente ale \u0219irului, scrie\u021bi un program care sa\u0306 determine:</p> <ul> <li>suma costurilor tuturor elementelor din \u0219irul dat;</li> <li>rezultatele afi\u0219ate \u00een urma aplica\u0306rii fieca\u0306reia dintre cele \\(q\\) opera\u021bii, date \u00een forma precizata\u0306.</li> </ul> <p>Pentru a rezolva problema, vom precalcula pentru fiecare valoare r\u0103spunsul optim pentru fiecare num\u0103r de la \\(1\\) la \\(a\\) folosind ciurul lui Eratostene. Apoi, parcurgem valorile de la \\(1\\) la \\(a\\) pentru a afla r\u0103spunsul optim dup\u0103 ce am aflat numerele prime din \u0219ir. </p> <p>Pentru a rezolva query-urile, voi folosi un vector de frecventa pentru a tine aceste diferen\u021be, care de altfel sunt destul de mici. Apoi, pentru fiecare query, voi parcurge vectorul de frecven\u021b\u0103 pentru a afla suma celor mai mici \\(p\\) diferen\u021be.</p> <p>Solu\u021bia de \\(100\\) de puncte</p>"},{"location":"usor/sieve/#probleme-si-lectura-suplimentara","title":"Probleme \u0219i lectur\u0103 suplimentar\u0103","text":"<p>Mai trebuie puse probleme</p> <ul> <li>Probleme cu ciurul lui Eratostene de pe kilonova</li> <li>Wikipedia - Ciurul lui Eratostene</li> <li>Articol de pe CP Algorithms</li> </ul>"},{"location":"usor/sorting/","title":"Algoritmi simpli de sortare","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p>"},{"location":"usor/sorting/#fundamente-si-cunostinte-necesare","title":"Fundamente \u0219i cuno\u0219tin\u021be necesare","text":"<p>\u00cen foarte multe probleme de algoritmic\u0103, un pas important \u00een rezolvarea problemelor const\u0103 \u00een ordonarea datelor de intrare dup\u0103 un anumit criteriu, iar o \u00eentrebare care se pune este cum putem s\u0103 ordon\u0103m datele convenabil, c\u00e2t mai rapid posibil?</p> <p>Din fericire, de-a lungul timpului s-au inventat foarte mul\u021bi algoritmi de sortare pe care \u00eei putem folosi pentru a rezolva problema pus\u0103 mai sus. Pentru a face \u00een\u021belegerea lor u\u0219oar\u0103, voi explica algoritmii \u00een ordine cresc\u0103toare a dificult\u0103\u021bii lor de \u00een\u021belegere, precum \u0219i \u00een ordine cresc\u0103toare a performan\u021bei, men\u021bion\u00e2nd \u00een cazul fiec\u0103ruia din algoritmi cuno\u0219tin\u021bele necesare pentru a-i putea \u00een\u021belege \u0219i folosi cu succes.</p>"},{"location":"usor/sorting/#algoritmi-de-sortare-in-on2","title":"Algoritmi de sortare \u00een \\(O(n^2)\\)","text":"<p>Voi \u00eencepe prin a explica algoritmii de sortare \u00een \\(O(n^2)\\) deoarece ace\u0219tia sunt de o dificultate similar\u0103, singura cuno\u0219tin\u021b\u0103 necesar\u0103 pentru ei fiind lucrul cu tablouri unidimensionale. Performan\u021bele celor trei algoritmi pe care \u00eei voi men\u021biona sunt de asemenea foarte similare, dar fiecare din ace\u0219ti algoritmi are punctele lui tari \u0219i slabe. Pentru fiecare sec\u021biune am ata\u0219at un exemplu de ordonare cresc\u0103toare a valorilor folosind acest algoritm.</p>"},{"location":"usor/sorting/#selection-sort","title":"Selection sort","text":"<p>Sortarea prin selec\u021bie sau selection sort este un algoritm elementar de sortare care verific\u0103 fiecare pereche de valori din vector \u0219i dac\u0103 cele dou\u0103 valori sunt a\u0219ezate contrar ordinii folosite la ordonarea lor, le vom schimba \u00eentre ele.</p> <pre><code>int v[1001], n;\n\nfor (int i = 1; i &lt; n; i++) {\n    for (int j = i + 1; j &lt;= n; j++) {\n        if (v[i] &gt; v[j]) {\n            int aux = v[i];\n            v[i] = v[j];\n            v[j] = aux;\n        }\n    }\n}\n</code></pre>"},{"location":"usor/sorting/#bubble-sort","title":"Bubble sort","text":"<p>Sortarea prin metoda bulelor sau bubble sort este un algoritm elementar de sortare care itereaz\u0103 prin valorile din vector c\u00e2t timp nu sunt ordonate \u0219i la fiecare pas al itera\u021biei, dac\u0103 g\u0103se\u0219te dou\u0103 valori adiacente ordonate contrar ordinii cerute, schimb\u0103 \u00eentre ele valorile \u0219i reseteaz\u0103 contorul folosit pentru a decide dac\u0103 algoritmul va trebui continuat dup\u0103 sf\u00e2r\u0219itul itera\u021biei curente a structurii repetitive.</p> <p>Observa\u021bie</p> <p>Num\u0103rul de interschimb\u0103ri f\u0103cut de algoritmul bubble sort este egal cu num\u0103rul de inversiuni al vectorului dat, observa\u021bie ce se va dovedi a fi foarte util\u0103 pentru multe con\u021binuturi mai avansate.</p> <pre><code>int v[1001], n;\nbool ok = true;\n\nwhile (ok == true) {\n    ok = false;\n\n    for (int i = 1; i &lt; n; i++) {\n        if (v[i] &gt; v[i + 1]) {\n            int aux = v[i];\n            v[i] = v[i + 1];\n            v[i + 1] = aux;\n            ok = false;\n        }\n    }\n}\n</code></pre>"},{"location":"usor/sorting/#insertion-sort","title":"Insertion sort","text":"<p>Sortarea prin inser\u021bie sau insertion sort este un algoritm elementar de sortare care pune pe r\u00e2nd fiecare valoare \u00eentre pozi\u021biile \\(2\\) \u0219i \\(n\\) pe pozi\u021bia potrivit\u0103 \u00een ordinea sortat\u0103 a valorilor p\u00e2n\u0103 la acea pozi\u021bie inclusiv.</p> <pre><code>int v[1001], n;\n\nfor (int i = 2; i &lt;= n; i++) {\n    for (int j = i - 1; j &gt;= 1; j--) {\n        if (v[j] &gt; v[j + 1]) {\n            int aux = v[j];\n            v[j] = v[j + 1];\n            v[j + 1] = aux;\n        }\n    }\n}\n</code></pre>"},{"location":"usor/sorting/#algoritmi-de-sortare-in-on-log-n","title":"Algoritmi de sortare \u00een \\(O(n \\log n)\\)","text":"<p>Dup\u0103 studiul algoritmilor de mai sus, o \u00eentrebare natural\u0103 se pune: putem sorta un \u0219ir mai repede de \\(O(n^2)\\)? R\u0103spunsul este unul afirmativ, exist\u00e2nd foarte mul\u021bi algoritmi de sortare mai rapizi, cei mai rapizi fiind cei \u00een \\(O(n \\log n)\\). De\u0219i \u00een practic\u0103 \u00een cadrul concursurilor, de regul\u0103 ajungem s\u0103 ne folosim de func\u021bia std::sort, propriet\u0103\u021bile celorlal\u021bi algoritmi pot fi utile pentru \u00een\u021belegerea anumitor concepte prezentate pe parcurs.</p>"},{"location":"usor/sorting/#functia-stdsort","title":"Func\u021bia std::sort","text":"<p>Se poate spune c\u0103 de departe cea mai folosit\u0103 metod\u0103 de a ordona un \u0219ir \u00een timpul unei competi\u021bii este prin folosirea func\u021biei oferite de limbajul C++ pentru a sorta un \u0219ir, aceast\u0103 func\u021bie av\u00e2nd la spate algoritmul IntroSort, o combina\u021bie \u00eentre QuickSort, HeapSort \u0219i Insertion Sort care preia cele mai bune caracteristici ale celor trei algoritmi men\u021biona\u021bi. Aplicarea ei se va dovedi a fi banal\u0103, fiind nevoie de o singur\u0103 linie de cod.</p> <p>Pentru a scrie func\u021bia, trebuie s\u0103 \u0219tim adresa de \u00eenceput (de regul\u0103, pozi\u021bia \\(0\\) sau \\(1\\) din \u0219ir) \u0219i adresa de final, cea de final fiind incrementat\u0103 cu \\(1\\) deoarece intervalul pe care \u00eel vom folosi pentru func\u021bia descris\u0103 este \u00eenchis la st\u00e2nga \u0219i deschis la dreapta. Dup\u0103 cum se va observa mai jos, vom putea ad\u0103uga func\u021bii de comparare pentru a folosi <code>std::sort</code> la valoarea sa adev\u0103rat\u0103. Mai jos am ata\u0219at dou\u0103 exemple de aplicare a func\u021biei, pe vector indexat de la \\(0\\), respectiv \\(1\\).</p> <pre><code>int v[1001], n;\n\nsort(v + 1, v + n + 1);\n\nvector&lt;int&gt; vx(1002);\nsort(vx.begin(), vx.begin() + 500);\n\nvector&lt;int&gt; vy(2001);\nsort(vx.begin() + 1, vx.end());\n</code></pre>"},{"location":"usor/sorting/#quick-sort","title":"Quick Sort","text":"<p>QuickSort sau Sortarea rapid\u0103 este o metod\u0103 eficient\u0103 de sortare a unui tablou, descoperit\u0103 de programatorul britanic Tony Hoare. Pentru un set de \\(n\\) valori oarecare algoritmul efectueaz\u0103 \\(O(n \\log n)\\) compara\u021bii, dar \u00een cazul cel mai nefavorabil se efectueaz\u0103 \\(O(n^2)\\) compara\u021bii. De regul\u0103, acest algoritm este mai rapid dec\u00e2t merge sort sau heap sort, dar dac\u0103 pivotul este ales favorabil, cazul cel mai nefavorabil va efectua mereu \\(O(n \\log n)\\) compara\u021bii.</p> <p>Algoritmul este de tip divide et impera; el sorteaz\u0103 o secven\u021b\u0103 a tabloului (ini\u021bial \u00eentreg tabloul), astfel:</p> <ul> <li>se alege un element special al listei, numit pivot;</li> <li>se ordoneaz\u0103 elementele listei, astfel \u00eenc\u00e2t toate elementele din st\u00e2nga   pivotului s\u0103 fie mai mici sau egale cu acesta, \u0219i toate elementele din dreapta   pivotului s\u0103 fie mai mari sau egale cu acesta;</li> <li>se continu\u0103 recursiv cu secven\u021ba din st\u00e2nga pivotului \u0219i cu cea din dreapta   lui.</li> </ul>"},{"location":"usor/sorting/#merge-sort","title":"Merge Sort","text":"<p>MergeSort este o metod\u0103 eficient\u0103 de sortare a unui tablou, inventat\u0103 de programatorul John von Neumann. Pentru un set de \\(n\\) valori oarecare algoritmul efectueaz\u0103 \\(O(n \\log n)\\) compara\u021bii, algoritmul fiind acela\u0219i indiferent de modul \u00een care sunt a\u0219ezate valorile. Algoritmul func\u021bioneaz\u0103 \u00een felul urm\u0103tor.</p> <ul> <li>Avem lista curent\u0103, o \u00eemp\u0103r\u021bim \u00een dou\u0103 jum\u0103t\u0103\u021bi egale.</li> <li>Rul\u0103m algoritmul pe fiecare din cele dou\u0103 jum\u0103t\u0103\u021bi.</li> <li>Se interclaseaz\u0103 cele dou\u0103 \u0219iruri rezultate.</li> </ul> <p>Este de remarcat c\u0103 acest algoritm poate fi folosit pentru a calcula num\u0103rul de inversiuni al unui \u0219ir.</p>"},{"location":"usor/sorting/#heap-sort","title":"Heap Sort","text":"<p>Heap sort este un algoritm de sortare care la fiecare pas selecteaz\u0103 valoarea minim\u0103 folosind structura de date potrivit\u0103 (un heap, un arbore de intervale, un set etc.) \u0219i de aceea poate fi descris \u0219i drept un selection sort cu structura de date potrivit\u0103. La fiecare pas se afl\u0103 valoarea minim\u0103 din \u0219ir \u0219i se interschimb\u0103 valorile de pe cea mai din st\u00e2nga pozi\u021bie nefixat\u0103 cu valoarea de pe pozi\u021bia minim\u0103 g\u0103sit\u0103.</p>"},{"location":"usor/sorting/#sortare-cu-comparator-special","title":"Sortare cu comparator special","text":"<p>Uneori, criteriul dup\u0103 care sort\u0103m un \u0219ir poate fi mai dificil de configurat de c\u0103tre <code>std::sort</code>, a\u0219a c\u0103 de multe ori suntem nevoi\u021bi s\u0103 implement\u0103m logica proprie de comparator. De cele mai multe ori, acesta va fi implementat drept o func\u021bie bool, care ia ca parametru dou\u0103 valori ale \u0219irului ce vrem s\u0103 \u00eel ordon\u0103m \u0219i le verific\u0103m folosind criteriul dorit. \u00cen secven\u021ba de mai jos, avem o structur\u0103 str \u0219i vom sorta datele de intrare din structur\u0103 folosind drept criteriu de comparare suma valorilor din pereche. Se poate observa faptul c\u0103 func\u021bia de comparare este apelat\u0103 de, \u00een acest caz, <code>std::sort</code>.</p> <pre><code>constexpr int N = 100;\n\nstruct Foo {\n    int a, b;\n};\n\nFoo v[N + 1];\n\nbool cmp(const Foo x, const Foo y) {\n    return (x.a + x.b) &lt; (y.a + y.b);\n}\n\nsort(v + 1, v + N + 1, cmp);\n\n// Alternativ (vom elabora \u00eentr-o lec\u021bie viitoare):\nvector&lt;Foo&gt; foos(N + 1);\n\nsort(foos.begin(), foos.end(),\n     [](const Foo x, const Foo y) {\n        return (x.a + x.b) &lt; (y.a + y.b);\n     });\n</code></pre>"},{"location":"usor/sorting/#algoritmi-speciali-de-sortare","title":"Algoritmi speciali de sortare","text":""},{"location":"usor/sorting/#counting-sort","title":"Counting Sort","text":"<p>Counting sort este un algoritm de sortare folosit atunci c\u00e2nd avem un num\u0103r mic de elemente distincte, care pot fi \u021binute \u00eentr-un vector de frecven\u021b\u0103. Acest algoritm se poate folosi \u0219i dac\u0103 intervalul \u00een care sunt a\u0219ezate valorile este unul mic, complexitatea fiind \u00een ambele cazuri \\(O(n + k)\\), unde \\(n\\) este num\u0103rul de valori din \u0219ir, iar \\(k\\) este diferen\u021ba dintre cea mai mare \u0219i cea mai mic\u0103 valoare din \u0219ir.</p>"},{"location":"usor/sorting/#radix-sort","title":"Radix Sort","text":"<p>Radix sort este un algoritm de sortare folosit atunci c\u00e2nd vrem s\u0103 grup\u0103m elementele \u00een func\u021bie de cifrele lor, de la cea mai semnificativ\u0103 la cea mai nesemnificativ\u0103, acest algoritm fiind util \u00eentr-o serie de probleme ce implic\u0103 prelucrarea cifrelor \u0219i numerelor \u00een diferite moduri.</p>"},{"location":"usor/sorting/#concluzii-si-probleme-suplimentare","title":"Concluzii \u0219i probleme suplimentare","text":"<p>Algoritmii de sortare sunt foarte utili pentru a \u00een\u021belege bazele multor algoritmi, diversele metode folosite reg\u0103sindu-se \u00een foarte multe tipuri de probleme, dar \u0219i \u00een anumite optimiz\u0103ri care pot fi g\u0103site pentru a evita tratarea anumitor probleme \u00eentr-o manier\u0103 prea generic\u0103.</p> <p>Ace\u0219ti algoritmi ajung s\u0103 fie folosi\u021bi \u00een foarte multe tipuri de probleme, cele mai frecvente fiind aplica\u021biile tip greedy dar \u0219i alte probleme \u00een care sortarea poate consta un pas spre a procesa mai u\u0219or datele de intrare, precum c\u0103utarea binar\u0103, diverse probleme ce implic\u0103 structuri de date \u0219i a\u0219a mai departe.</p>"},{"location":"usor/sorting/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>perechi kilonova</li> <li>sir OJI 2005</li> <li>USACO Bronze Acowdemia I</li> <li>Pergament OJI 2023</li> <li>pseudocmp OJI 2022</li> <li>yinyang OJI 2019</li> <li>JOI 2018 Stove</li> <li>JOI 2018 Art Exhibition</li> <li>InfoPro insertsort</li> <li>probleme cu sortare de pe Kilonova</li> <li>High Card Low Card USACO Gold</li> </ul>"},{"location":"usor/sorting/#probleme-de-pe-alte-siteuri","title":"Probleme de pe alte siteuri","text":"<ul> <li>Distinct Numbers</li> <li>Movie Festival</li> <li>Towers</li> <li>Kayaking</li> <li>Movie Festival II</li> <li>Tasks and Deadlines</li> <li>Permutator</li> <li>Playing in a Casino</li> <li>The Party and Sweets</li> <li>USB vs. PS/2</li> </ul>"},{"location":"usor/sorting/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Introduction to Sorting - USACO Guide</li> <li>Greedy Algorithms with Sorting</li> <li>Sortarea prin num\u0103rare</li> <li>Tutorial Video RoAlgo</li> </ul>"},{"location":"usor/sume_partiale/","title":"Sume par\u021biale","text":""},{"location":"usor/sume_partiale/#cunostiinte-necesare-pentru-intelegerea-completa-a-articolului","title":"Cuno\u0219tiin\u021be necesare pentru \u00een\u021belegerea complet\u0103 a articolului:","text":"<ul> <li>tablourile unidimensionale \u0219i parcurgerea lor</li> <li>tablourile bidimensionale \u0219i parcurgerea lor</li> </ul>"},{"location":"usor/sume_partiale/#problema-initiala","title":"Problema ini\u021bial\u0103","text":"<p>S\u0103 presupunem c\u0103 avem un \u0219ir \\(V\\) de \\(N\\) numere indexat de la \\(1\\), iar asupra \u0219irului primim mai multe \u00eentreb\u0103ri de forma: care este suma valorilor cuprinse \u00eentre pozi\u021biile \\(st\\) \u0219i \\(dr\\) (inclusiv) \u00een \u0219ir?</p> <p>R\u0103spunsul pentru aceast\u0103 \u00eentrebare se poate calcula foarte u\u0219or dac\u0103 realiz\u0103m parcurgerea efectiv\u0103 a \u0219irului de la pozi\u021bia \\(st\\) la pozi\u021bia \\(dr\\) \u0219i ne-ar lua \\(O(N)\\) pa\u0219i \u00een cel mai r\u0103u caz ca s\u0103 r\u0103spundem la o \u00eentrebare, complexitatea final\u0103 a programului ajung\u00e2nd la \\(O(N \\cdot Q)\\), ceea ce pentru valori mai mari de \\(10^4\\) pentru \\(N\\) \u0219i \\(Q\\) ar dep\u0103\u0219i limitele de timp la majoritatea problemelor de algoritmic\u0103. A\u0219adar, este nevoie de o optimizare, care se nume\u0219te \u201eSume par\u021biale\u201d.</p>"},{"location":"usor/sume_partiale/#prezentarea-conceptului","title":"Prezentarea conceptului","text":"<p>Sumele par\u021biale reprezint\u0103 o optimizare pentru algoritmii care trebuie s\u0103 afle o sum\u0103 pe un interval, iar pe acel interval nu se produc modific\u0103ri. Consider\u0103m: \\(sp[i] =\\) suma valorilor de pe prefixul \\(1, 2, \\dots, i\\)</p> <p>Tabloul se calculeaz\u0103 \u00een felul urm\u0103tor:</p> <pre><code>for (int i = 1; i &lt;= n; i++)\n    sp[i] = sp[i - 1] + v[i];\n</code></pre> <p>Dup\u0103 calculare, putem \u00eencepe s\u0103 r\u0103spunem la \u00eentreb\u0103ri. R\u0103spunsul nostru pentru un interval \\([st, dr]\\), unde \\(1 \\leq st \\leq dr \\leq n\\) va fi: \\(suma \\ = sp[dr] - sp[st - 1]\\)</p> <p>Faptul c\u0103 r\u0103spunsul nostru este dat de o formul\u0103, va face ca timpul nostru efectuat pentru rezolvarea unei \u00eentreb\u0103ri s\u0103 fie constant \\(O(1)\\), ceea ce va duce ca programul nostru s\u0103 aib\u0103 o complexitate final\u0103 \\(O(N + Q)\\), pentru calcularea tabloului \\(sp\\) \u0219i pentru citirea \u0219i r\u0103spunderea la \u00eentreb\u0103ri. Totu\u0219i, hai s\u0103 vedem de ce formula men\u021bionat\u0103 mai sus func\u021bioneaz\u0103. </p> <p>Pentru demonstra\u021bie, vom \u00eencerca o abordare grafic\u0103 a formulei. Primul pas const\u0103 \u00een adunarea sumei prefixului \\(1, 2, \\dots, dr\\).</p> <p></p> <p>Apoi, va trebui s\u0103 sc\u0103dem prefixul \\(1, 2, \\dots, st - 1\\). </p> <p>\u00cen final, subsecven\u021ba \\(st, st + 1, \\dots, dr - 1, dr\\) va fi alc\u0103tuit\u0103 din acele pozi\u021bii care se afl\u0103 \u00een segmentul verde (prefixul \\(1, 2, \\dots, dr\\)), dar care nu se afl\u0103 \u0219i \u00een segmentul ro\u0219u (prefixul \\(1, 2, \\dots, st - 1\\)). A\u0219adar, \u00een urma acestei delimit\u0103ri o s\u0103 ob\u021binem suma cerut\u0103 pe intervalul nostru.</p>"},{"location":"usor/sume_partiale/#extinderea-sumelor-partiale-pe-matrice","title":"Extinderea sumelor par\u021biale pe matrice","text":"<p>De asemenea, sumele par\u021biale se pot extinde \u0219i pe tablouri bidimensionale. S\u0103 presupunem c\u0103 lucr\u0103m cu matricea \\(A\\) care are \\(N\\) linii \u0219i \\(M\\) coloane. Vom defini matricea \\(sp\\) \u00een felul urm\u0103tor: </p> <p>\\(sp[i][j] =\\) suma valorilor aflate \u00een submatricea care are col\u021bul st\u00e2nga-sus de coordonate \\((1, 1)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((i, j)\\)</p> <p>Fa\u021b\u0103 de cazul \\(1D\\), aici vom \u00eencepe cu demonstra\u021bia formulei de calcul a unei sume pe o submatrice, apoi vom \u0219i ar\u0103ta cum se va calcula matricea \\(sp\\). Vom analiza ni\u0219te cazuri particulare de submatrice, apoi vom enun\u021ba o formul\u0103 final\u0103.</p> <p>Pentru \u00eenceput, datorit\u0103 modului \u00een care am definit matricea \\(sp\\), primul caz particular pe care \u00eel vom analiza va fi calcularea sumei de pe o submatrice care are col\u021bul st\u00e2nga-sus de coordonate \\((1, 1)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((x, y)\\). R\u0103spunsul \u00een acest caz va fi \\(sp[x][y]\\), deoarece fix acest lucru ne este calculat de c\u0103tre matricea \\(sp\\).</p> <p></p> <p>\\(suma = sp[x][y]\\)</p> <p>Acum, s\u0103 analiz\u0103m urm\u0103torul caz: ni se cere s\u0103 afl\u0103m suma valorilor dintr-o submatrice care are col\u021bul st\u00e2nga-sus de coordonate \\((1, z)\\) \u0219i col\u021bul dreapta-jos de coordonate \\((x, y)\\). Formula men\u021bionat\u0103 mai sus nu este corect\u0103, dar este un punct de plecare. Noi vom con\u021bine o submatrice \u00een plus \u00een cea determinat\u0103 de col\u021burile de coordonate \\((1, 1)\\) \u0219i \\((x, y)\\), anume cea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((x, z - 1)\\). A\u0219adar, dup\u0103 adunarea sumei date de \\(sp[x][y]\\) va fi nevoie s\u0103 sc\u0103dem \\(sp[x][z - 1]\\).</p> <p></p> <p>\\(suma = sp[x][y] - sp[x][z - 1]\\)</p> <p>Asemenea cazului precedent este si cazul \u00een care noi dorim s\u0103 afl\u0103m suma unei submatrice care are col\u021burile \\((z, 1)\\) \u0219i \\((x, y)\\). Similar, \\(sp[x][y]\\) nu este suficient, dar este un punct de plecare. Fa\u021b\u0103 de cazul precedent, submatricea \\emph{\u00een plus} este cea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((z - 1, y)\\). \u00cen final, formula pentru acest caz va fi \\(sp[x][y] - sp[z - 1][y]\\).</p> <p>% lasa imaginile vietii asa, vad eu cum le refac, dar tot ar fi util sa pui referinte (gen \"In fig.~\\ref{fig:sp5} vorbim de Scufita Rosie\" nuj)</p> <p></p> <p>\\(suma = sp[x][y] - sp[z - 1][y]\\)</p> <p>Acum, putem \u00eencerca s\u0103 deducem o formul\u0103 pentru orice submatrice. S\u0103 consider\u0103m submatricea determinat\u0103 de col\u021burile st\u00e2nga-sus de coordonate \\((x, y)\\) \u0219i dreapta-jos de coordonate \\((z, t)\\). Dac\u0103 ar fi s\u0103 adun\u0103m formulele demonstrate \u00een ultimele dou\u0103 cazuri \\((sp[z][t] - sp[x - 1][t] - sp[z][y - 1])\\), noi o s\u0103 sc\u0103dem de dou\u0103 ori suma din submatricea determinat\u0103 de col\u021burile \\((1, 1)\\) \u0219i \\((x - 1, y - 1)\\), \u00een timp ce noi o adun\u0103m doar o dat\u0103. A\u0219adar, la formul\u0103 se va aduna \u0219i suma din submatricea respectiv\u0103, pentru a compensa deficitul.</p> <p></p> <p>\\(suma = sp[z][t] - sp[z][y - 1] - sp[x - 1][t] + sp[x - 1][y - 1]\\)</p> <p>Cu un ra\u021bionament asem\u0103n\u0103tor celui pentru determinarea formulei pentru cazul general, vom determina \u0219i cum se calculeaz\u0103 matricea \\(sp\\). S\u0103 presupunem c\u0103 vrem s\u0103 afl\u0103m \\(sp[i][j]\\). Mai \u00eent\u00e2i vom porni de la a scrie formula pentru a afla suma valorii de pe pozi\u021bia \\((i, j)\\) \u00een matrice (valoare pe care noi o \u0219i stim!):</p> <p>\\(sp[i][j] - sp[i - 1][j] - sp[i][j - 1] + sp[i - 1][j - 1] = A[i][j]\\)</p> <p>Trecem to\u021bi termenii, cu excep\u021bia lui \\(sp[i][j]\\), \u00een dreapta \u0219i ob\u021binem:</p> <p>\\(sp[i][j] = sp[i - 1][j] + sp[i][j - 1] - sp[i - 1][j - 1] + A[i][j]\\)</p> <p>Deci, tabloul \\(sp\\) se poate calcula destul de u\u0219or \u00een timp \\(O(N \\cdot M)\\). Ata\u0219\u0103m, mai jos, o secven\u021b\u0103 de cod \u00een care se calculeaz\u0103 matricea \\(sp\\).</p> <pre><code>for (int i = 1; i &lt;= n; i++)\n    for (int j = 1; j &lt;= m; j++)\n        sp[i][j] = sp[i - 1][j] + sp[i][j - 1] - sp[i - 1][j - 1] + a[i][j];\n</code></pre>"},{"location":"usor/sume_partiale/#smenul-lui-mars","title":"\u0218menul lui Mars","text":"<p>S\u0103 consider\u0103m urm\u0103toarea problem\u0103: se d\u0103 o ax\u0103 \u0219i \\(K\\) intervale de forma \\([st, dr]\\). Ni se dau dup\u0103 \\(Q\\) \u00eentreb\u0103ri de forma: c\u00e2te intervale con\u021bin \u00een interiorul lor punctul \\(x\\) de pe ax\u0103? </p> <p>O solu\u021bie foarte ineficient\u0103 ar fi pentru fiecare \u00eentrebare s\u0103 lu\u0103m fiecare interval \u00een parte \u0219i s\u0103 verific\u0103m dac\u0103 punctul nostru este inclus sau nu \u00een interval. Solu\u021bia este u\u0219or de intuit \u0219i de implementat, dar programul nostru ar avea complexitate \\((Q \\cdot K)\\). \u0218menul lui Marius Andrei (Mars) ne poate rezolva aceast\u0103 problem\u0103 \u00een timp constant, chiar \u0219i dac\u0103 o extindem pe mai multe dimensiuni (dou\u0103 axe, \\(3\\) axe etc.).</p> <p>\u0218menul lui Mars permite efectuarea opera\u021biilor de ad\u0103ugare a unei valori la toate elementele dintr-un interval (sau o submatrice, pentru cazul \u00een care lucr\u0103m cu o matrice), f\u0103r\u0103 posibilitatea de a primi \u00eentreb\u0103ri \u00eentre opera\u021biile de ad\u0103ugare (pentru acest tip de problem\u0103 se vor utiliza arborii de intervale, o tehnic\u0103 care va fi prezentat\u0103 ulterior). C\u00e2nd primim actualiz\u0103rile, noi vom efectua ni\u0219te adun\u0103ri \u0219i ni\u0219te sc\u0103deri pentru a delimita bucata din \u0219ir / matrice pe care se efectueaz\u0103 opera\u021bia. Apoi, valorile efective din structura noastr\u0103 de date se vor calcula asem\u0103n\u0103tor sumelor par\u021biale, fapt ce ne poate intui \u00eentr-o modalitate cum vom efectua aceste opera\u021bii.</p>"},{"location":"usor/sume_partiale/#smenul-lui-mars-1d","title":"\u0218menul lui Mars 1D","text":"<p>Primul pas c\u00e2nd aplic\u0103m \u0218menul lui Mars unui \u0219ir, va trebui s\u0103 lu\u0103m fiecare interval \u00een parte \u0219i s\u0103 delimit\u0103m bucata din \u0219ir pe care efectu\u0103m opera\u021bia. Pentru intervalul de pozi\u021bii \\([x, y]\\), vom actualiza \u00een \u0219men cu \\(+1\\) la pozi\u021bia \\(x\\), ca s\u0103 ilustr\u0103m c\u0103 a \u00eenceput un nou interval, \u0219i cu \\(-1\\) la pozi\u021bia \\(y + 1\\) pentru a ar\u0103ta faptul c\u0103 intervalul nostru nu cuprinde \u0219i pozi\u021bia \\(y + 1\\). Astfel, vom avea:</p> <pre><code>mars[x]++;\nmars[y + 1]--;\n</code></pre> <p>unde vectorul \\(mars[]\\) reprezint\u0103 adun\u0103rile / sc\u0103derile din \u0219men. A\u0219a cum am zis \u0219i mai sus, noi calcul\u0103m valorile noastre din \u0219ir ca la sumele par\u021biale, deci, se poate afirma c\u0103: \\(v[i] = mars[1] + mars[2] + \\dots + mars[i]\\)</p> <p>Dupa efectuarea tuturor opera\u021biilor de ad\u0103ugare pe interval, noi vom calcula printr-o parcurgere simpl\u0103 valorile din \u0219irul \\(V\\):</p> <pre><code>for (int i = 1; i &lt;= n; i++) {\n    mars[i] += mars[i - 1];\n    v[i] = mars[i];\n}\n</code></pre> <p>Aten\u021bie la faptul c\u0103 suma pe prefixul \\(1, 2, \\dots, i\\) va fi \u021binut\u0103 \u00een \\(mars[i]\\). Revenind la problema noastr\u0103 ini\u021bial\u0103, r\u0103spunsul la fiecare \u00eentrebare va fi \u00een \\(mars[x]\\), astfel ob\u021bin\u00e2nd \\bigO{1} pe query. Evident, dac\u0103 vrem s\u0103 ad\u0103ug\u0103m o valoare \\(z\\) \u00een loc de \\(1\\) pe interval, acest lucru se poate realiza foarte u\u0219or:</p> <pre><code>mars[x] += z;\nmars[y + 1] -= z;\n/// cod din program\nfor (int i = 1; i &lt;= n; i++) {\n    mars[i] += mars[i - 1];\n    v[i] += mars[i];\n}\n</code></pre> <p>Codul de mai sus poate s\u0103 sus\u021bin\u0103 \u0219i updateuri pe un \u0219ir ini\u021bial nevid. Dac\u0103 problema noastr\u0103 nu are suficient\u0103 memorie pentru men\u021binerea \u0219irului, aceste plusuri \u0219i minusuri se pot re\u021bine ca evenimente, care se pot sorta dup\u0103 pozi\u021bie pentru efectuarea lor. Nu o s\u0103 intr\u0103m \u00een profunzime momentan cu aceast\u0103 tehnic\u0103, dar o l\u0103s\u0103m ca tem\u0103 pentru studiu cititorului.</p>"},{"location":"usor/sume_partiale/#smenul-lui-mars-2d","title":"\u0218menul lui Mars 2D","text":"<p>\u0218menul lui Mars aplicat pe o matrice presupune \u00een\u021belegerea mai profund\u0103 a cum se propag\u0103 sumele par\u021biale pe matrice. S\u0103 presupunem c\u0103 avem submatricea delimitat\u0103 de col\u021burile \\((x, y)\\) \u0219i \\((z, t)\\). Dac\u0103 o s\u0103 facem doar o adunare \u0219i o sc\u0103dere ca la cazul liniar din \u0219menul lui Mars, propag\u0103rile noastre vor fi foarte eronate. S\u0103 privim \u00een desen de ce:</p> <p></p> <p>O s\u0103 avem, \u00een plus, multe elemente care sunt actualizate. De aceea, se va proceda \u00een felul urm\u0103tor: se va p\u0103stra adunarea de la \\(mars[x][y]\\) \u0219i se va sc\u0103dea la \\(mars[z + 1][y]\\) \u0219i \\(mars[x][t + 1]\\). \u00cenc\u0103 nu este complet, fiindc\u0103 pe submatricea \\((z + 1, t + 1), (N, M)\\) vor fi o adunare \u0219i dou\u0103 sc\u0103deri, deci acum sc\u0103dem mai mult dec\u00e2t ar trebui, deci va trebui s\u0103 adun\u0103m \u0219i la \\(mars[z + 1][t + 1]\\).</p> <p></p> <p>\u00cen cod, ar ar\u0103ta \u00een felul urm\u0103tor:</p> <pre><code>mars[x][y] += k;\nmars[z + 1][y] -= k;\nmars[x][t + 1] -= k;\nmars[z + 1][t + 1] += k;\n/// cod din program\nfor (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n        mars[i][j] += mars[i - 1][j] + mars[i][j - 1] - mars[i - 1][j - 1];\n        a[i][j] += mars[i][j];\n    }\n}\n</code></pre> <p>\u00cen final, \u00een urma opera\u021biilor de ad\u0103ugare, dac\u0103 vrem s\u0103 \u0219tim ce valoare se afl\u0103 pe pozi\u021bia \\((i, j)\\), r\u0103spunsul va fi dat de \\(A_{i, j}\\).</p> <p>\u0218menul lui Mars poate fi extins \u0219i pe \\(3\\) dimensiuni sau chiar mai multe, iar abordarea pe mai multe dimensiuni se va realiza identic, dar o s\u0103 fie rar \u00eent\u00e2lnit \u00een problemele de algoritmic\u0103 cazuri \u00een care s\u0103 se cear\u0103 \u0219menul lui Mars pe mai mult de dou\u0103 dimensiuni.</p>"},{"location":"usor/sume_partiale/#concluzii-si-probleme-suplimentare","title":"Concluzii \u0219i probleme suplimentare","text":"<p>Sumele par\u021biale sunt o optimizare cheie \u00een algoritmic\u0103, ajut\u00e2ndu-ne s\u0103 transform\u0103m lucruri precum aflarea unei sume pe un interval dintr-o \u00eentreag\u0103 parcurgere \u00eentr-o simpl\u0103 formul\u0103, cu timp constant de r\u0103spuns.</p> <p>Pentru aprofundarea algoritmilor prezenta\u021bi mai sus, recomand rezolvarea urm\u0103toarelor probleme \u0219i articole:</p>"},{"location":"usor/sume_partiale/#probleme-de-la-olimpiade","title":"Probleme de la olimpiade","text":"<ul> <li>Prefix Sums 1D</li> <li>plaja ONI 2010</li> <li>gradina ONI 2013</li> <li>Breed Counting USACO Silver</li> <li>flip01 RoAlgo PreOJI 2024</li> <li>sirpal RoAlgo PreOJI 2024</li> <li>cdcq RoAlgo Contest #1</li> <li>tnia OJI 2018</li> <li>balon ONI 2023</li> <li>poseidon RoAlgo Contest #4</li> <li>investi\u021bie OJI 2023</li> <li>Probleme cu sume par\u021biale</li> <li>Probleme cu \u0219menul lui Mars</li> <li>Subsequences Summing to Sevens USACO Silver</li> <li>Haybale Stacking USACO Bronze</li> <li>Painting the Barn USACO Gold</li> </ul>"},{"location":"usor/sume_partiale/#probleme-de-pe-codeforces","title":"Probleme de pe Codeforces","text":"<ul> <li>Good Subarrays - Codeforces</li> <li>Running Miles - Codeforces</li> <li>Irreductible Anagrams</li> <li>Nusret Gokce</li> <li>Two Pointers Step 3 - Codeforces EDU</li> </ul>"},{"location":"usor/sume_partiale/#bibliografie-si-lectura-suplimentara","title":"Bibliografie \u0219i lectur\u0103 suplimentar\u0103","text":"<ul> <li>Sume par\u021biale - CPPI</li> <li>Trucul lui Mars - CPPI</li> <li>Prefix Sums - USACO Guide</li> <li>More on Prefix Sums</li> <li>An Introduction to Difference Arrays</li> </ul>"},{"location":"usor/tablouri/","title":"Tablouri (arrays)","text":"<p>Autor: \u0218tefan-Cosmin D\u0103sc\u0103lescu</p> <p>Una din primele structuri de date pe care orice programator o folose\u0219te, indiferent de limbajul de programare folosit este tabloul (array \u00een englez\u0103). Ace\u0219tia stau la baza unui num\u0103r mare de prelucr\u0103ri care necesit\u0103 un volum mare de date, iar \u00een contextul rezolv\u0103rii problemelor de algoritmic\u0103, tablouri sunt o parte fundamental\u0103 at\u00e2t \u00een sine, c\u00e2t \u0219i prin faptul c\u0103 toate tablourile multidimensionale sunt de fapt, tablouri unidimensionale pu\u0219i \u00eempreun\u0103. Colocvial, aceste tablouri mai sunt numite \u0219i vectori, dar trebuie evitat\u0103 confuzia cu vectorii din STL, prezenta\u021bi ulterior.</p> <p>Observa\u021bie</p> <p>\u00cen memorie, tablourile sunt stocate secven\u021bial, indiferent de num\u0103rul de dimensiuni pe care \u00eel au.</p> <p>\u00cen contextul limbajului C++, putem lucra cu tablourile \u00een dou\u0103 moduri distincte: fie folosind varianta standard, luat\u0103 din limbajul C, fie folosind STL (Standard Template Library). Conceptele din STL vor fi prezentate \u00een capitolele ulterioare, deoarece acesta nu con\u021bine doar tablouri dinamice. \u00cen acest capitol voi insista mai ales pe varianta standard, lucrul cu STL fiind aprofundat mai cu seam\u0103 \u00een capitolele utile.</p>","tags":["vectori"]},{"location":"usor/tablouri/#declararea-si-umplerea-tablourilor-statice","title":"Declararea \u0219i umplerea tablourilor statice","text":"<p>Pentru a declara un tablou \u0219i a da valori, trebuie s\u0103 analiz\u0103m structura acestuia. \u00cen mod similar cu variabilele simple, ne trebuie un tip de date pe care acest tablou s\u0103-l stocheze, precum \u0219i dimensiunea pe care vrem s\u0103 o atribuim acestui tablou.</p> <p>De exemplu, <code>int v[101];</code> \u00eenseamn\u0103 ca am declarat un tablou cu \\(101\\) elemente, pozi\u021biile fiind num\u0103rate de la \\(0\\) la \\(100\\).</p> <p>Observa\u021bie</p> <p>Dac\u0103 prefera\u021bi s\u0103 lucra\u021bi cu tablouri indexate de la \\(1\\), ave\u021bi grij\u0103 s\u0103 ad\u0103uga\u021bi \\(1\\) la dimensiunile pe care le folosi\u021bi pentru a adapta tablourile la stilul vostru de lucru. De asemenea, nu pute\u021bi \u00eencepe tablourile de la indici negativi cum se poate \u00een alte limbaje (Pascal, de pild\u0103) \u0219i nici s\u0103-i folosi\u021bi pentru a lua elemente de la final (ca \u00een Python).</p> <p>Observa\u021bie</p> <p>De obicei, dimensiunea maxim\u0103 este una static\u0103, dar putem transforma tablourile statice \u00een structuri alocate dinamic folosind func\u021biile din limbajul C. Totu\u0219i, acesta nu este scopul articolului de fa\u021b\u0103, iar ulterior va fi prezentat STL. </p> <p>Pentru a atribui o valoare unei anumite pozi\u021bii, se va proceda similar ca la o variabil\u0103 obi\u0219nuit\u0103, de exemplu <code>v[5] = 7;</code> \u00eenseamn\u0103 c\u0103 pe pozi\u021bia \\(5\\), vom avea acum valoarea \\(7\\).</p> <p>Pentru a citi un vector, vom folosi de regul\u0103 o structur\u0103 repetitiv\u0103, precum for sau while, citind valorile pe r\u00e2nd, la fel cum am proceda cu variabile obi\u0219nuite.</p> <p>O alt\u0103 metod\u0103 de a ini\u021bializa elementele dintr-un tablou este aceea de a atribui valori primelor pozi\u021bii, idee ce va fi folosit\u0103 pe parcurs la diver\u0219i algoritmi, un exemplu notabil fiind flood fill. De exemplu, <code>int A[] = {10, 20, 30};</code> va crea un tablou cu \\(3\\) elemente, unde <code>A[0] = 10; A[1] = 20;</code> \u0219.a.m.d.</p>","tags":["vectori"]},{"location":"usor/tablouri/#inserarea-stergerea-inversarea-valorilor-dintr-un-tablou","title":"Inserarea, \u0219tergerea, inversarea valorilor dintr-un tablou","text":"<p>De multe ori \u00een diverse aplica\u021bii, putem avea nevoie de opera\u021bia de inserare \u0219i de opera\u021bia de \u0219tergere din tablou, ambele opera\u021bii fiind foarte importante pentru a putea lucra \u00een mod corespunz\u0103tor cu tablourile. \u00cen exemplele pe care le voi prezenta mai jos, voi presupune c\u0103 tablourile sunt indexate de la \\(1\\).</p>","tags":["vectori"]},{"location":"usor/tablouri/#inserarea-in-tablou","title":"Inserarea \u00een tablou","text":"<p>Dac\u0103 avem un tablou cu \\(n\\) valori \u0219i vrem s\u0103 inser\u0103m o valoare nou\u0103 la pozi\u021bia \\(k\\), unde \\(1 \\leq k \\leq n+1\\), vom vrea mai \u00eent\u00e2i s\u0103 mut\u0103m valorile \u00eentre pozi\u021biile \\(n\\) \u0219i \\(k\\) cu o pozi\u021bie la dreapta, iar mai apoi vom atribui noua valoare pe pozi\u021bia \\(k\\).  </p> <pre><code>for (int i = n; i &gt;= k; i--) {\n    v[i + 1] = v[i];\n}\n\nv[k] = x;\n\nn++; // (1)\n</code></pre> <ol> <li>Tabloul va avea o valoare \u00een plus, drept pentru care trebuie s\u0103      cre\u0219tem \u00een consecin\u021b\u0103 lungimea sa.</li> </ol> <p>Aten\u021bie</p> <p>Mutarea valorilor trebuie f\u0103cut\u0103 \u00een ordine descresc\u0103toare a pozi\u021biilor ini\u021biale deoarece altfel, am ajunge s\u0103 avem aceea\u0219i valoare peste tot.</p> <pre><code>for (int i = k; i &lt;= n; i++) {\n    v[i + 1] = v[i];\n}\n\nv[k] = x;\n\nn++; \n</code></pre> <p>Se poate observa cu u\u0219urin\u021b\u0103 c\u0103 valoarea de pe pozi\u021bia \\(k\\) va ajunge peste tot dac\u0103 implement\u0103m a\u0219a, ceea ce este gre\u0219it.</p>","tags":["vectori"]},{"location":"usor/tablouri/#stergerea-din-tablou","title":"\u0218tergerea din tablou","text":"<p>Dac\u0103 avem un tablou cu \\(n\\) valori \u0219i vrem s\u0103 \u0219tergem valoarea de la pozi\u021bia \\(k\\), unde \\(1 \\leq k \\leq n\\), vom vrea s\u0103 mut\u0103m pe r\u00e2nd valorile de la pozi\u021biile \\(k+1\\), \\(k+2\\), ..., \\(n\\) cu o pozi\u021bie mai \u00een spate. Spre deosebire de cazul inser\u0103rii, vom vrea s\u0103 mut\u0103m valorile \u00een ordine cresc\u0103toare a pozi\u021biei ini\u021biale. </p> <pre><code>for (int i = k; i &lt; n; i++) {\n    v[i] = v[i + 1];\n}\n\n\nn--; // (1)\n</code></pre> <ol> <li>Tabloul va avea o valoare \u00een minus, drept pentru care trebuie s\u0103      sc\u0103dem \u00een consecin\u021b\u0103 lungimea sa.</li> </ol> <p>Aten\u021bie</p> <p>Mutarea valorilor trebuie f\u0103cut\u0103 \u00een ordine cresc\u0103toare a pozi\u021biilor ini\u021biale deoarece altfel, am ajunge s\u0103 avem aceea\u0219i valoare peste tot.</p> <pre><code>for (int i = n; i &gt; k; i--) {\n    v[i - 1] = v[i];\n}\n\nn--; \n</code></pre>","tags":["vectori"]},{"location":"usor/tablouri/#inversarea-unui-tablou","title":"Inversarea unui tablou","text":"<p>Pentru a putea inversa un tablou, trebuie s\u0103 \u0219tim num\u0103rul de elemente pe care \u00eel are. Scopul nostru este s\u0103 avem pe pozi\u021bia \\(i\\) valoarea ce se afla anterior pe pozi\u021bia \\(n - i + 1\\), implementarea nefiind prea dificil\u0103. Pentru a p\u0103stra scopul educativ, am implementat interschimbarea elementelor folosind \"regula celor trei pahare\".</p> <pre><code>for (int i = 1; i &lt;= n / 2; i++) {\n    int x = v[i];         // (1)\n    v[i] = v[n - i + 1];  // (2)\n    v[n - i + 1] = x;     // (3)\n}\n</code></pre> <ol> <li>Re\u021binem valoarea lui <code>v[i]</code> \u00een <code>x</code>.</li> <li>Interschimb\u0103m <code>v[i]</code> cu pozi\u021bia echivalent\u0103 de la cap\u0103tul tabloului, adic\u0103 <code>v[n - i + 1]</code>. </li> <li>Re\u021binem valoarea lui <code>v[i]</code> \u00een <code>x</code>.</li> </ol>","tags":["vectori"]},{"location":"usor/tablouri/#interclasarea-tablourilor","title":"Interclasarea tablourilor","text":"<p>Pentru a putea interclasa dou\u0103 tablouri (de regul\u0103, cresc\u0103toare) \\(A\\) \u0219i \\(B\\), av\u00e2nd \\(n\\), respectiv \\(m\\) elemente, vom vrea mereu s\u0103 introducem valoarea mai mic\u0103 \u00een tabloul unde \u021binem rezultatul, \\(C\\), acesta av\u00e2nd lungimea \\(n + m\\). De asemenea, vom vrea s\u0103 avem grij\u0103 ca dup\u0103 ce prelucr\u0103m complet unul din cele dou\u0103 tablouri, s\u0103 continu\u0103m inser\u0103rile cu cel de-al doilea tablou, unul din ele ar r\u0103m\u00e2ne mereu cu valori. </p> <p>Observa\u021bie</p> <p>Folosind acest algoritm de interclasare, putem ob\u021bine un tablou cresc\u0103tor \u00een \\(\\mathcal{O}(n + m)\\), unde \\(n\\) \u0219i \\(m\\) sunt lungimile celor dou\u0103 \u0219iruri. </p> <p>Observa\u021bie</p> <p>Folosind un algoritm similar cu cel prezentat mai jos, putem implementa diverse opera\u021bii pe mul\u021bimi, precum reuniunea, intersec\u021bia \u0219i diferen\u021ba.</p> <pre><code>int i = 1;\nint j = 1;\nint poz = 0;\n\n// Mergem prin tablou p\u00e2n\u0103 c\u00e2nd am parcurs unul din ele.\nwhile (i &lt;= n &amp;&amp; j &lt;= m) {\n    poz++;\n\n    // Punem \u00een C elementul mai mic dintre A[i] \u0219i B[j]\n    if (A[i] &lt;= B[j]) {\n        C[poz] = A[i];\n        i++;\n    } else {\n        C[poz] = B[j];\n        j++;\n    }\n}\n\n// Dac\u0103 mai exist\u0103 elemente \u00een A, adaug\u0103-le \u00een C.\nwhile (i &lt;= n) {\n    poz++;\n    C[poz] = A[i];\n    i++;\n}\n\n// Dac\u0103 mai exist\u0103 elemente \u00een B, adaug\u0103-le \u00een C.\nwhile (j &lt;= m) {\n    poz++;\n    C[poz] = B[j];\n    j++;\n}\n</code></pre>","tags":["vectori"]},{"location":"usor/tablouri/#rotirea-tablourilor","title":"Rotirea tablourilor","text":"<p>Pentru a putea roti un tablou la st\u00e2nga sau la dreapta, va trebui s\u0103 mut\u0103m toate elementele cu o pozi\u021bie la st\u00e2nga/dreapta, iar pentru a putea face asta, va trebui mai \u00eent\u00e2i s\u0103 p\u0103str\u0103m \u00een memorie valoarea de pe prima/ultima pozi\u021bie, s\u0103 mut\u0103m secven\u021bial celelalte valori \u0219i \u00een cele din urm\u0103 s\u0103 mut\u0103m valoarea p\u0103strat\u0103 pe ultima/prima pozi\u021bie \u00een \u0219irul nou rezultat. \u00cen mod similar, putem implementa rotirea cu \\(k\\) pozi\u021bii, folosind \\(\\mathcal{O}(k)\\) memorie suplimentar\u0103. </p> <p>De\u0219i algoritmul prezentat este unul liniar, mai t\u00e2rziu pute\u021bi descoperi un algoritm ce ruleaz\u0103 \u00een timp constant pentru o rota\u021bie la st\u00e2nga sau la dreapta.</p> <pre><code>void rotire(int arr[], int n, bool laStanga = true, int k = 1) {\n    k = k % n;\n\n    // Dac\u0103 k = 0 sau multiplu de n, nu facem nimic.\n    if (k == 0) {\n        return;\n    }\n\n    int temp[k];\n    if (laStanga) {\n        rotireLaStanga(arr, n, k);\n    } else {\n        rotireLaDreapta(arr, n, k);\n    }\n}\n</code></pre> Rotire la st\u00e2ngaRotire la dreapta <pre><code>void rotireLaStanga(int arr[], int n, int k) {\n    int* temp = new int[k];\n\n    // P\u0103str\u0103m primele k elemente\n    for (int i = 0; i &lt; k; ++i) {\n        temp[i] = arr[i];  // P\u0103str\u0103m primele k elemente\n    }\n\n    // Mut\u0103m elementele spre st\u00e2nga\n    for (int i = 0; i &lt; n - k; ++i) {\n        arr[i] = arr[i + k];\n    }\n\n    // Plas\u0103m elementele p\u0103strate la sf\u00e2r\u0219it\n    for (int i = 0; i &lt; k; ++i) {\n        arr[n - k + i] = temp[i];\n    }\n\n    delete[] temp;\n}\n</code></pre> <pre><code>void rotireLaDreapta(int arr[], int n, int k) {\n    int* temp = new int[k];\n\n    // P\u0103str\u0103m ultimele k elemente\n    for (int i = 0; i &lt; k; ++i) {\n        temp[i] = arr[n - k + i];\n    }\n\n    // Mut\u0103m elementele spre dreapta\n    for (int i = n - 1; i &gt;= k; --i) {\n        arr[i] = arr[i - k];\n    }\n\n    // Plas\u0103m elementele p\u0103strate la \u00eenceput\n    for (int i = 0; i &lt; k; ++i) {\n        arr[i] = temp[i];\n    }\n\n    delete[] temp;\n}\n</code></pre>","tags":["vectori"]}]}